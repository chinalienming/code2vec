1	src/com/google/javascript/jscomp/RemoveUnusedVars.java内private void removeUnreferencedFunctionArgs(Scope fnScope)	2353d807058bc2a20af279a480d6652cdf892f4d	1dfad5043a207e032a78ef50c3cba50488bcd300	253	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-253.json	function arguments should not be optimized away	Function arguments should not be optimized away, as this comprimizes the function's length property.    What steps will reproduce the problem?   // ==ClosureCompiler==  // @compilation_level SIMPLE_OPTIMIZATIONS  // @output_file_name default.js  // ==/ClosureCompiler==  function foo (bar, baz) {    return bar;  }  alert (foo.length);  function foo (bar, baz) {    return bar;  }  alert (foo.length);    --------------------------------------    What is the expected output?    function foo(a,b){return a}alert(foo.length);    --------------------------------------    What do you see instead?    function foo(a){return a}alert(foo.length);    --------------------------------------    What version of the product are you using? On what operating system?   I'm using the product from the web page http://closure-compiler.appspot.com/home    I'm using Firefox 3.6.10 on Ubuntu 10.0.4    Please provide any additional information below.   The function's length property is essential to many techniques, such as currying functions.	src
2	src/com/google/javascript/jscomp/TypeCheck.java内private void checkInterfaceConflictProperties(NodeTraversal t, Node n, String functionName, HashMap<String, ObjectType> properties, HashMap<String, ObjectType> currentProperties, ObjectType interfaceType)	61095090415cff7cae4f3645fa76ee7cdd3ee23d	d1cfe67977d8f3aaa85ec20c262171da394d5977	884	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-884.json	combining @interface and multiple @extends can crash compiler	Compile this:  ---------------------------------  // ==ClosureCompiler==  // @compilation_level SIMPLE_OPTIMIZATIONS  // @warning_level VERBOSE  // @output_file_name default.js  // ==/ClosureCompiler==    /**   * @interface   * @extends {unknown_1}   * @extends {unknown_2}   */  function Foo() {}  ---------------------------------    => Get this..  ---------------------------------------  23: java.lang.NullPointerException   at com.google.javascript.jscomp.TypeCheck.checkInterfaceConflictProperties(TypeCheck.java:1544)   at com.google.javascript.jscomp.TypeCheck.visitFunction(TypeCheck.java:1635)   at com.google.javascript.jscomp.TypeCheck.visit(TypeCheck.java:761)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:509)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:502)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:502)   at com.google.javascript.jscomp.NodeTraversal.traverseWithScope(NodeTraversal.java:347)   at com.google.javascript.jscomp.TypeCheck.check(TypeCheck.java:400)   at com.google.javascript.jscomp.TypeCheck.process(TypeCheck.java:371)   at com.google.javascript.jscomp.DefaultPassConfig$29$1.process(DefaultPassConfig.java:1209)   at com.google.javascript.jscomp.PhaseOptimizer$PassFactoryDelegate.processInternal(PhaseOptimizer.java:303)   at com.google.javascript.jscomp.PhaseOptimizer$NamedPass.process(PhaseOptimizer.java:279)   at com.google.javascript.jscomp.PhaseOptimizer.process(PhaseOptimizer.java:191)   at com.google.javascript.jscomp.Compiler.check(Compiler.java:814)   at com.google.javascript.jscomp.Compiler.compileInternal(Compiler.java:729)   at com.google.javascript.jscomp.Compiler.access$000(Compiler.java:85)   at com.google.javascript.jscomp.Compiler$2.call(Compiler.java:637)   at com.google.javascript.jscomp.Compiler$2.call(Compiler.java:634)   at com.google.javascript.jscomp.Compiler.runInCompilerThread(Compiler.java:694)   at com.google.javascript.jscomp.Compiler.compile(Compiler.java:634)   at com.google.javascript.jscomp.Compiler.compile(Compiler.java:590)   at com.google.javascript.jscomp.webservice.backend.CompilerInvokerImpl.compile(CompilerInvokerImpl.java:47)   at com.google.javascript.jscomp.webservice.backend.ServerController.executeRequest(ServerController.java:177)   at com.google.javascript.jscomp.webservice.backend.CompilationRequestHandler.serviceParsedRequest(CompilationRequestHandler.java:180)   at com.google.javascript.jscomp.webservice.backend.CompilationRequestHandler.service(CompilationRequestHandler.java:162)   at com.google.javascript.jscomp.webservice.frontend.CompilationServlet.doPost(CompilationServlet.java:83)   at javax.servlet.http.HttpServlet.service(HttpServlet.java:637)   at javax.servlet.http.HttpServlet.service(HttpServlet.java:717)   at org.mortbay.jetty.servlet.ServletHolder.handle(ServletHolder.java:511)   at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1166)   at com.google.apphosting.utils.servlet.ParseBlobUploadFilter.doFilter(ParseBlobUploadFilter.java:102)   at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1157)   at com.google.apphosting.runtime.jetty.SaveSessionFilter.doFilter(SaveSessionFilter.java:35)   at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1157)   at com.google.apphosting.utils.servlet.TransactionCleanupFilter.doFilter(TransactionCleanupFilter.java:43)   at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1157)   at org.mortbay.jetty.servlet.ServletHandler.handle(ServletHandler.java:388)   at org.mortbay.jetty.security.SecurityHandler.handle(SecurityHandler.java:216)   at org.mortbay.jetty.servlet.SessionHandler.handle(SessionHandler.java:182)   at org.mortbay.jetty.handler.ContextHandler.handle(ContextHandler.java:765)   at org.mortbay.jetty.webapp.WebAppContext.handle(WebAppContext.java:418)   at com.google.apphosting.runtime.jetty.AppVersionHandlerMap.handle(AppVersionHandlerMap.java:266)   at org.mortbay.jetty.handler.HandlerWrapper.handle(HandlerWrapper.java:152)   at org.mortbay.jetty.Server.handle(Server.java:326)   at org.mortbay.jetty.HttpConnection.handleRequest(HttpConnection.java:542)   at org.mortbay.jetty.HttpConnection$RequestHandler.headerComplete(HttpConnection.java:923)   at com.google.apphosting.runtime.jetty.RpcRequestParser.parseAvailable(RpcRequestParser.java:76)   at org.mortbay.jetty.HttpConnection.handle(HttpConnection.java:404)   at com.google.apphosting.runtime.jetty.JettyServletEngineAdapter.serviceRequest(JettyServletEngineAdapter.java:146)   at com.google.apphosting.runtime.JavaRuntime$RequestRunnable.run(JavaRuntime.java:447)   at com.google.tracing.TraceContext$TraceContextRunnable.runInContext(TraceContext.java:454)   at com.google.tracing.TraceContext$TraceContextRunnable$1.run(TraceContext.java:461)   at com.google.tracing.TraceContext.runInContext(TraceContext.java:703)   at com.google.tracing.TraceContext$AbstractTraceContextCallback.runInInheritedContextNoUnref(TraceContext.java:338)   at com.google.tracing.TraceContext$AbstractTraceContextCallback.runInInheritedContext(TraceContext.java:330)   at com.google.tracing.TraceContext$TraceContextRunnable.run(TraceContext.java:458)   at com.google.apphosting.runtime.ThreadGroupPool$PoolEntry.run(ThreadGroupPool.java:251)   at java.lang.Thread.run(Thread.java:679)    Original Post Data:   output_format=json&output_info=compiled_code&output_info=warnings&output_info=errors&output_info=statistics&compilation_level=SIMPLE_OPTIMIZATIONS&warning_level=VERBOSE&output_file_name=default.js&js_code=%2F**%0A*%20%40interface%0A*%20%40extends%20%7BA%7D%0A*%20%40extends%20%7BB%7D%0A*%2F%0Afunction%20Foo()%20%7B%7D  ------------------      Seems like a combination of @interface plus more than one @extend and where at least one of the @extend types are unknown causes a crash.    Regards  / Fredrik Blomqvist	src
3	src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java内public void enterScope(NodeTraversal t)外src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java内private Node getDefCfgNode()外src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java内public boolean apply(Node input)	3cc85c3c37aa8bc834a4a86f91ddeb399d854024	d80fcc04239ab8c4cf781273c4f9bc54cf06f479	864	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-864.json	optimization fails with variable in catch clause	Enter the following in the closure service:    function getStack() {    var getErrorObject = function() {      try {        throw Error("");      } catch(err) {        return err;      }    };    return getErrorObject().stack;  }  window['getStackTrace']=getStack;    Use Optimization = Simple. Note the following result:    function getStack()   {     try     {       throw Error("");     }    catch(a)     {     }     return a.stack   }   window.getStackTrace = getStack;    The scope of the variable a is limited to the catch clause, but the compiler references it illegally as the return value of the inlined function.  	src
4	src/com/google/javascript/rhino/jstype/NamedType.java内JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing)外src/com/google/javascript/rhino/jstype/NamedType.java内JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing)	1c95684b4a6add525b3070cbd27c234981520676	efefb736fccc2039b5fb079710b3f2ac82b8c6e4	873	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-873.json	Converting from an interface type to a constructor which @implements itself causes stack overflow.	// Options: --externs externs/es3.js --property_renaming OFF --variable_renaming OFF --jscomp_warning=checkTypes --js=t.js      // File: t.js  /**   * @interface   */  var OtherType = function() {}    /**   * @implements {MyType}   * @constructor   */  var MyType = function() {}    /**   * @type {MyType}   */  var x = /** @type {!OtherType} */ (new Object());    Get Infinite recursion in:    PrototypeObjectType.isSubtype @ 350    Options:    - prevent cycles in the inheritance/implements graph  - detect cycles after they are created and exit compilation before any subsequent passes run  - detect and remove cycles after they are created but before any subsequent passes run  - make every subsequent pass robust against cycles in that graph	src
5	src/com/google/javascript/jscomp/InlineObjectLiterals.java内private boolean isInlinableObject(List<Reference> refs)	722d1192e7ed174a12911dce09594228e31240e9	59eec92e364b2ec2cec9dd63449f5c0134983f18	851	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-851.json	Compiler ignores 'delete' statements, can break functionality.	When the compiler rewrites internally-referenced object variables to non-object  variables, as in the example below, it ignores 'delete' statements. These delete statements work as expected with the objects originally written, but don't function the same when the variables are no longer object properties. See:    (function(arg) {    var foo = {};      foo.bar = arg;      console.log(foo.bar);      delete foo.bar;      console.log(foo.bar);  })();    Compiles to (simple setting):  (function(a){console.log(a);delete a;console.log(a)})();    Perhaps the compiler needs to look for these delete statements and change them to setting the rewritten variable to undefined instead.	src
6	src/com/google/javascript/jscomp/TypeValidator.java内boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName)外src/com/google/javascript/jscomp/TypeValidator.java内boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName)外src/com/google/javascript/jscomp/TypeValidator.java内boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName)	929b1c8fb38d8a7145f6e6f96255a764d92f5b3c	9f7a353385bf0b93cdaeaa56cc5b1450db790127	635	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-635.json	better 'this' type checking	/** @constructor */  function F() {}  F.prototype.bar = function() { this.baz(); };  F.prototype.baz = function() { };    /** @constructor */  function G() {}  G.prototype.bar = F.prototype.bar;    We should notice that "F.prototype.bar" and "G.prototype.bar" have different "this" types, and emit a warning.	src
7	src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java内public JSType caseNumberType()	d93f2d5aaf346749eaa6ae1641a171aeb177de5d	e736b1c92981fafdc87f3f41f66918305f173734	841	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-841.json	Bad type inference with goog.isFunction and friends	experimental/johnlenz/typeerror/test.js:16: WARNING - Property length  never defined on Number        var i = object.length;      This is the reduced test case:    /**   * @param {*} object Any object.   * @return {boolean}   */  test.isMatched = function(object) {    if (goog.isDef(object)) {      if (goog.isFunction(object)) {        // return object();      } else if (goog.isBoolean(object)) {        // return object;      } else if (goog.isString(object)) {        // return test.isDef(object);      } else if (goog.isArray(object)) {        var i = object.length;      }    }    return false;  };	src
8	src/com/google/javascript/jscomp/CollapseVariableDeclarations.java内private boolean canBeRedeclared(Node n, Scope s)	e237d2643b102fbea616717806391f48e2ce506a	6300a43566d4adcf8828128267808a8740edc835	820	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-820.json	Obfuscated code triggers TypeError in Firefox	The Closure Compiler is a great tool, but I'm having problems with it. It often produces code that triggers TypeError in Firefox, even though original code does not. Here is why. The original code may look as follows:    function(argument){  ...//use argument  var variable = ...;  ...//argument not used anymore  }    But often Closure Compiler will translate it to:  function(a){  ...  var a = ...;  ...  }    This is not wrong JS, since argument is no longer used, Closure Compiler tries to reuse the name 'a' for something else.    This triggers the following in Firefox 13-15:  TypeError: variable a re-declares argument    Still, the resulting code is correct and runs, but it's very annoying debugging it when I'm getting all the time a lot of TypeErrors in the console.    Also, our customers have noticed these TypeErrors when testing the product and it undermines our code reliability.    Could you please rename variables in such a way as to avoid these TypeErrors (not to rename vars in a way that will coincide with function argument names)?    What steps will reproduce the problem? This happens reproducibly on our real-life JS input, which I cannot submit for various reasons. If my problem description is not clear enough, please make a comment and I will try to construct some artificial example that also triggers the TypeError.    What is the expected output? What do you see instead? The expected output is obfuscated code with variables renamed to unique names, in order not to trigger TypeError in Firefox. Instead I see variables renamed to the same name, which runs OK, but Firefox complains with TypeError.    What version of the product are you using? On what operating system? Closure Compiler (http://code.google.com/closure/compiler)  Version: 20120917 (revision 2180)  Built on: 2012/09/17 14:33    Please provide any additional information below. 	src
9	src/com/google/javascript/jscomp/ProcessCommonJSModules.java内public static String toModuleName(String requiredFilename, String currentFilename)外src/com/google/javascript/jscomp/ProcessCommonJSModules.java内private void visitScript(NodeTraversal t, Node script)	19233b94d925c331933feff6268dc2941fa988b1	e9c15465c000c19ef4e0b8f68a680589ae4111d7	824	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-824.json	Compiler fails to find amd module in a subdirectory	What steps will reproduce the problem?   1. Create 1st AMD module in lib/Foo.js  2. Create 2nd AMD module in Bar.js depending on lib/Foo.js  3. Try to compile both files with Bar.js as main module    What is the expected output? What do you see instead?   java -jar compiler.jar --transform_amd_modules --process_common_js_modules --common_js  _entry_module=Bar.js --compilation_level=ADVANCED_OPTIMIZATIONS --js_output_file=out.js --js=Bar.js --js=lib/Foo.js  ERROR - required entry point "module$lib$Foo" never provided    1 error(s), 0 warning(s)  make: *** [out.js] Error 1    What version of the product are you using? On what operating system?   Latest version from trunk including fix for issue #804    Please provide any additional information below.   Find minimal not-working example attached with Makefile. The same setup has been working prior to fix for #804 (although with backslashes). This feature does not seem to have enough unit test coverage.  	src
10	src/com/google/javascript/jscomp/NodeUtil.java内static boolean mayBeString(Node n)	f681fd8045bfa4a41f3a66c942b97fb04335b7cc	0884a4cbef1c82153ef306477a12af0480385a35	821	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-821.json	Wrong code generated if mixing types in ternary operator	What steps will reproduce the problem? 1. Use Google Closure Compiler to compile this code:        var a =(Math.random()>0.5? '1' : 2 ) + 3 + 4;    You can either simple or advanced. It doesn't matter      What is the expected output? What do you see instead?   I'm seeing this as a result:      var a = (0.5 < Math.random() ? 1 : 2) + 7;    This is obviously wrong as the '1' string literal got converted to a number, and 3+4 got combined into 7 while that's not ok as '1' + 3 + 4 = '134', not '17'.    What version of the product are you using? On what operating system? Please provide any additional information below.   Seems like this issue happens only when you are mixing types together. If both 1 and 2 are string literals or if they are both numbers it won't happen. I was also a little surprised to see this happening in simple mode as it actually breaks the behavior.	src
11	src/com/google/javascript/jscomp/TypeCheck.java内private void visitGetProp(NodeTraversal t, Node n, Node parent)	bbf1b138e20a36ca79b2a012ae145c943929a6dd	482b767639e6eec7c30d8898851560c41b66d885	810	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-810.json	Record type invalid property not reported on function with @this annotation	Code:    var makeClass = function(protoMethods) {    var clazz = function() {      this.initialize.apply(this, arguments);    }    for (var i in protoMethods) {      clazz.prototype[i] = protoMethods[i];    }      return clazz;  }    /**   * @constructor   * @param {{name: string, height: number}} options   */  var Person = function(options){};  Person = makeClass(/** @lends Person.prototype */ {    /**     * @this {Person}     * @param {{name: string, height: number}} options     */    initialize: function(options) {      /** @type {string} */ this.name_ = options.thisPropDoesNotExist;    },      /**     * @param {string} message     * @this {Person}     */    say: function(message) {      window.console.log(this.name_ + ' says: ' + message);    }  });      var joe = new Person({name: 'joe', height: 300});  joe.say('hi');      compiled with:  java -jar build/compiler.jar --formatting=PRETTY_PRINT --jscomp_error=checkTypes --jscomp_error=externsValidation --compilation_level=SIMPLE_OPTIMIZATIONS repro.js      I would expect an error on this line:      /** @type {string} */ this.name_ = options.thisPropDoesNotExist;    which works in other contexts.    Thanks!  	src
12	src/com/google/javascript/jscomp/MaybeReachingVariableUse.java内ReachingUses flowThrough(Node n, ReachingUses input)	919fda930ca242e2d1490e6413b601c8bad701b4	d06ac163013a3779fcec7c2f544ba99d08f69f58	794	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-794.json	Try/catch blocks incorporate code not inside original blocks	What steps will reproduce the problem?   Starting with this code:    -----  function a() {   var x = '1';   try {    x += somefunction();   } catch(e) {   }   x += "2";   try {    x += somefunction();   } catch(e) {   }   document.write(x);  }    a();  a();  -----    It gets compiled to:    -----  function b() {    var a;    try {      a = "1" + somefunction()    }catch(c) {    }    try {      a = a + "2" + somefunction()    }catch(d) {    }    document.write(a)  }  b();  b();  -----    What is the expected output? What do you see instead?   The problem is that it's including the constant "1" and "2" inside the try block when the shouldn't be. When executed uncompiled, the script prints "1212". When compiled, the script prints "undefinedundefined".    This behavior doesn't happen if the entire function gets inlined, or if the code between the two try blocks is sufficiently complex.      What version of the product are you using? On what operating system?   Closure Compiler (http://code.google.com/closure/compiler)  Version: 20120430 (revision 1918)  Built on: 2012/04/30 18:02  java version "1.6.0_33"  Java(TM) SE Runtime Environment (build 1.6.0_33-b03-424-11M3720)  Java HotSpot(TM) 64-Bit Server VM (build 20.8-b03-424, mixed mode)  	src
13	src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java内private void traverse(Node node)	8b8c01a39b94069a9dac08b92c27dc9b9532ff7f	d6d733f461ee5ba26e9326c1c7609f1f00d6d2db	787	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-787.json	true/false are not always replaced for !0/!1	What steps will reproduce the problem?   function some_function() {    var fn1;    var fn2;      if (any_expression) {      fn2 = external_ref;      fn1 = function (content) {        return fn2();      }    }      return {      method1: function () {        if (fn1) fn1();        return true;      },      method2: function () {        return false;      }    }  }    What is the expected output? What do you see instead?   We expect that true/false will be replaced for !0/!1, but it doesn't happend.    function some_function() {    var a, b;    any_expression && (b = external_ref, a = function () {      return b()    });    return {      method1: function () {        a && a();        return true      },      method2: function () {        return false      }    }  };    What version of the product are you using? On what operating system?   This is output for latest official build.  I also got the same output for 20120430, 20120305. But 20111117 is OK.    Please provide any additional information below.   Here is just one of example. I found too many non-replaced true/false in compiler output. Replacement non-replaced true/false to !1/!0 in conpiler output saves 1-2 kb for 850 kb js file.	src
14	src/com/google/javascript/jscomp/ControlFlowAnalysis.java内private static Node computeFollowNode( Node fromNode, Node node, ControlFlowAnalysis cfa)	b7c2861bf45b358b26ebc5ee1be9b6ce96bec78a	4b15b25f400335b6e2820cb690430324748372f9	779	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-779.json	bogus 'missing return' warning	The following sample code compiles with "Missing return statement. Function expected to return boolean." warning:    /**   * @return {boolean}   */  function fb(a)  {      try      {          alert(a);      // Some method, which can throw          if (a > 0)              return false;      }      finally      {          a = 5;      }            return true;  }	src
15	src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java内public boolean apply(Node n)	f9fbad23b8fb59464e395c164197750abb5db296	968b3f467f51c6bfec18af1fbcf980a0f19a1fb3	773	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-773.json	Switched order of "delete key" and "key in" statements changes semantic	// Input:    var customData = { key: 'value' };    function testRemoveKey( key ) {   var dataSlot = customData,    retval = dataSlot && dataSlot[ key ],    hadKey = dataSlot && ( key in dataSlot );     if ( dataSlot )    delete dataSlot[ key ];     return hadKey ? retval : null;  };    console.log( testRemoveKey( 'key' ) ); // 'value'  console.log( 'key' in customData ); // false      // Compiled version:    var customData={key:"value"};function testRemoveKey(b){var a=customData,c=a&&a[b];a&&delete a[b];return a&&b in a?c:null}console.log(testRemoveKey("key"));console.log("key"in customData);    // null  // false      "b in a" is executed after "delete a[b]" what obviously doesn't make sense in this case.      Reproducible on: http://closure-compiler.appspot.com/home and in "Version: 20120430 (revision 1918) Built on: 2012/04/30 18:02"	src
16	src/com/google/javascript/jscomp/ScopedAliases.java内public void applyAlias()外src/com/google/javascript/jscomp/ScopedAliases.java内private void fixTypeNode(Node typeNode)	33ab4df84afbdb36216b8a1ea3a526c438615e26	3b97e5e4212c769daa22a96094ed19b4658c8760	772	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-772.json	JSCompiler does not recursively resolve typedefs	goog.provide('a.b.c');    goog.scope(function() {  var b = a.b;  var c = b.c;    /** @typedef {string} */  c.MyType;    /** @param {c.MyType} x The variable. */  c.myFunc = function(x) {};    });    results in a compiler error.    given that JSCompiler *does* recursively resolve other names, this appears to be a bug rather than an intended limitation.  	src
17	src/com/google/javascript/jscomp/TypedScopeCreator.java内private JSType getDeclaredType(String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue)	e5e1253ac6d43e26271cc658a42fdb1477454faf	33ab4df84afbdb36216b8a1ea3a526c438615e26	688	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-688.json	@const dumps type cast information	The following code compiles fine:    /**  * Class defining an interface with two numbers.  * @interface  */  function TwoNumbers() {}    /** @type number */  TwoNumbers.prototype.first;    /** @type number */  TwoNumbers.prototype.second;    var SOME_DEFAULT =    /** @type {TwoNumbers} */ ({first: 1, second: 2});    /**   * Class with a two number member.   * @constructor   */  function HasTwoNumbers() {    /** @type {TwoNumbers} */    this.twoNumbers = this.getTwoNumbers();  }    /**   * Get the default two numbers.   * @return {TwoNumbers}   */  HasTwoNumbers.prototype.getTwoNumbers = function() {    return SOME_DEFAULT;  };    Now realizing that SOME_DEFAULTS is actually a preset constant which should not change I would like to say for that line (just adding an @const)    /** @const */ var SOME_DEFAULT =    /** @type {TwoNumbers} */ ({first: 1, second: 2});    However that starts throwing warnings as adding the @const makes the compiler dump the type. (Does the value get inlined without the typecast?)    Expected:  Compiles fine.    Error can be reproduced on:  http://closure-compiler.appspot.com/home  copy-past the attached file in there, it throws a warning and does not compile.	src
18	src/com/google/javascript/jscomp/Compiler.java内Node parseInputs()	686146c4de7d2bd985156ae15175365633dd0f94	ea119a2d06328852763f9ee447c3bf74fa1f83dc	768	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-768.json	Dependency sorting with closurePass set to false no longer works.	What steps will reproduce the problem?   1. Instantiate new instance of Compiler    2. Set closurePass to false to prevent goog.require/goog.provide removal.  compilerOptions.setClosurePass(false);    3. Turn dependency sorting on.  DependencyOptions dependencyOptions = new DependencyOptions();  dependencyOptions.setDependencySorting(true);    4. Compile js code      What is the expected output?   Dependent files should be sorted and concatenated in their dependent order.    What do you see instead?  Dependent files are not sorted.    What version of the product are you using? On what operating system? > r1824  mac OS 10.7      Please provide any additional information below. This worked in the r1810 release. However, it looks like this was changed in r1824. The compiler now expects closurePass to be true for dependency sorting to work.  http://code.google.com/p/closure-compiler/source/detail?path=/trunk/src/com/google/javascript/jscomp/Compiler.java&r=1824    What we are looking for is a way to sort dependencies and concatenate all files in their dependent order without removing the goog.require/goog.provide js calls. Turning closurePass to true causes the goog calls to be replaced. We use this methodology in local development to test our JS code.    Thanks!  	src
19	src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java内protected void declareNameInScope(FlowScope scope, Node node, JSType type)	8d91f37d29abd8682e298a23f63b96f2f2def659	686146c4de7d2bd985156ae15175365633dd0f94	769	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-769.json	Type refining of 'this' raises IllegalArgumentException	What steps will reproduce the problem? 1. goog.isFunction(this) or goog.isObject(this) or goog.isNull(this) etc.    What is the expected output? What do you see instead?   Expected: normal compilation, checking the type of this  Actual output:    23: java.lang.IllegalArgumentException: Node cannot be refined.   THIS 1 [source_file: Input_0] : global this     at com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter.declareNameInScope(ChainableReverseAbstractInterpreter.java:172)   at com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter.restrictParameter(ClosureReverseAbstractInterpreter.java:240)   at com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter.getPreciserScopeKnowingConditionOutcome(ClosureReverseAbstractInterpreter.java:221)   at com.google.javascript.jscomp.TypeInference.branchedFlowThrough(TypeInference.java:239)   at com.google.javascript.jscomp.TypeInference.branchedFlowThrough(TypeInference.java:59)   at com.google.javascript.jscomp.DataFlowAnalysis$BranchedForwardDataFlowAnalysis.flow(DataFlowAnalysis.java:448)   at com.google.javascript.jscomp.DataFlowAnalysis.analyze(DataFlowAnalysis.java:213)   at com.google.javascript.jscomp.DataFlowAnalysis.analyze(DataFlowAnalysis.java:181)   at com.google.javascript.jscomp.TypeInferencePass.inferTypes(TypeInferencePass.java:90)   at com.google.javascript.jscomp.TypeInferencePass$TypeInferringCallback.enterScope(TypeInferencePass.java:106)   at com.google.javascript.jscomp.NodeTraversal.pushScope(NodeTraversal.java:581)   at com.google.javascript.jscomp.NodeTraversal.traverseWithScope(NodeTraversal.java:345)   at com.google.javascript.jscomp.TypeInferencePass.inferTypes(TypeInferencePass.java:81)   at com.google.javascript.jscomp.TypeInferencePass.process(TypeInferencePass.java:74)   at com.google.javascript.jscomp.DefaultPassConfig$24$1.process(DefaultPassConfig.java:1119)   at com.google.javascript.jscomp.PhaseOptimizer$PassFactoryDelegate.processInternal(PhaseOptimizer.java:296)   at com.google.javascript.jscomp.PhaseOptimizer$NamedPass.process(PhaseOptimizer.java:273)   at com.google.javascript.jscomp.PhaseOptimizer.process(PhaseOptimizer.java:187)   at com.google.javascript.jscomp.Compiler.check(Compiler.java:768)   at com.google.javascript.jscomp.Compiler.compileInternal(Compiler.java:683)   at com.google.javascript.jscomp.Compiler.access$000(Compiler.java:79)   at com.google.javascript.jscomp.Compiler$1.call(Compiler.java:586)   at com.google.javascript.jscomp.Compiler$1.call(Compiler.java:583)   at com.google.javascript.jscomp.Compiler$2.run(Compiler.java:628)   at com.google.javascript.jscomp.Compiler.runCallable(Compiler.java:651)   at com.google.javascript.jscomp.Compiler.runInCompilerThread(Compiler.java:601)   at com.google.javascript.jscomp.Compiler.compile(Compiler.java:583)    What version of the product are you using? On what operating system?   Any version (local and http://closure-compiler.appspot.com/).    Please provide any additional information below.   A workaround is to assign 'this' to a variable. "var a=this;goog.isNull(a)" works.	src
20	src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java内private Node tryFoldSimpleFunctionCall(Node n)	7e98b9c9511d197ed572b73214814ccb546a4b78	ebf229b05f4ee71bc05d70830f5dd5683271d661	759	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-759.json	String conversion optimization is incorrect	What steps will reproduce the problem?   var f = {    valueOf: function() { return undefined; }  }  String(f)    What is the expected output? What do you see instead?   Expected output: "[object Object]"  Actual output: "undefined"    What version of the product are you using? On what operating system?   All versions (http://closure-compiler.appspot.com/ as well).    Please provide any additional information below.   The compiler optimizes String(x) calls by replacing them with x + ''. This is correct in most cases, but incorrect in corner cases like the one mentioned above.	src
21	src/com/google/javascript/jscomp/CheckSideEffects.java内public void visit(NodeTraversal t, Node n, Node parent)外src/com/google/javascript/jscomp/CheckSideEffects.java内public void visit(NodeTraversal t, Node n, Node parent)	a9250a5aac439a72f71c248de07f042674fb2076	1787d7b2cff83a0f177dd958033c53e4502406d2	753	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-753.json	Classify non-rightmost expressions as problematic	Purpose of code changes: When it comes to an expression involving the comma operator, only the  first element of such a sequence is checked for being free of side  effects. If the element is free of side effects, it is classified as  problematic and a warning is issued.    As other non-rightmost elements are not checked for being free of side  effects and therefore cannot be classified as problematic, this leads  to unexpected behavior:    1. foo((1, 2, 42)) is transformed into foo((1, 3)) and a warning is  issued only with regard to the first element.  2. foo((bar(), 2, 42)) is transformed into foo((bar(), 3)) and no  warning is issued.  3. foo(((1, 2, 3), (4, 5, 42))) is transformed into foo((1, 4, 42)) and  warnings are issued with regard to the first elements of inner  sequences only.	src
22	src/com/google/javascript/jscomp/CheckSideEffects.java内public void visit(NodeTraversal t, Node n, Node parent)	c8e5f7acc524fe629f73876acfb463619a02f34b	43a55234ef122a1ed98681ce0350506207b878d5	753	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-753.json	Classify non-rightmost expressions as problematic	Purpose of code changes: When it comes to an expression involving the comma operator, only the  first element of such a sequence is checked for being free of side  effects. If the element is free of side effects, it is classified as  problematic and a warning is issued.    As other non-rightmost elements are not checked for being free of side  effects and therefore cannot be classified as problematic, this leads  to unexpected behavior:    1. foo((1, 2, 42)) is transformed into foo((1, 3)) and a warning is  issued only with regard to the first element.  2. foo((bar(), 2, 42)) is transformed into foo((bar(), 3)) and no  warning is issued.  3. foo(((1, 2, 3), (4, 5, 42))) is transformed into foo((1, 4, 42)) and  warnings are issued with regard to the first elements of inner  sequences only.	src
23	src/com/google/javascript/jscomp/PeepholeFoldConstants.java内private Node tryFoldArrayAccess(Node n, Node left, Node right)	30a88df811879f5d389f56257c93ab5f740a0518	b59cdd9e2dc64d2db86b90982c200a78f2f85e50	747	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-747.json	tryFoldArrayAccess does not check for side effects	What steps will reproduce the problem? 1. Compile the following program with simple or advanced optimization:  console.log([console.log('hello, '), 'world!'][1]);    What is the expected output? What do you see instead? The expected output would preserve side effects. It would not transform the program at all or transform it into:    console.log((console.log("hello"), "world!"));    Instead, the program is transformed into:    console.log("world!");    What version of the product are you using? On what operating system? Revision 2022. Ubuntu 12.04.    Please provide any additional information below. tryFoldArrayAccess in com.google.javascript.jscomp.PeepholeFoldConstants should check whether   every array element that is not going to be preserved has no side effects.	src
24	src/com/google/javascript/jscomp/ScopedAliases.java内private void findAliases(NodeTraversal t)外src/com/google/javascript/jscomp/ScopedAliases.java内private void findAliases(NodeTraversal t)	59aac0b247db74ec7047132f368953935edd81b8	70ca6014779735bdc52ca0e80e528257829a15e7	737	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-737.json	goog.scope doesn't properly check declared functions	The following code is a compiler error:    goog.scope(function() {    var x = function(){};  });    but the following code is not:    goog.scope(function() {    function x() {}  });    Both code snippets should be a compiler error, because they prevent the goog.scope from being unboxed.	src
25	src/com/google/javascript/jscomp/TypeInference.java内private void updateTypeOfThisOnClosure(Node n, FunctionType fnType)外src/com/google/javascript/jscomp/TypeInference.java内private FlowScope traverseNew(Node n, FlowScope scope)	372eb11e44b8559004bfe78a5b4003caf0072135	2e904fcdc3bc09e3bff557fcfca383ba7e450095	729	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-729.json	anonymous object type inference behavior is different when calling constructors	The following compiles fine with:  java -jar build/compiler.jar --compilation_level=ADVANCED_OPTIMIZATIONS --jscomp_error=accessControls --jscomp_error=checkTypes --jscomp_error=checkVars --js ~/Desktop/reverse.js    reverse.js:  /**   * @param {{prop1: string, prop2: (number|undefined)}} parry   */  function callz(parry) {    if (parry.prop2 && parry.prop2 < 5) alert('alright!');    alert(parry.prop1);  }    callz({prop1: 'hi'});        However, the following does not:  /**   * @param {{prop1: string, prop2: (number|undefined)}} parry   * @constructor   */  function callz(parry) {    if (parry.prop2 && parry.prop2 < 5) alert('alright!');    alert(parry.prop1);  }    new callz({prop1: 'hi'});      /Users/dolapo/Desktop/reverse.js:10: ERROR - actual parameter 1 of callz does not match formal parameter  found   : {prop1: string}  required: {prop1: string, prop2: (number|undefined)}  new callz({prop1: 'hi'});        Thanks!  	src
26	src/com/google/javascript/jscomp/ProcessCommonJSModules.java内private String normalizeSourceName(String filename)外src/com/google/javascript/jscomp/ProcessCommonJSModules.java内private void visitScript(NodeTraversal t, Node script)外src/com/google/javascript/jscomp/ProcessCommonJSModules.java内private void visitModuleExports(Node prop)	d36428ed0ba16afb7fa603154be162514303fbcf	372eb11e44b8559004bfe78a5b4003caf0072135	732	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-732.json	ProcessCommonJSModules module$exports failures when checkTypes enabled	If you define a module (echo.js) as:  define(function() { return {    echo: function(val) {      window.console.log(val);    }  }});    and an entry point* that does not define any new modules as:  var echo = require('echo');  echo.echo('hello world');    and compile with:  java -jar build/compiler.jar --formatting=PRETTY_PRINT --jscomp_error=checkTypes --compilation_level=SIMPLE_OPTIMIZATIONS --transform_amd_modules --process_common_js_modules --js=echo.js --js=echo-main.js --common_js_entry_module=echo-main.js    You get the error:  echo-main.js:1: ERROR - Property module$exports never defined on module$echo_main    which is probably happening because of ProcessCommonJSModules#emitOptionalModuleExportsOverride is testing a property that doesn't exist. I can try to cook up a patch but it would probably fall back to using goog.isDef and there's probably a cleaner way :)          *p.s what is the intended definition of entry points that do not define new modules. the following leaves a call to a require function:  require(['echo'], function(echo) {    echo.echo('hello world');  });	src
27	src/com/google/javascript/rhino/IR.java内public static Node block(Node ... stmts)外src/com/google/javascript/rhino/IR.java内public static Node labelName(String name)外src/com/google/javascript/rhino/IR.java内public static Node tryFinally(Node tryBody, Node finallyBody)	1d9ecb5328bbde5ee84dbfe2d74bbd318b89b6d7	7a8983042131c5a9c2b5421ae42075cbb8ef1aeb	727	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-727.json	Error trying to build try-catch block (AST)	1. EXAMPLE    Node nodeTry = IR.block(    IR.var(      IR.name("testing"),       IR.number(11)    )  );  Node nodeCatch = IR.catchNode(    IR.name("blabla"),      IR.block(        IR.var(          IR.name("testing"),   IR.number(22)        )      )  );  IR.tryCatch(nodeTry, nodeCatch);      2. THROWS ERROR    Exception in thread "main" java.lang.RuntimeException: java.lang.RuntimeException: INTERNAL COMPILER ERROR.  Please report this problem.  null    Node(FUNCTION tt): input.js:2:4      function tt() {    Parent(BLOCK): input.js:1:4  try {      3. SOLUTION    IR.block is verifing the catch node is a statement which it isnt.	src
28	src/com/google/javascript/jscomp/InlineCostEstimator.java内void addIdentifier(String identifier)	5c46a579786510ff342dcf622148e2bb3da0874e	59dbb7a28680caad08ddb1658123fe0cbb1ae689	728	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-728.json	constant functions not inlined aggressively enough	If you call a function that returns 'false' enough times under certain conditions, it doesn't get inlined.    // ==ClosureCompiler==  // @compilation_level ADVANCED_OPTIMIZATIONS  // @output_file_name default.js  // ==/ClosureCompiler==    function f() { return false; }  if (!f()) alert('hi'); // repeat this about 25 times    	src
29	src/com/google/javascript/jscomp/InlineObjectLiterals.java内private boolean isVarInlineForbidden(Var var)外src/com/google/javascript/jscomp/InlineObjectLiterals.java内private boolean isInlinableObject(List<Reference> refs)外src/com/google/javascript/jscomp/InlineObjectLiterals.java内private boolean isInlinableObject(List<Reference> refs)	3587cc3bb550dadee3c9aeac44041aa29087e74e	6924915efab89f921fd0779fe200fecc1bf80847	724	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-724.json	closure compiler screws up a perfectly valid isFunction() implementation	hi, this function does not get compiled correctly via google closure compiler     isFunction = function(functionToCheck) {      var getType;      getType = {}; //just an object      return functionToCheck && getType.toString.apply(functionToCheck) === '[object Function]';    };    gets compiled into     isFunction = function(a) {    return a && "[object Function]" === (void 0).apply(a)  };    to make it work, we have to use an array instead of an object (even though we just want to call the object toString method)      isFunction = function(functionToCheck) {      var getType;      getType = []; //not it's an array       return functionToCheck && getType.toString.apply(functionToCheck) === '[object Function]';    };    gets compiled into    isFunction = function(a) {    var b;    b = [];    return a && "[object Function]" === b.toString.apply(a)  };    and it does what it should do.     i wasted an hour to find that bug. bugs me. great tool otherwise. 	src
30	src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java内public void exitScope(NodeTraversal t)外src/com/google/javascript/jscomp/MustBeReachingVariableDef.java内noLeftCurtyIn1stLine:外src/com/google/javascript/jscomp/MustBeReachingVariableDef.java内private void computeDependence(final Definition def, Node rValue)外src/com/google/javascript/jscomp/MustBeReachingVariableDef.java内boolean dependsOnOuterScopeVars(String name, Node useNode)	6da361c5865ecac18ee147014c9e84244d19c2a9	38e2b8f247423734adec3dbd76fa22da1a3561a8	698	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-698.json	Combining temporary strings are over-optimized in advanced build	What steps will reproduce the problem? 1. This bug only manifests itself in large code bases. How large, and what the specifics are, I haven't yet worked out, since the output differs. But the principle code is:    sgxColorRGBA.prototype.asHex = function() {   var hexString = "";      str = (sgxFloor(this.r*255)).toString(16);   if (str.length < 2) { str = "0"+str; }   hexString += str;     str = (sgxFloor(this.g*255)).toString(16);   if (str.length < 2) { str = "0"+str; }   hexString += str;     str = (sgxFloor(this.b*255)).toString(16);   if (str.length < 2) { str = "0"+str; }   hexString += str;     str = (sgxFloor(this.a*255)).toString(16);   if (str.length < 2) { str = "0"+str; }   hexString += str;     return hexString;  }    Note that 'str' is not declared as var.    What is the expected output? What do you see instead? I see this:  sgxColorRGBA.prototype.pb = function() {    str = A(255 * this.A).toString(16);    2 > str.length && (str = "0" + str);    str = A(255 * this.w).toString(16);    2 > str.length && (str = "0" + str);    str = A(255 * this.s).toString(16);    2 > str.length && (str = "0" + str);    str = A(255 * this.r).toString(16);    2 > str.length && (str = "0" + str);    return"" + str + str + str + str  };    Obviously, repeatedly adding 'str' is broken in the final line, compared to the original. So whatever is aggregating the result is seeing a temporary 'str' reference and combining it, I guess. If 'str' is declared as var, the problem goes away.    I'd expect a warning, at least.    What version of the product are you using? On what operating system?   Live at http://closure-compiler.appspot.com    Please provide any additional information below.   As a stand-alone method, both 'var str' and 'str' works. It's only when the project hits a certain (undetermined) size that it fails.    	src
31	src/com/google/javascript/jscomp/Compiler.java内Node parseInputs()	82dd7814fd865ac31435cd239cb61c531900bd03	0a670cb51fd56c12c19f98884c9513792ebc3f76	703	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-703.json	Add support for --manage_closure_dependencies and --only_closure_dependencies with compilation level WHITESPACE_ONLY	The compiler options --manage_closure_dependencies and --only_closure_dependencies are currently ignored with compilation level WHITESPACE_ONLY. It would be helpful for testing, if dependency management were supported for WHITESPACE_ONLY in addition to SIMPLE_OPTIMIZATIONS and ADVANCED_OPTIMIZATIONS. For example, both Closure Builder and plovr automatically manage dependencies for all compilation levels.    The proposed change (see attached diff) does not automatically manage dependencies, but it enables dependency management if either --manage_closure_dependencies or --only_closure_dependencies is specified, or if at least one --closure_entry_point is specified.    The attached diff passed the JUnit tests: ant test  	src
32	src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java内private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option)外src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java内private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option)外src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java内private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option)外src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java内private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option)	116e0d5aea0f0f968a6d2ea4e085930331919752	66c8c695fd8130e3ede6f77c6e5cc1ec96a0e9b3	701	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-701.json	Preserve doesn't preserve whitespace at start of line	What steps will reproduce the problem?   Code such as:  /**   * @preserve    This    was      ASCII         Art    */    What is the expected output? What do you see instead?   The words line up on the left:  /*  This  was  ASCII  Art  */      What version of the product are you using? On what operating system?   Live web verison.      Please provide any additional information below. 	src
33	src/com/google/javascript/rhino/jstype/PrototypeObjectType.java内JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope)	24c113d396a1c3e175bf70fe572b496ff7a68144	382422adae8e9f07fc23c94089c0ebe08a2174bc	700	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-700.json	weird object literal invalid property error on unrelated object prototype	Apologies in advance for the convoluted repro case and the vague summary.    Compile the following code (attached as repro.js) with:  java -jar build/compiler.jar --compilation_level=ADVANCED_OPTIMIZATIONS --jscomp_error=accessControls --jscomp_error=checkTypes --jscomp_error=checkVars --js repro.js *    /**   * @param {{text: string}} opt_data   * @return {string}   */  function temp1(opt_data) {    return opt_data.text;  }    /**   * @param {{activity: (boolean|number|string|null|Object)}} opt_data   * @return {string}   */  function temp2(opt_data) {    /** @notypecheck */    function __inner() {      return temp1(opt_data.activity);    }    return __inner();  }    /**   * @param {{n: number, text: string, b: boolean}} opt_data   * @return {string}   */  function temp3(opt_data) {    return 'n: ' + opt_data.n + ', t: ' + opt_data.text + '.';  }    function callee() {    var output = temp3({      n: 0,      text: 'a string',      b: true    })    alert(output);  }    callee();      yields:  repro.js:30: ERROR - actual parameter 1 of temp3 does not match formal parameter  found   : {b: boolean, n: number, text: (string|undefined)}  required: {b: boolean, n: number, text: string}    var output = temp3({    It seems like temp3 is actually being called with the right type {b: boolean, n: number, text: string} though it seems to think that text is a (string|undefined)  This seems to happen because of the seemingly unrelated code in functions temp1 and temp2. If I change the name of the text property (as in repro3.js) it works.  Additionally, if I fix the type of the activity property in the record type of temp2 it works (as in repro2.js)    This comes up in our codebase in some situations where we don't have type info for all the objects being passed into a function. It's always a tricky one to find because it reports an error at a location that looks correct.      * it also fails with SIMPLE_OPTIMIZATIONS   	src
34	src/com/google/javascript/jscomp/CodePrinter.java内void endCaseBody()外src/com/google/javascript/jscomp/CodeGenerator.java内void add(Node n, Context context)外src/com/google/javascript/jscomp/CodeGenerator.java内private void unrollBinaryOperator( Node n, int op, String opStr, Context context, Context rhsContext, int leftPrecedence, int rightPrecedence)	bc018d6c44e70b5c02016431a2f3604b3e6fc45c	87b154f89cba3c67045cd7a783b79231d0630a4c	691	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-691.json	StackOverflowError exception when running closure compiler (javascript attached)	What steps will reproduce the problem?   1. I'm trying to run: java -jar compiler.jar --js AdMedia.eam.js --js_output_file AdMedia.eam.min.js  2. AdMedia.eam.js is attached.    What is the expected output? What do you see instead?   I get the following exception:  java.lang.RuntimeException: java.lang.RuntimeException: java.lang.StackOverflowError          at com.google.javascript.jscomp.Compiler.runCallable(Compiler.java:643)          at com.google.javascript.jscomp.Compiler.runInCompilerThread(Compiler.java:588)          at com.google.javascript.jscomp.Compiler.toSource(Compiler.java:1492)          at com.google.javascript.jscomp.AbstractCommandLineRunner.processResults(AbstractCommandLineRunner.java:788)          at com.google.javascript.jscomp.AbstractCommandLineRunner.doRun(AbstractCommandLineRunner.java:726)          at com.google.javascript.jscomp.AbstractCommandLineRunner.run(AbstractCommandLineRunner.java:334)          at com.google.javascript.jscomp.CommandLineRunner.main(CommandLineRunner.java:871)  Caused by: java.lang.RuntimeException: java.lang.StackOverflowError          at com.google.javascript.jscomp.Compiler.runCallable(Compiler.java:643)          at com.google.javascript.jscomp.Compiler.runInCompilerThread(Compiler.java:588)          at com.google.javascript.jscomp.Compiler.toSource(Compiler.java:1608)          at com.google.javascript.jscomp.Compiler$5.call(Compiler.java:1503)          at com.google.javascript.jscomp.Compiler$5.call(Compiler.java:1492)          at com.google.javascript.jscomp.Compiler$2.run(Compiler.java:615)          at java.lang.Thread.run(Unknown Source)  Caused by: java.lang.StackOverflowError          at com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:91)          at com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:881)          at com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:103)          at com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:881)          at com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:103)          at com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:881)          at com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:103)          at com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:881)          at com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:103)          at com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:881)          at com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:103)          at com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:881)  .  .  .      What version of the product are you using? On what operating system?   Closure:  Closure Compiler (http://code.google.com/closure/compiler)  Version: 20120305 (revision 1810)  Built on: 2012/03/05 20:55    Java:  java version "1.6.0_31"  Java(TM) SE Runtime Environment (build 1.6.0_31-b05)  Java HotSpot(TM) Client VM (build 20.6-b01, mixed mode, sharing)    Windows 7 (64-bit)    Please provide any additional information below.   Works fine on the following Java version:  java version "1.7.0"  Java(TM) SE Runtime Environment (build 1.7.0-b147)  Java HotSpot(TM) 64-Bit Server VM (build 21.0-b17, mixed mode)	src
35	src/com/google/javascript/jscomp/TypeInference.java内private void inferPropertyTypesToMatchConstraint( JSType type, JSType constraint)	7e3e1a667c866458cca12b7ade9965b4e6ddf3c0	22784dc96c391b01692ce686eb93b9aa0ef74ede	669	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-669.json	assignment to object in conditional causes type error on function w/ record type return type	slightly dodgy code :)    /** @returns {{prop1: (Object|undefined), prop2: (string|undefined), prop3: (string|undefined)}} */  function func(a, b) {    var results;    if (a) {      results = {};      results.prop1 = {a: 3};    }    if (b) {      results = results || {};      results.prop2 = 'prop2';    } else {      results = results || {};      results.prop3 = 'prop3';    }    return results;  }  results in this error:      JSC_TYPE_MISMATCH: inconsistent return type  found   : ({prop1: {a: number}}|{})  required: {prop1: (Object|null|undefined), prop2: (string|undefined), prop3: (string|undefined)} at line 18 character 7  return results;        defining results on the first line on the function causes it the world.  the still dodgy, but slightly less so, use of this is if the function return type were that record type|undefined and not all branches were guaranteed to be executed.	src
36	src/com/google/javascript/jscomp/InlineVariables.java内private boolean canInline( Reference declaration, Reference initialization, Reference reference)	c5ec81dc0b6aaaefcdfd84ee10e43f3312350d23	be397ee0d0be2aad8f71d12f097b17563866445a	668	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-668.json	goog.addSingletonGetter prevents unused class removal	What steps will reproduce the problem?   // ==ClosureCompiler==  // @compilation_level ADVANCED_OPTIMIZATIONS  // @output_file_name default.js  // @use_closure_library true  // @formatting pretty_print,print_input_delimiter  // @warning_level VERBOSE  // @debug true  // ==/ClosureCompiler==    goog.provide('foo');    var foo = function() { this.values = []; };  goog.addSingletonGetter(foo);    foo.prototype.add = function(value) {this.values.push(value)};      What is the expected output? What do you see instead?   Expect: The code is completely removed.    Instead:    (function($ctor$$) {    $ctor$$.$getInstance$ = function $$ctor$$$$getInstance$$() {      return $ctor$$.$instance_$ || ($ctor$$.$instance_$ = new $ctor$$)    }  })(function() {  });      What version of the product are you using? On what operating system?    http://closure-compiler.appspot.com on Feb 28, 2012    Please provide any additional information below.      	src
37	src/com/google/javascript/jscomp/NodeTraversal.java内private void traverseFunction(Node n, Node parent)外src/com/google/javascript/jscomp/parsing/IRFactory.java内Node processFunctionNode(FunctionNode functionNode)	375879beef8fcffaae51749a7ac537d2eb140802	7e93d521cb67ce33018315234fafe8a5aa30ee1e	663	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-663.json	incomplete function definition crashes the compiler when ideMode is enabled	The code:    f f f ;  function t    The cause:    Rhino is creating an incomplete FUNCTION node.  We could fix this in Rhino or the IRFactory.  If it is invalid in Rhino we should fix it there, I'm not sure how to determine this so maybe we should fix it in the IRFactory and be done with it.    The stack trace:    Caused by: java.lang.RuntimeException: INTERNAL COMPILER ERROR.  at com.google.common.base.Preconditions.checkState(Preconditions.java:135)  at com.google.javascript.jscomp.NodeTraversal.traverseFunction(NodeTraversal.java:544)  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:493)  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:501)  at com.google.javascript.jscomp.NodeTraversal.traverse(NodeTraversal.java:281)  at com.google.javascript.jscomp.NodeTraversal.traverse(NodeTraversal.java:459)  at com.google.javascript.jscomp.PrepareAst.process(PrepareAst.java:70)  at com.google.javascript.jscomp.Compiler.prepareAst(Compiler.java:1836)  at com.google.javascript.jscomp.JsAst.parse(JsAst.java:100)  at com.google.javascript.jscomp.JsAst.getAstRoot(JsAst.java:53)  at com.google.javascript.jscomp.CompilerInput.getAstRoot(CompilerInput.java:120)  at com.google.javascript.jscomp.Compiler.parseInputs(Compiler.java:1303)  at com.google.javascript.jscomp.Compiler.parse(Compiler.java:697)    	src
38	src/com/google/javascript/jscomp/CodeConsumer.java内void addNumber(double x)	f067d0e1d84d631ec0c1e8e8cd812bbda1497958	8cf08115c6b252f8c6b54348a4089dccc45a01fb	657	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-657.json	Identifier minus a negative number needs a space between the "-"s	What steps will reproduce the problem? 1. Compile the attached file with      java -jar build/compiler.jar --compilation_level ADVANCED_OPTIMIZATIONS --js bulletfail.js --js_output_file cc.js  2. Try to run the file in a JS engine, for example           node cc.js    What is the expected output? What do you see instead?   The file does not parse properly, because it contains      g--0.0    This is subtraction of a negative number, but it looks like JS engines interpret it as decrementing g, and then fail to parse the 0.0. (g- -0.0, with a space, would parse ok.)    What version of the product are you using? On what operating system?   Trunk closure compiler on Ubuntu    Please provide any additional information below. 	src
39	src/com/google/javascript/rhino/jstype/PrototypeObjectType.java内String toStringHelper(boolean forAnnotations)外src/com/google/javascript/rhino/jstype/PrototypeObjectType.java内String toStringHelper(boolean forAnnotations)	9a40e654ee3aa65d01671e4da63f292d2e4e03c0	d577973fb378dfe0d05991ec0dfa6c1f40e574ee	643	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-643.json	externExport with @typedef can generate invalid externs	What steps will reproduce the problem? 1. Create a file that has a @typedef and code referencing the type def above and below the typedef declaration.  2. Run the closure compiler and grab the externExport string stored on the last result for review.  3. I have attached both source and output files displaying the issue.    What is the expected output? What do you see instead?   The code above the @typedef references the aliased name of the @typedef as expected however the code below the @typedef tries embedding the body of the @typedef and ends up truncating it if the length is too long with a "...". This throws bad type errors when compiling against this extern. What is odd is this only seems to be the case when the parameter with the type is optional. When neither are optional it embeds the types, which is not a big deal, except when types are long; they get truncated and throw errors.      What version of the product are you using? On what operating system?   plovr built from revision 3103:d6db24beeb7f  Revision numbers for embedded Closure Tools:  Closure Library:    1374  Closure Compiler:   1559  Closure Templates:    23    Please provide any additional information below. 	src
40	src/com/google/javascript/jscomp/NameAnalyzer.java内public void visit(NodeTraversal t, Node n, Node parent)	a90f4b4fba37c52376d5f074729233d59ce08408	6ebc0c3d7d4da7d2cf95f53d4ea790e89d3abc7a	284	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-284.json	smartNameRemoval causing compiler crash	What steps will reproduce the problem? Compiler the following code in advanced mode:    {{{  var goog = {};  goog.inherits = function(x, y) {};  var ns = {};  /** @constructor */ ns.PageSelectionModel = function(){};    /** @constructor */   ns.PageSelectionModel.FooEvent = function() {};  /** @constructor */   ns.PageSelectionModel.SelectEvent = function() {};  goog.inherits(ns.PageSelectionModel.ChangeEvent, ns.PageSelectionModel.FooEvent);  }}}      What is the expected output? What do you see instead? The compiler will crash. The last var check throws an illegal state exception because it knows something is wrong.    The crash is caused by smartNameRemoval. It has special logic for counting references in class-defining function calls (like goog.inherits), and it isn't properly creating a reference to PageSelectionModel.	src
41	src/com/google/javascript/jscomp/FunctionTypeBuilder.java内FunctionTypeBuilder inferFromOverriddenFunction( @Nullable FunctionType oldType, @Nullable Node paramsParent)外src/com/google/javascript/jscomp/FunctionTypeBuilder.java内methodPartNotInFile:Nullable Node argsParent,	974027e9f66882bc75840bb15cfbaa206e02dd0e	00b1517c53912ac6843c257c0a6ead1176e8c5ee	368	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-368.json	In ADVANCED mode, Compiler fails to warn about overridden methods with different signatures.	In ADVANCED mode, Compiler fails to warn about overridden methods with different signatures. The following code only warns in the one instance noted in the comment, whereas I would expect it to complain about the declarations of both Bar.prototype.add and Bar.prototype.sub, as they claim @inheritDoc, but have seemingly different signatures from that of their superclass methods.    It would be helpful to have such a warning so that when you change the signature of a superclass method, you can run the Compiler to trigger warnings and find all of the other signatures that you need to update.    Run the following:    // ==ClosureCompiler==  // @compilation_level ADVANCED_OPTIMIZATIONS  // @output_file_name default.js  // @use_closure_library true  // ==/ClosureCompiler==    goog.provide('Foo');  goog.provide('Bar');      /** @constructor */  Foo = function() {};      /**   * @param {number} a   * @param {number} b   * @return {number}   */  Foo.prototype.add = function(a, b) {    return a + b;  };      /**   * @param {number} a   * @param {number} b   * @return {number}   */  Foo.prototype.sub = goog.abstractMethod;      /**   * @constructor   * @extends {Foo}   */  Bar = function() {    goog.base(this);  };  goog.inherits(Bar, Foo);      /** @inheritDoc */  Bar.prototype.add = function(one) {    return one;  };      /** @inheritDoc */  Bar.prototype.sub = function(one) {    return one;  };      var foo = /** @type {Foo} */ (new Bar());  alert(foo.add(3, 4));    var bar = new Bar();  // THIS PRODUCES JSC_WRONG_ARGUMENT_COUNT  alert(bar.add(3, 4));  	src
42	src/com/google/javascript/jscomp/parsing/IRFactory.java内Node processExpressionStatement(ExpressionStatement statementNode)	f74939a64a205d89721383c24874fe4e41439cfd	fb01427a445ebfeb3af5e220a98ccaced339b73e	644	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-644.json	Simple "Whitespace only" compression removing "each" keyword from "for each (var x in arr)" loop	What steps will reproduce the problem? See below code snippet before after compression    ---Before---  contactcenter.screenpop.updatePopStatus = function(stamp, status) {  for each ( var curTiming in this.timeLog.timings ) {  if ( curTiming.callId == stamp ) {  curTiming.flag = status;  break;  }  }  };  ---After---  contactcenter.screenpop.updatePopStatus=function(stamp,status){for(var curTiming in this.timeLog.timings)if(curTiming.callId==stamp){curTiming.flag=status;break}};      What is the expected output? What do you see instead? ---each keyword should be preserved    What version of the product are you using? On what operating system? Please provide any additional information below. for each (** in **) --->  returns object value  for (** in **) --> returns index  	src
43	src/com/google/javascript/jscomp/TypedScopeCreator.java内private JSType getNativeType(JSTypeNative nativeType)外src/com/google/javascript/jscomp/TypedScopeCreator.java内public void visit(NodeTraversal t, Node n, Node parent)外src/com/google/javascript/jscomp/TypedScopeCreator.java内private void attachLiteralTypes(NodeTraversal t, Node n)	29f4990e25842d232922171594d835888627ace0	f636f23bdef4b27752ca249a28463ec1b6af1f0b	314	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-314.json	@lends does not work unless class is defined beforehand	What steps will reproduce the problem? With advanced optimizations enabled as well as type checking (--jscomp_error=checkTypes), try to use @lends in the same way it's used on the jsdoc page at http://code.google.com/p/jsdoc-toolkit/wiki/TagLends - using either a utility method called "makeClass" or another method of class constructing such as John Resig's method at http://ejohn.org/blog/simple-javascript-inheritance/    What is the expected output? What do you see instead? Expected output is to have code compiled but instead I get a compile error such as:    ERROR - Variable Person.prototype not declared before @lends annotation.      What version of the product are you using? On what operating system? Latest svn build, OS X.    	src
44	src/com/google/javascript/jscomp/CodeConsumer.java内void add(String newcode)	3e66c9c827308d2f549a16440e3f0ef7fd844e04	64bb2291f9a9bbab67d865dffe603f8a0df8ef30	620	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-620.json	alert(/ / / / /)	alert(/ / / / /);  output: alert(/ /// /);  should be: alert(/ // / /);	src
45	src/com/google/javascript/jscomp/RemoveUnusedVars.java内private void interpretAssigns()外src/com/google/javascript/jscomp/RemoveUnusedVars.java内private void interpretAssigns()外src/com/google/javascript/jscomp/RemoveUnusedVars.java内void apply()	a55420ec8457fb0c7be663b2afbdbc0a60064901	6aa71f116df0102a98c463f471ad8ddd4dba01f8	618	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-618.json	Assignment removed when used as an expression result to Array.push	What steps will reproduce the problem? 1. Open online closure-compiler  2. Input code:    function f() {      var a = [], b;      a.push(b = []);      b[0] = 1;      return a;    }  3. Press [Compile]    What is the expected output? What do you see instead? Except OK.  Output: function f(){var a=[];a.push([]);return a}; //wrong    What version of the product are you using? On what operating system? Current online version.  	src
46	src/com/google/javascript/rhino/jstype/RecordType.java内boolean defineProperty(String propertyName, JSType type, boolean inferred, Node propertyNode)	edb6e4c48c19be681f38e9ee27e67b66a1944640	4a1a31c6a50a0fbe25fa33277909bd51f1deb8e9	603	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-603.json	ClassCastException during TypeCheck pass	What steps will reproduce the problem? 1. Compile code that has a ProxyObjectType that references a RecordType.  For example, we have a NamedType in a typedef that references a RecordType.    Please provide any additional information below.   Patch attached.  Is this the correct fix?  	src
47	src/com/google/javascript/jscomp/SourceMap.java内public void addMapping( Node node, FilePosition outputStartPosition, FilePosition outputEndPosition)外src/com/google/debugging/sourcemap/SourceMapConsumerV3.java内private OriginalMapping getOriginalMappingForEntry(Entry entry)	c5d7b308ecf260bf6ccf4b20ac256074fc42768f	aedce35970673f20696d5721acba13e986cc764c	575	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-575.json	Original source line numbers are one-based in source maps.	Generated source line/column numbers and original column numbers are zero-based. Original source line numbers should be zero based as well.	src
48	src/com/google/javascript/jscomp/TypedScopeCreator.java内void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue)	5524adbda991632656059566b69cc2771ba42b7d	46da17d59abb4f9c48b6ffd31601c212490b970b	586	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-586.json	Type checking error when replacing a function with a stub after calling.	Given the following Javascript:      /** @constructor */    var myclass = function() {    }        /** @param {boolean} success */    myclass.prototype.fn = function(success) { }        myclass.prototype.test = function() {      this.fn();      this.fn = function() { };    }    I would expect an error at both lines of test(). Instead, the second line causes the error in the first not to be reported.	src
49	src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java内public void enterScope(NodeTraversal t)外src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java内public boolean shouldTraverse(NodeTraversal t, Node n, Node parent)外src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java内public void visit(NodeTraversal t, Node n, Node parent)	62581c697a626f2cd848b98648aa42329d482859	1a7ba5cb0111dd3ed9afd9691cab39b3c341e408	539	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-539.json	Incorrect output if a function is assigned to a variable, and the function contains a variable with the same name	What steps will reproduce the problem?    1. Enter the following into the online compiler      var foo = function bar(){      var bar;      alert(bar)    };     2.  Compile using simple optimization    What is the expected output? What do you see instead?    I'd expect to see      var foo = function() {      alert(void 0)    };     Instead I see      var foo = function bar() {      alert(bar)    };    What version of the product are you using? On what operating system?    Using http://closure-compiler.appspot.com/home    Please provide any additional information below.    The compiled output is correct if you remove the "var foo =" part, or if you rename the function from "bar" to something else.  	src
50	src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java内private Node tryFoldArrayJoin(Node n)外src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java内private Node tryFoldArrayJoin(Node n)	9d3ed3fb128d2378e76f65e15bc45783eaf4cd57	c3b630fc9c2a1c4eb7cb718f8d324bfb306cb9df	558	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-558.json	Optimisation: convert array.join(",") to array.join()	What steps will reproduce the problem?   Compile this code:    var variable = confirm("value from user");  var array = [ "constant", variable ];  alert( array.join(",") );      What is the expected output? What do you see instead?   $ java -jar /usr/local/slando/lib/Google/compiler.jar --compilation_level ADVANCED_OPTIMIZATIONS --js foo.js  var a=["constant",confirm("value from user")];alert(a.join(","));    We could save three bytes here by producing:    var a=["constant",confirm("value from user")];alert(a.join());      What version of the product are you using? On what operating system?   $ java -jar /usr/local/slando/lib/Google/compiler.jar --version  Closure Compiler (http://code.google.com/closure/compiler)  Version: 1180  Built on: 2011/06/15 21:40    Running on Linux 2.6.18      Please provide any additional information below.   Here's a common pattern this would be useful in:    var my_jquery_selectors = [];  // ... append to my_jquery_selectors from various parts of the codebase ...  $(my_jquery_selectors.join(",")).html("the code is more readable with the comma left in place");	src
51	src/com/google/javascript/jscomp/CodeConsumer.java内void addNumber(double x)	44c2d71195e5c4a3ded0ef2b2e593cabdeeec08b	a02241e5df48e44e23dc0e66dbef3fdc3c91eb3e	582	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-582.json	-0.0 becomes 0 even in whitespace mode	Affects dart: http://code.google.com/p/dart/issues/detail?id=146	src
52	src/com/google/javascript/jscomp/CodeGenerator.java内static boolean isSimpleNumber(String s)	d79072969c2f31860ea1f55e392a146c49bc2d0f	5909c3db59b16886917456ab950ef9661a7fe6b1	569	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-569.json	Converts string properties into numbers in literal object definitions	What steps will reproduce the problem? 1. Minimize the following script:    var lit = {"0102":"Zero One Zero Two"};  alert(lit["0102"]);    What is the expected output? What do you see instead?   Expected:  var lit={"0102":"Zero One Zero Two"};alert(lit["0102"]);    Actual:  var lit={102:"Zero One Zero Two"};alert(lit["0102"]);    What version of the product are you using? On what operating system?   r1459    Please provide any additional information below. 	src
53	src/com/google/javascript/jscomp/InlineObjectLiterals.java内private void replaceAssignmentExpression(Var v, Reference ref, Map<String, String> varmap)外src/com/google/javascript/jscomp/InlineObjectLiterals.java内private void replaceAssignmentExpression(Var v, Reference ref, Map<String, String> varmap)	4adf024b5eb87f6b760b40e9923ed1391bca4152	9959716b01fc5231ae68bc7a24454ce45d341606	545	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-545.json	compiler-20110811 crashes with index(1) must be less than size(1)	What steps will reproduce the problem? Run compiler on https://raw.github.com/scottschiller/SoundManager2/master/script/soundmanager2-nodebug.js    You can copy this into the Appspot closure compiler to see the error:  // ==ClosureCompiler==  // @output_file_name default.js  // @compilation_level SIMPLE_OPTIMIZATIONS  // @code_url https://raw.github.com/scottschiller/SoundManager2/master/script/soundmanager2-nodebug.js  // ==/ClosureCompiler==    I've attached a dump of the error from appspot.    (This is the popular SoundManager library for HTML5 audio)    What is the expected output? What do you see instead? Got crash...    What version of the product are you using? On what operating system? Latest (compiler-20110811). We were previously using the June build, and had no problems    Please provide any additional information below. 	src
54	src/com/google/javascript/rhino/jstype/FunctionType.java内public void setPrototypeBasedOn(ObjectType baseType)外src/com/google/javascript/rhino/jstype/FunctionType.java内public boolean setPrototype(PrototypeObjectType prototype)外src/com/google/javascript/jscomp/TypedScopeCreator.java内void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue)	fc307189f141773d0a66c235f8f37f05c8252d8d	7e9b8336568ea7f05c33e1b58eb67fa6d4eee756	537	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-537.json	Prototype methods can't be used from the constructor in case prototype is explicitly defined.	Consider the following source code:  http://trac.webkit.org/browser/trunk/Source/WebCore/inspector/front-end/DOMAgent.js    When I mark WebInspector.DOMAgent as a @constructor, I get the following warning.    Source/WebCore/inspector/front-end/DOMAgent.js:48: WARNING - Property _setAttributesPayload never defined on WebInspector.DOMNode          this._setAttributesPayload(payload.attributes);    It sounds like the problem is in the way we define prototypes in line 83-ish. That's the way WebKit style tells us to do.  	src
55	src/com/google/javascript/jscomp/FunctionRewriter.java内public Node parseHelperCode(Reducer reducer)	1d13eac7441b980804c7ddfbe48a10a2ec3431d0	f2c0cb1f67ecb3315c0cb11326c9cb04db07ee8a	538	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-538.json	Exception when emitting code containing getters	Consider the following source code: http://trac.webkit.org/browser/trunk/Source/WebCore/inspector/front-end/Settings.js#L123    Following exception fires unless I remove the "get name()" getter from the code.    java.lang.RuntimeException: java.lang.IllegalStateException: Expected function but was call Reference node CALL 128 [free_call: 1] [source_file: Settings.js]   at com.google.javascript.jscomp.Compiler.runCallable(Compiler.java:629)   at com.google.javascript.jscomp.Compiler.runInCompilerThread(Compiler.java:574)   at com.google.javascript.jscomp.Compiler.compile(Compiler.java:556)   at com.google.javascript.jscomp.Compiler.compile(Compiler.java:515)   at com.google.javascript.jscomp.AbstractCommandLineRunner.doRun(AbstractCommandLineRunner.java:662)   at com.google.javascript.jscomp.AbstractCommandLineRunner.run(AbstractCommandLineRunner.java:295)   at com.google.javascript.jscomp.CommandLineRunner.main(CommandLineRunner.java:758)  Caused by: java.lang.IllegalStateException: Expected function but was call Reference node CALL 128 [free_call: 1] [source_file: Settings.js]   at com.google.javascript.jscomp.AstValidator$1.handleViolation(AstValidator.java:51)   at com.google.javascript.jscomp.AstValidator.violation(AstValidator.java:763)   at com.google.javascript.jscomp.AstValidator.validateNodeType(AstValidator.java:768)   at com.google.javascript.jscomp.AstValidator.validateFunctionExpression(AstValidator.java:359)   at com.google.javascript.jscomp.AstValidator.validateObjectLitGetKey(AstValidator.java:696)   at com.google.javascript.jscomp.AstValidator.validateObjectLitKey(AstValidator.java:677)   at com.google.javascript.jscomp.AstValidator.validateObjectLit(AstValidator.java:670)   at com.google.javascript.jscomp.AstValidator.validateExpression(AstValidator.java:252)   at com.google.javascript.jscomp.AstValidator.validateAssignmentExpression(AstValidator.java:603)   at com.google.javascript.jscomp.AstValidator.validateExpression(AstValidator.java:219)   at com.google.javascript.jscomp.AstValidator.validateExprStmt(AstValidator.java:476)   at com.google.javascript.jscomp.AstValidator.validateStatement(AstValidator.java:126)   at com.google.javascript.jscomp.AstValidator.validateScript(AstValidator.java:89)   at com.google.javascript.jscomp.AstValidator.validateCodeRoot(AstValidator.java:79)   at com.google.javascript.jscomp.AstValidator.process(AstValidator.java:63)   at com.google.javascript.jscomp.PhaseOptimizer$PassFactoryDelegate.processInternal(PhaseOptimizer.java:273)   at com.google.javascript.jscomp.PhaseOptimizer$NamedPass.process(PhaseOptimizer.java:250)   at com.google.javascript.jscomp.PhaseOptimizer.process(PhaseOptimizer.java:168)   at com.google.javascript.jscomp.Compiler.optimize(Compiler.java:1634)   at com.google.javascript.jscomp.Compiler.compileInternal(Compiler.java:664)   at com.google.javascript.jscomp.Compiler.access$000(Compiler.java:70)   at com.google.javascript.jscomp.Compiler$1.call(Compiler.java:559)   at com.google.javascript.jscomp.Compiler$1.call(Compiler.java:556)   at com.google.javascript.jscomp.Compiler$2.run(Compiler.java:601)   at java.lang.Thread.run(Thread.java:680)	src
56	src/com/google/javascript/jscomp/SourceFile.java内public String getLine(int lineNumber)	f791e3a7a172728b54a337c94bff4bc27c7adc43	9e921fa973c603473f745fff76c44620fd7719e3	511	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-511.json	Last warning or error in output is truncated	The last error or warning statement written to the output appears to be getting truncated. It's causing a problem for my error / warning parser.    To reproduce, create a file called test.js and add the following content to it:    ---------------  alert(foo);  alert(bar);  ---------------    When compiled, the output looks like this:    ---------------  >java -jar compiler.jar --warning_level VERBOSE --js test.js  test.js:1: ERROR - variable foo is undefined  alert(foo);        ^    test.js:2: ERROR - variable bar is undefined    2 error(s), 0 warning(s)  ---------------    If you look at the last error includes neither the line the error occurred on nor the column-indicating caret. This happens with warnings as well.    Tested against r1257 committed 2011-07-11 11:11:32 -0700.	src
57	src/com/google/javascript/jscomp/ClosureCodingConvention.java内private static String extractClassNameIfGoog(Node node, Node parent, String functionName)	2d3b9a6c591ef14e8c9208a3f049a1630c993d84	f759f431d5a7a2261b44440bca9cfab93ae25302	530	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-530.json	compiler crashes when  goog.provide used with non string 	What steps will reproduce the problem? 1. insert  goog.provide(some.function);  2. compile.  3. What is the expected output? What do you see instead?   This should give an error diagnostic. What it gives is:    java.lang.RuntimeException: java.lang.RuntimeException: INTERNAL COMPILER ERROR.  Please email js-compiler@google.com with this stack trace.  GETPROP 17 [originalname: Spike] [source_file: file.js] is not a string node   Node(CALL): file.js:17:12  goog.provide(mine.Spike);  ...  [stack traces...]    I think this is the current build as of the day of this report.	src
58	src/com/google/javascript/jscomp/LiveVariablesAnalysis.java内private void computeGenKill(Node n, BitSet gen, BitSet kill, boolean conditional)	7876ab2f80475ead7eb239dda7f65348c5cb7bdb	f640b5dec722422c93a9a624cd21d30b5e321858	528	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-528.json	Online CC bug: report java error.	What steps will reproduce the problem? 1. open http://closure-compiler.appspot.com/  2. input js code:    function keys(obj) {      var a = [], i = 0;      for (a[i++] in obj)        ;      return a;    }  3. press [compile] button.    What is the expected output? What do you see instead? Except OK. See java error.    What version of the product are you using? On what operating system? Online CC version.  	src
59	src/com/google/javascript/jscomp/Compiler.java内public void initOptions(CompilerOptions options)	5331b915cf55e8d5f030b6cc62487757cfe50cd6	49b4ef31c850611a5c85d95140b4cedda7f4c59a	521	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-521.json	Cannot exclude globalThis checks through command line	What steps will reproduce the problem? 1. Run command line utility  2. Supply flags --warning_level VERBOSE --jscomp_off globalThis --jscomp_off nonStandardJsDocs    What is the expected output? What do you see instead? I expect that globalThis and nonStandardJsDocs warnings will be ignored. Only nonStandardJsDocs warnings are ignored.    What version of the product are you using? On what operating system? Version 1180  Sun OS 5.10    Please provide any additional information below. --jscomp_error also doesn't work with globalThis (works with nonStandardJSDocs).   	src
60	src/com/google/javascript/jscomp/NodeUtil.java内static TernaryValue getImpureBooleanValue(Node n)外src/com/google/javascript/jscomp/NodeUtil.java内static TernaryValue getPureBooleanValue(Node n)	042b972a5853424d39be1cb76f2710d4bc3380e0	fbaadc736f0031dd84bebea33abae497b47158cb	504	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-504.json	void function () {}(); wrongly identified as having no side effects	This code results in the execution of the function and should not be identified as having no side effects.	src
61	src/com/google/javascript/jscomp/NodeUtil.java内static boolean functionCallHasSideEffects( Node callNode, @Nullable AbstractCompiler compiler)	bac71221414f7f42d31d3634c935c2ae1a940376	34e4616a924bf272c076039e143e20f1d792731e	501	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-501.json	Closure removes needed code.	What steps will reproduce the problem? 1. Try the following code, in Simple mode  Math.blah = function(test) { test.a = 5; };  var test = new Object();  Math.blah(test);   2. The output is  Math.blah=function(a){a.a=5};var test={};      What is the expected output? What do you see instead? Note that Math.blah(test) was removed. It should not be. It issues a warning: JSC_USELESS_CODE: Suspicious code. This code lacks side-effects. Is there a bug? at line 4 character 9    What version of the product are you using? On what operating system? Tested on Google hosted Closure service.    Please provide any additional information below. Closure seems to be protective about Math in particular, and doesn't like people messing around with her? So, when I try the following code:-  var n = {};  n.blah = function(test) { test.a = 5; };  var test = new Object();  n.blah(test);    It works. When I replace n by Math, then again, Closure kicks out blah. I need that poor fellow. Please talk some sense into it.	src
62	src/com/google/javascript/jscomp/LightweightMessageFormatter.java内private String format(JSError error, boolean warning)	1e07047234938543ea364f68ec0f29686dbc12f1	b12d1d6489329c989b15635f6f7f06681b3f6582	487	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-487.json	Column-indicating caret is sometimes not in error output	For some reason, the caret doesn't always show up in the output when there are errors.    When test.js looks like this:      >alert(1;      , the output is this:      >java -jar compiler.jar --js test.js  test.js:1: ERROR - Parse error. missing ) after argument list    1 error(s), 0 warning(s)      However, when test.js looks like this (notice the line break after the semicolon):      >alert(1;  >      , the output is this:      >java -jar compiler.jar --js test.js  test.js:1: ERROR - Parse error. missing ) after argument list  alert(1;          ^    1 error(s), 0 warning(s)      That's the simplest reproduction of the problem that I could come up with, but I just encountered the problem in a file with ~100 LOC in it. This is the first time I believe I've run into the problem, but when it happens, my error parser fails and it becomes a pain to track down the raw output to find the actual problem.    Tested against r1171, committed 6/10 08:06. The problem is present going back to at least r1000, so this isn't a new issue.	src
63	src/com/google/javascript/jscomp/LightweightMessageFormatter.java内private String format(JSError error, boolean warning)	7deaed51a2313dd3d5814cf3ed93d7140cf3b1b5	37b0e1b0b5860e6cd4f48519c1105623778dc44f	487	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-487.json	Column-indicating caret is sometimes not in error output	For some reason, the caret doesn't always show up in the output when there are errors.    When test.js looks like this:      >alert(1;      , the output is this:      >java -jar compiler.jar --js test.js  test.js:1: ERROR - Parse error. missing ) after argument list    1 error(s), 0 warning(s)      However, when test.js looks like this (notice the line break after the semicolon):      >alert(1;  >      , the output is this:      >java -jar compiler.jar --js test.js  test.js:1: ERROR - Parse error. missing ) after argument list  alert(1;          ^    1 error(s), 0 warning(s)      That's the simplest reproduction of the problem that I could come up with, but I just encountered the problem in a file with ~100 LOC in it. This is the first time I believe I've run into the problem, but when it happens, my error parser fails and it becomes a pain to track down the raw output to find the actual problem.    Tested against r1171, committed 6/10 08:06. The problem is present going back to at least r1000, so this isn't a new issue.	src
64	src/com/google/javascript/jscomp/Compiler.java内public Void call()外src/com/google/javascript/jscomp/Compiler.java内public Void call()	620fc21fa289cf0fda52c3d310a41d9fc2103be9	de726510af4329fb8eeb8a54b2d93d8d37c87545	489	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-489.json	--language_in=ECMASCRIPT5_STRICT results in 1 'use strict' per input file	What steps will reproduce the problem? 1.  Create a JS file called "get_num.js" with the contents "var getNum = function() { return 5; };"  2.  Create a JS file called "alert.js" with the contents "alert(getNum());"  3.  Compile the two files with the following command:    java -jar compiler.jar --language_in=ECMASCRIPT5_STRICT --compilation_level=ADVANCED_OPTIMIZATIONS --warning_level=VERBOSE --js get_num.js --js alert.js    What is the expected output? What do you see instead?   I would expect the output to be:    'use strict';alert(5);    or, if the compiler wants to be really clever, just "alert(5)" since this is already ES5 Strict compliant.      What version of the product are you using? On what operating system? Head on Mac OS X    Please provide any additional information below.   https://groups.google.com/forum/#!topic/closure-compiler-discuss/TOLXpePju5Q	src
65	src/com/google/javascript/jscomp/CodeGenerator.java内static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder)	9465f9139201814dc532adc33fe44a169a101937	48aea0ff7d027507362007415963a4b662fb10a7	486	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-486.json	String escaping mishandles null byte	What steps will reproduce the problem? 1. Run:  var x = "\u00003"; if (x.length < 2) { alert("fail"); } else { alert("win"); }  2. Compile and run    What is the expected output? What do you see instead? "win" is expected. "fail" is observed    What version of the product are you using? On what operating system? r1167 on OS x 10.6    Please provide any additional information below. The problem is here: http://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/javascript/jscomp/CodeGenerator.java#1015    Here's a patch that fixes it:  $ svn diff  Index: src/com/google/javascript/jscomp/CodeGenerator.java  ===================================================================  --- src/com/google/javascript/jscomp/CodeGenerator.java (revision 1167)  +++ src/com/google/javascript/jscomp/CodeGenerator.java (working copy)  @@ -1012,7 +1012,7 @@       for (int i = 0; i < s.length(); i++) {         char c = s.charAt(i);         switch (c) {  -        case '\0': sb.append("\\0"); break;  +        case '\0': sb.append("\\000"); break;           case '\n': sb.append("\\n"); break;           case '\r': sb.append("\\r"); break;           case '\t': sb.append("\\t"); break;    You could also lookahead and output "\\000" only if the following char is 0-7 (octal valid) and otherwise output "\\0". Is 2 bytes worth the complexity?	src
66	src/com/google/javascript/jscomp/TypeCheck.java内public void visit(NodeTraversal t, Node n, Node parent)	984bce0d9f36b0a21a0f9b51dc68fca0175aa1c8	59a30b48325cccadabae8687fdf603d72e26c157	482	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-482.json	@enum does not type correctly	What steps will reproduce the problem?   1. create an enum with any syntax  my example:  /**   @type {Object}  */  var NS = {};    /**  @enum {number}  */  NS.keys = {    a: 1,    b: 2,    c: 3  };    /**  @enum  */  window['gKEYS'] = NS.keys;      2. complie with --compilation_level ADVANCED_OPTIMIZATIONS --summary_detail_level 3 --warning_level VERBOSE    3. look at the % typed    What is the expected output? What do you see instead? it shouldn't count the enum as un-typed; it does...    What version of the product are you using? On what operating system? Version: 1043  Built on: 2011/05/02 19:47    Please provide any additional information below.   i also tried to tersely coerce the type, eg:  /** @type {number} */ a:  (/** @type {number} */(1)),    which has no effect.    	src
67	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java内private boolean isPrototypePropertyAssign(Node assign)	8777edb959dfea307495e667c2c01834adabb906	aa89d05b48332d68b8e6ebcee427b2ac3b4e3184	459	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-459.json	Advanced compilations renames a function and then deletes it, leaving a reference to a renamed but non-existent function	If we provide the below code to advanced:      function A() {  this._x = 1;  }    A.prototype['func1'] = // done to save public reference to func1  A.prototype.func1 = function() {    this._x = 2;    this.func2();  }    A.prototype.func2 = function() {    this._x = 3;    this.func3();  }    window['A'] = A;      We get the output:      function a() {    this.a = 1  }  a.prototype.func1 = a.prototype.b = function() {    this.a = 2;    this.c() // Problem!  };  window.A = a;      So the compiler emits no errors, and renames 'func2' to 'c' but ends up throwing away the definition of that function!    The problem arises when I use:    A.prototype['func1'] = // done to save public reference to func1  A.prototype.func1 = function() {  ...  }    The ['func1'] line is apparently enough to save the reference correctly, but also has the side effect of causing the function innards to do the wrong thing.    I can of course instead write it as:    A.prototype['func1'] = A.prototype.func1;  A.prototype.func1 = function() {    this._x = 2;    this.func2();  }    In which case Advanced will compile correctly and the results will also be valid.    function a() {    this.a = 1  }  a.prototype.func1 = a.prototype.b;  a.prototype.b = function() {    this.a = 2;    this.a = 3 // func2, correctly minified  };  window.A = a;      For now I can just use the expected way of declaring that func1 export, but since the compiler returns with no errors or warnings and creates a function with no definition, it seems worth reporting.	src
68	src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java内boolean parse()外src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java内private Node parseBasicTypeExpression(JsDocToken token)外src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java内private Node parseFunctionType(JsDocToken token)	f392c8416faeb6dc41e663912ad7f4421d893a90	9d5a6e3082dd99f6c44df1b3526b9e83b79aa7da	477	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-477.json	Cryptic error message on invalid "@type function" annotation	What steps will reproduce the problem? 1.  test.js:        /**       * @type function       */      var callback;    2. java -jar compiler.jar --js test.js     What is the expected output? What do you see instead?   Warning reported is:    test.js:3: WARNING - Parse error. Unexpected end of file   */    ^    Expected to see the actual warning (e.g., "expected '('", for the *previous* line)    What version of the product are you using? On what operating system?   compiler-20110502    Please provide any additional information below.   Simply adding "()" to it ("@type function()") removes the warning, but it would be much more effective if it could communicate that properly.	src
69	src/com/google/javascript/jscomp/TypeCheck.java内private void visitCall(NodeTraversal t, Node n)	036f2173d91679c7c914da196761c0f7d05e5389	63df133d0850805818d1e280ba47dcefc9763c89	440	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-440.json	Compiler should warn/error when instance methods are operated on	What steps will reproduce the problem? 1. Compile and run the following code:    goog.require('goog.graphics.Path');    function demo() {      var path = new goog.graphics.Path();      var points = [[1,1], [2,2]];      for (var i = 0; i < points.length; i++) {        (i == 0 ? path.moveTo : path.lineTo)(points[i][0], points[i][1]);      }    }    goog.exportSymbol('demo', demo);    What is the expected output? What do you see instead? I expect it to either work or produce a warning.  In this case, the latter since there's an error in the javascript - when calling path.moveTo(x, y), "this" is set correctly to the path element in the moveTo function.  But when the function is operated on, as in (i == 0 ? path.moveTo : path.lineTo)(x, y), it's no longer an instance method invocation, so "this" reverts to the window object.  In this case, an error results because moveTo references a field in Path that is now "undefined".  Better would be to issue a warning/error that an instance method is being converted to a normal function (perhaps only if it references this).    What version of the product are you using? On what operating system? Unknown (it's built into my build tools) - I presume this issue is present in all builds.  Running on ubuntu.    Please provide any additional information below.	src
70	src/com/google/javascript/jscomp/TypedScopeCreator.java内private void declareArguments(Node functionNode)	7433d30ac4cb2334d22e66299846118686efe939	ec4a34c2bd87ba54fa8770affdeeea4f3c42089b	433	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-433.json	unexpected typed coverage of less than 100%	What steps will reproduce the problem? 1. Create JavaScript file:  /*global window*/  /*jslint sub: true*/  /**   * @constructor   * @param {!Element} element   */  function Example(element) {      /**       * @param {!string} ns       * @param {!string} name       * @return {undefined}       */      this.appendElement = function appendElement(ns, name) {          var e = element.ownerDocument.createElementNS(ns, name);          element.appendChild(e);      };  }  window["Example"] = Example;  2. compile it:  java -jar compiler.jar --jscomp_error checkTypes --summary_detail_level 3 --js v.js --js_output_file compiled.js  3. observe the outcome:  0 error(s), 0 warning(s), 73.7% typed    What is the expected output? What do you see instead? This was expected:  0 error(s), 0 warning(s), 100% typed    What version of the product are you using? On what operating system? Closure Compiler Version: 964, Built on: 2011/04/05 14:31 on GNU/Linux.    Please provide any additional information below. 	src
71	src/com/google/javascript/jscomp/CheckAccessControls.java内private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent)	c498ecb791f2dd8a1b37e74f94c1c119549607bc	db1fdf97454a6e4ff2d29cab5f1ef2273b54c0b4	254	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-254.json	no warnings when @private prop is redeclared on subclass	What steps will reproduce the problem? /** @constructor */ function Foo() { /** @private */ this.x_ = 3; }    then, in a separate file:  /** @constructor    * @extends {Foo} */ function SubFoo() { /** @private */ this.x_ = 3; }    then, compile with --jscomp_error=visibility    Expected: You should get an error.  Actual: No error.    You get an error as appropriate if the second @private annotation is removed.    	src
72	src/com/google/javascript/jscomp/FunctionToBlockMutator.java内private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop)外src/com/google/javascript/jscomp/RenameLabels.java内private void visitLabel(Node node, Node parent)	3f8896c5f08cd04efabfc1bd9915ebfd93fb832a	e323b879de2e53e5eedf6e7afb0d582382c6248d	435	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-435.json	Internal Compiler Error on Bullet	What steps will reproduce the problem? 1. The attachment is the Bullet physics library, compiled from C++ to JS using Emscripten.  2. I tried to compile it using the Closure Compiler, latest downloadable version (Apr 5 2011), with    java -jar apr5compiler.jar --compilation_level ADVANCED_OPTIMIZATIONS --variable_map_output_file js.vars --js bullet_1_1_q1.js --js_output_file bullet_1_1_q1.cc.js    What is the expected output? What do you see instead?   I would expect it to compile successfully. Instead it halts (after a few hours) with      ==================  java.lang.RuntimeException: java.lang.RuntimeException: INTERNAL COMPILER ERROR.  Please report this problem.  null    Node(LABEL): bullet_1_1_q1.js:60150:8          $for_body$5: while(1) {     Parent(BLOCK): bullet_1_1_q1.js:60043:26        if (__label__ == 0) {     at com.google.javascript.jscomp.Compiler.runCallable(Unknown Source)   at com.google.javascript.jscomp.Compiler.runInCompilerThread(Unknown Source)   at com.google.javascript.jscomp.Compiler.compile(Unknown Source)   at com.google.javascript.jscomp.Compiler.compile(Unknown Source)   at com.google.javascript.jscomp.AbstractCommandLineRunner.doRun(Unknown Source)   at com.google.javascript.jscomp.AbstractCommandLineRunner.run(Unknown Source)   at com.google.javascript.jscomp.CommandLineRunner.main(Unknown Source)  Caused by: java.lang.RuntimeException: INTERNAL COMPILER ERROR.  Please report this problem.  null    Node(LABEL): bullet_1_1_q1.js:60150:8          $for_body$5: while(1) {     Parent(BLOCK): bullet_1_1_q1.js:60043:26        if (__label__ == 0) {     at com.google.common.base.Preconditions.checkState(Preconditions.java:129)   at com.google.javascript.jscomp.RenameLabels$ProcessLabels.shouldTraverse(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseFunction(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverse(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverse(Unknown Source)   at com.google.javascript.jscomp.RenameLabels.process(Unknown Source)   at com.google.javascript.jscomp.PhaseOptimizer$PassFactoryDelegate.processInternal(Unknown Source)   at com.google.javascript.jscomp.PhaseOptimizer$NamedPass.process(Unknown Source)   at com.google.javascript.jscomp.PhaseOptimizer.process(Unknown Source)   at com.google.javascript.jscomp.Compiler.optimize(Unknown Source)   at com.google.javascript.jscomp.Compiler.compileInternal(Unknown Source)   at com.google.javascript.jscomp.Compiler.access$000(Unknown Source)   at com.google.javascript.jscomp.Compiler$1.call(Unknown Source)   at com.google.javascript.jscomp.Compiler$1.call(Unknown Source)   at com.google.javascript.jscomp.Compiler$2.run(Unknown Source)   at java.lang.Thread.run(Thread.java:662)  Caused by: java.lang.IllegalStateException   ... 40 more  ==================      What version of the product are you using? On what operating system?   The Closure Compiler download from Apr 5 2011, on Ubuntu 10.04 32 bit.  	src
73	src/com/google/javascript/jscomp/CodeGenerator.java内static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder)	760bded3242093d86611a82e81fdca302a1487f1	ee8344091722c28c9351e78dcb4155fbfddfd1af	416	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-416.json	Codepoint U+007f appears raw in output	What steps will reproduce the problem? 1. Open http://closure-compiler.appspot.com/home in your browser  2. Enter the source code: alert('\x7f')  3. Hit the "Compile" button.    What is the expected output?  alert("\x7f")    What do you see instead?  alert("");      What version of the product are you using? On what operating system? The version live on 11 April 2011.    Please provide any additional information below. Codepoint U+007f is a delete control character and is the only non-printable ASCII codepoint that is not <= U+0020.  http://www.fileformat.info/info/unicode/char/7f/index.htm    It should probably not appear raw in emitted source code because, it can confuse encoders.  	src
74	src/com/google/javascript/jscomp/PeepholeFoldConstants.java内private Node tryFoldComparison(Node n, Node left, Node right)外src/com/google/javascript/jscomp/PeepholeFoldConstants.java内private Node tryFoldComparison(Node n, Node left, Node right)	d5bf6b425c5d52b28136afc9770876139b34acd7	03fee32a06ccf8257b2da67b9034270be38805ae	413	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-413.json	Obvious optimizations don't works in "inline if"	Try it (advanced mode):      alert(true == null ? a() : b());    EVER true != null, in this case, EVER will trigger b(), but we get:      alert(!0 == null ? a() : b());    Same for:      alert(true == false ? a() : b());    Real life use:      function sum(a, b){        return (a == true ? 2 : a) + b;      }      alert(sum(true, 1));    Results in:      alert((!0 == !0 ? 2 : 1) + 1);    But correct is:      alert(3);	src
75	src/com/google/javascript/jscomp/NodeUtil.java内static Double getNumberValue(Node n)外src/com/google/javascript/jscomp/NodeUtil.java内static String trimJsWhiteSpace(String s)	31baadd1293c5ae7af05b3a06a1ba3a06403e4ed	c6cc58a9bc617483366141386e047b085b4e83ff	395	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-395.json	closure compiled swfobject error	swfobject.js code    function urlEncodeIfNecessary(s) {   var regex = /[\\\"<>\.;]/;   var hasBadChars = regex.exec(s) != null;   return hasBadChars && typeof encodeURIComponent != UNDEF ? encodeURIComponent(s) : s;  }    closure compiled:    function Z(a){return/[\"<>.;]/.exec(a)!=  null&&typeof encodeURIComponent!=j?encodeURIComponent(a):a}    but it's error.and minify erray:  Fatal error: Uncaught exception 'JSMin_UnterminatedStringException' with message 'Unterminated String: '"<>.;]/.exec(a)!=''    return/[\"<>.;]/ to  return /[\"<>.;]/   that's OK      ie = !+"\v1",   closure compiled to   ie=!1,    my god!!  	src
76	src/com/google/javascript/jscomp/DeadAssignmentsElimination.java内private boolean isVariableStillLiveWithinExpression( Node n, Node exprRoot, String variable)外src/com/google/javascript/jscomp/DeadAssignmentsElimination.java内private boolean isVariableStillLiveWithinExpression( Node n, Node exprRoot, String variable)外src/com/google/javascript/jscomp/DeadAssignmentsElimination.java内private VariableLiveness isVariableReadBeforeKill( Node n, String variable)外src/com/google/javascript/jscomp/DeadAssignmentsElimination.java内private VariableLiveness isVariableReadBeforeKill( Node n, String variable)	a6ca7c196cb8f9bcddefd038d80217c3de486e4e	78b01c3a435cd175ce3ee70f97b2f8faac342cdc	384	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-384.json	Assignments within conditions are sometimes incorrectly removed	What steps will reproduce the problem?   1. See attachment.  2. Run original.  3. Run compiled.      What is the expected output? What do you see instead?   * Both should return "true"  * Original does return "true"  * Compiled returns "undefined"      What version of the product are you using? On what operating system?   Closure Compiler (http://code.google.com/closure/compiler)  Version: 706  Built on: 2011/01/19 19:53    Mac OS X 10.6    Please provide any additional information below.   In the attached reduction if the "echo" functions aren't used then the entire body of the function is compiled away, they are there to demonstrate that the first assignment in the condition is removed.      Original:    function reduction()  {      var a, b;      if (echo(b = true) || echo(b = false))          a = b;      else          a = null;      return a;  }      Compiled:    function reduction() {      var a;      return echo(true) || echo(a = false) ? a: null  }	src
77	src/com/google/javascript/jscomp/CodeGenerator.java内static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder)	25827942ba9d45825dfd92faa37a78dbc9034ad0	b88400ce0e9c1a0dadfd3417c256b02a82f38fe1	383	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-383.json	\0 \x00 and \u0000 are translated to null character	What steps will reproduce the problem? 1. write script with string constant "\0" or "\x00" or "\u0000"    What is the expected output? What do you see instead? I expected a string literal with "\0" (or something like that)  and instead get a string literal with three null character values.    What version of the product are you using? On what operating system? compiler-20110119.zip on windows 7 x64    Please provide any additional information below.   This is causing an issue with IE9 and jQuery.getScript. It causes IE9 to interpret the null character as the end of the file instead of a null character.	src
78	src/com/google/javascript/jscomp/PeepholeFoldConstants.java内private Node performArithmeticOp(int opType, Node left, Node right)	b40c6c7e0e323f1b69fe7f9686ed8f763b01faf8	25829b0395164533782d608399096803321225a7	381	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-381.json	division by zero wrongly throws JSC_DIVIDE_BY_0_ERROR	What steps will reproduce the problem?   unaliased division by zero `1/0`    What is the expected output? What do you see instead?   I expect minified code, but an error is thrown instead.    What version of the product are you using? On what operating system?   appspot    Please provide any additional information below.   Division by zero is a perfectly sane operation in ECMAScript. See 11.5.2 [0] of the ECMAScript 5 specification. Aliased division by zero `(n=1)/0` is permitted.    [0] http://es5.github.com/#x11.5.2	src
79	src/com/google/javascript/jscomp/Normalize.java内private void reportCodeChange(String changeDescription)外src/com/google/javascript/jscomp/VarCheck.java内private void createSynthesizedExternVar(String varName)	f3c23f757da302483c86414ec8b9c502f10fce00	5d397618f3c86d9c444a4c4c6441267b8a89a21d	367	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-367.json	RuntimeException when compiling with extern prototype	What steps will reproduce the problem?   1. java -jar compiler.jar --compilation_level ADVANCED_OPTIMIZATIONS --externs prototype.js --js bootloader.js    What is the expected output? What do you see instead?   java.lang.RuntimeException: java.lang.RuntimeException: INTERNAL COMPILER ERROR.  Please report this problem.  null    Node(FUNCTION ): prototype.js:213:11    function Str(key, holder, stack) {    Parent(BLOCK): prototype.js:160:12  (function() {     at com.google.javascript.jscomp.Compiler.runCallable(Unknown Source)   at com.google.javascript.jscomp.Compiler.runInCompilerThread(Unknown Source)   at com.google.javascript.jscomp.Compiler.compile(Unknown Source)   at com.google.javascript.jscomp.Compiler.compile(Unknown Source)   at com.google.javascript.jscomp.AbstractCommandLineRunner.doRun(Unknown Source)   at com.google.javascript.jscomp.AbstractCommandLineRunner.run(Unknown Source)   at com.google.javascript.jscomp.CommandLineRunner.main(Unknown Source)  Caused by: java.lang.RuntimeException: INTERNAL COMPILER ERROR.  Please report this problem.  null    Node(FUNCTION ): prototype.js:213:11    function Str(key, holder, stack) {    Parent(BLOCK): prototype.js:160:12  (function() {     at com.google.common.base.Preconditions.checkState(Preconditions.java:129)   at com.google.javascript.jscomp.Normalize$DuplicateDeclarationHandler.onRedeclaration(Unknown Source)   at com.google.javascript.jscomp.SyntacticScopeCreator.declareVar(Unknown Source)   at com.google.javascript.jscomp.SyntacticScopeCreator.scanVars(Unknown Source)   at com.google.javascript.jscomp.SyntacticScopeCreator.scanVars(Unknown Source)   at com.google.javascript.jscomp.SyntacticScopeCreator.scanVars(Unknown Source)   at com.google.javascript.jscomp.SyntacticScopeCreator.scanVars(Unknown Source)   at com.google.javascript.jscomp.SyntacticScopeCreator.scanVars(Unknown Source)   at com.google.javascript.jscomp.SyntacticScopeCreator.scanVars(Unknown Source)   at com.google.javascript.jscomp.SyntacticScopeCreator.scanVars(Unknown Source)   at com.google.javascript.jscomp.SyntacticScopeCreator.scanVars(Unknown Source)   at com.google.javascript.jscomp.SyntacticScopeCreator.scanRoot(Unknown Source)   at com.google.javascript.jscomp.SyntacticScopeCreator.createScope(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.getScope(Unknown Source)      What version of the product are you using? On what operating system? Version: 706  Built on: 2011/01/19 19:53    Mac OS X 10.6.0  	src
80	src/com/google/javascript/jscomp/NodeUtil.java内static boolean isBooleanResultHelper(Node n)外src/com/google/javascript/jscomp/NodeUtil.java内static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals)	a2153e7405e09c8fa413a01874c949b8b2bcd32b	58786c3f717fa506280127265cd68fedf17de0a9	364	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-364.json	Unexpected expression nodeDELPROP 1	As of version 20110119 of the closure compiler, the following code produces an error when it's compiled with advanced compilation enabled:        function x() { return delete a; }      The exact output of the compiler:      java.lang.RuntimeException: java.lang.RuntimeException: INTERNAL COMPILER ERROR.  Please report this problem.  Unexpected expression nodeDELPROP 1 [sourcename: stdin]   parent:RETURN 1 [sourcename: stdin]    Node(RETURN): stdin:1:15  function x() { return delete a; }    Parent(BLOCK): stdin:1:13  function x() { return delete a; }     at com.google.javascript.jscomp.Compiler.runCallable(Unknown Source)   at com.google.javascript.jscomp.Compiler.runInCompilerThread(Unknown Source)   at com.google.javascript.jscomp.Compiler.compile(Unknown Source)   at com.google.javascript.jscomp.Compiler.compile(Unknown Source)   at com.google.javascript.jscomp.AbstractCommandLineRunner.doRun(Unknown Source)   at com.google.javascript.jscomp.AbstractCommandLineRunner.run(Unknown Source)   at com.google.javascript.jscomp.CommandLineRunner.main(Unknown Source)  Caused by: java.lang.RuntimeException: INTERNAL COMPILER ERROR.  Please report this problem.  Unexpected expression nodeDELPROP 1 [sourcename: stdin]   parent:RETURN 1 [sourcename: stdin]    Node(RETURN): stdin:1:15  function x() { return delete a; }    Parent(BLOCK): stdin:1:13  function x() { return delete a; }     at com.google.javascript.jscomp.NodeUtil.evaluatesToLocalValue(Unknown Source)   at com.google.javascript.jscomp.NodeUtil.evaluatesToLocalValue(Unknown Source)   at com.google.javascript.jscomp.PureFunctionIdentifier$FunctionAnalyzer.visit(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseFunction(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverse(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverse(Unknown Source)   at com.google.javascript.jscomp.PureFunctionIdentifier.process(Unknown Source)   at com.google.javascript.jscomp.PureFunctionIdentifier$Driver.process(Unknown Source)   at com.google.javascript.jscomp.PhaseOptimizer$PassFactoryDelegate.processInternal(Unknown Source)   at com.google.javascript.jscomp.PhaseOptimizer$NamedPass.process(Unknown Source)   at com.google.javascript.jscomp.PhaseOptimizer.process(Unknown Source)   at com.google.javascript.jscomp.Compiler.optimize(Unknown Source)   at com.google.javascript.jscomp.Compiler.compileInternal(Unknown Source)   at com.google.javascript.jscomp.Compiler.access$000(Unknown Source)   at com.google.javascript.jscomp.Compiler$1.call(Unknown Source)   at com.google.javascript.jscomp.Compiler$1.call(Unknown Source)   at com.google.javascript.jscomp.Compiler$2.run(Unknown Source)   at java.lang.Thread.run(Thread.java:680)  Caused by: java.lang.IllegalStateException: Unexpected expression nodeDELPROP 1 [sourcename: stdin]   parent:RETURN 1 [sourcename: stdin]   ... 23 more  	src
81	src/com/google/javascript/jscomp/parsing/IRFactory.java内Node processFunctionNode(FunctionNode functionNode)	a65a72e9dd320790710beed1593dd6358c4bf029	084b868bc2fbf9d6d0319e5a362ade1d7f43f899	251	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-251.json	An unnamed function statement statements should generate a parse error	An unnamed function statement statements should generate a parse error, but it does not, for example:    function () {};    Note: Unnamed function expression are legal:    (function(){});        	src
82	src/com/google/javascript/rhino/jstype/JSType.java内public boolean isNoObjectType()	1a7fbd18b47c102152869c3b046b65ff0f12fc43	a857aec27d79fc234fddd4a72c1215af0251b2d8	301	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-301.json	.indexOf fails to produce missing property warning	The following code compiled with VERBOSE warnings or with the missingProperties check enabled fails to produce a warning or error:    var s = new String("hello");  alert(s.toLowerCase.indexOf("l"));    However, other string functions do properly produce the warning:    var s = new String("hello");  alert(s.toLowerCase.substr(0, 1));	src
83	src/com/google/javascript/jscomp/CommandLineRunner.java内public BooleanOptionHandler( CmdLineParser parser, OptionDef option, Setter<? super Boolean> setter)	840ddca5b28cea7563a5be20d2624478af67bc02	43c245f0ff8d409e81e25687e69d34666b7cf26a	319	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-319.json	Cannot see version with --version	What steps will reproduce the problem? 1. Download sources of latest (r698) command-line version of closure compiler.  2. Build (with ant from command line).  3. Run compiler (java -jar compiler.jar --version).    What is the expected output?  Closure Compiler (http://code.google.com/closure/compiler)  Version: 698  Built on: 2011/01/17 12:16    What do you see instead?  Опция "--version" требует операнд  (Option "--version" requires operand)  and full list of options with description.    What version of the product are you using? On what operating system? Latest source of command-line compiler from SVN (r698). OS Linux Mint 7, Sun Java 1.6.0_22.    Please provide any additional information below. When running compiler with  java -jar compiler.jar --version ?  it shows error message, then version info, then full list of options.	src
84	src/com/google/javascript/jscomp/parsing/IRFactory.java内Node processArrayLiteral(ArrayLiteral literalNode)外src/com/google/javascript/jscomp/parsing/IRFactory.java内Node processUnaryExpression(UnaryExpression exprNode)外src/com/google/javascript/jscomp/parsing/IRFactory.java内Node processUnaryExpression(UnaryExpression exprNode)	9f8345afa4e5eaa24e3ff6a84d16691764698799	4839e1ea57f9a1a26debd2cc8f22beef7282b490	215	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-215.json	Invalid left-hand side of assignment not detected	What steps will reproduce the problem? Compile this:    var x=0,y=1;x||y=8    What is the expected output? What do you see instead? I expect an error, because this is parsed as (x||y)=8, which is an invalid left-hand side of an assignment. Instead, I get    var x=0,y=1;x||y=8;  which, like the input, is invalid code.	src
85	src/com/google/javascript/jscomp/UnreachableCodeElimination.java内private Node tryRemoveUnconditionalBranching(Node n)外src/com/google/javascript/jscomp/UnreachableCodeElimination.java内private Node tryRemoveUnconditionalBranching(Node n)外src/com/google/javascript/jscomp/UnreachableCodeElimination.java内private Node tryRemoveUnconditionalBranching(Node n)	2410995673fcaaaec5d4d48eae9139127c64acac	21a2103d7fa5664ea324ef9ee25b4a8922e50955	311	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-311.json	Reproduceable crash with switch statement	When attempting to compile the following code with default options (-jar compiler.jar --js filename) always produces the same error.    function a(b) {    switch (b.v) {      case 'SWITCH':        if (b.i >= 0) {          return b.o;        } else {          return undefined;        }        break;    }  }    Whenever I try and compile the above script I get a RuntimeException thrown:    INTERNAL COMPILER ERROR.  Please report this problem.  null    Node(BREAK): C:\test.js:11:3        break;    Parent: NULL    The result of calling --version on compiler.jar:    Version: 20100917 (revision 440)  Built on: 2010/09/17 17:55    The result of calling -version on java.exe:    java version "1.6.0_11"  Java(TM) SE Runtime Environment (build 1.6.0_11-b03)  Java HotSpot(TM) Client VM (build 11.0-b16, mixed mode, sharing)    Anyone else with the same issue - to work around in the short term, comment out the "break;" line.	src
86	src/com/google/javascript/jscomp/NodeUtil.java内static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals)	5cd9c1efe90dc7c1be33cd7f8c1dcbaa9225909e	0907b6618a60b2de23c8f7ec2217a37dc5e9a091	303	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-303.json	side-effects analysis incorrectly removing function calls with side effects	Sample Code:  ---  /** @constructor */  function Foo() {    var self = this;    window.setTimeout(function() {      window.location = self.location;    }, 0);  }    Foo.prototype.setLocation = function(loc) {    this.location = loc;  };    (new Foo()).setLocation('http://www.google.com/');  ---    The setLocation call will get removed in advanced mode.	src
87	src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java内private boolean isFoldableExpressBlock(Node n)	e9f7e6114414f68deb90f4116861d7a054365404	f64a3f51bd346547ce6e1edb30601df73dff27d9	291	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-291.json	IE8 error: Object doesn't support this action	What steps will reproduce the problem? 1. Use script with fragment like      if (e.onchange) {        e.onchange({          _extendedByPrototype: Prototype.emptyFunction,          target: e        });      }  2. Compile with Compiler (command-line, latest version)  3. Use in IE8    What is the expected output?  Script:  if(b.onchange){b.onchange({_extendedByPrototype:Prototype.emptyFunction,target  :b})}    What do you see instead?  Script:  b.onchange&&b.onchange({_extendedByPrototype:Prototype.emptyFunction,target  :b})  IE8:  Error message "Object doesn't support this action"    What version of the product are you using? On what operating system? Version: 20100917 (revision 440)  Built on: 2010/09/17 17:55  	src
88	src/com/google/javascript/jscomp/DeadAssignmentsElimination.java内private VariableLiveness isVariableReadBeforeKill( Node n, String variable)	d68322323aa52d943b9dc5618ef8ea81d43d7b4f	6a17da87f9e132bdc147b33223826da040c77a6b	297	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-297.json	Incorrect assignment removal from expression in simple mode.	function closureCompilerTest(someNode) {     var nodeId;     return ((nodeId=someNode.id) && (nodeId=parseInt(nodeId.substr(1))) && nodeId>0);  }    COMPILES TO:    function closureCompilerTest(b){var a;return b.id&&(a=parseInt(a.substr(1)))&&a>0};    "nodeId=someNode.id" is replaced with simply "b.id" which is incorrect as the value of "nodeId" is used.	src
89	src/com/google/javascript/jscomp/CollapseProperties.java内private void updateSimpleDeclaration(String alias, Name refName, Ref ref)外src/com/google/javascript/jscomp/GlobalNamespace.java内boolean canCollapseUnannotatedChildNames()	e7ad2425c384dcb18a34bec8e147a91c658d5118	4b065734d8afb5ab0d241ee5da22af0fa9d75ec3	289	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-289.json	Compiler removes function properties that it should not	The Compiler appears to remove properties that are added to functions. I do not believe that it should do such a thing. In the following example, I add a property named "alwaysCall" to a function that I check later. The property appears to be stripped, which changes the behavior of the program. To see this in action run the following through http://closure-compiler.appspot.com/home:    // ==ClosureCompiler==  // @compilation_level ADVANCED_OPTIMIZATIONS  // @output_file_name default.js  // @use_closure_library true  // @formatting pretty_print  // ==/ClosureCompiler==    var lastMsg;  var map = {};    var addToMap = function(key, func) {    map[key] = func;  };    var f1 = function() { alert('f1'); };  f1.alwaysCall = true;  var f2 = function() { alert('f2'); };    addToMap('f1', f1);  addToMap('f2', f2);    var callFunctionByKey = function(key) {    var f = map[key];    if (f.alwaysCall) f();  };    callFunctionByKey(Math.random() > 0.5 ? 'f1' : 'f2');      The compiled code is:      var a = {};  a.f1 = function() {    alert("f1")  };  a.f2 = function() {    alert("f2")  };  var b = a[Math.random() > 0.5 ? "f1" : "f2"];  b.a && b();    Note that a.f1 does not have a property defined on it anymore, though it still appears to be checked on this line of code:    b.a && b();    So it looks like it is missing the following:    a.f1.a =  true;    For now, I can workaround this by quoting the property:    f1['alwaysCall'] = true;    // In callFunctionByKey:  if (f['alwaysCall']) f();    But that seems as though it should not be necessary.  	src
90	src/com/google/javascript/jscomp/FunctionTypeBuilder.java内public boolean apply(JSType type)外src/com/google/javascript/rhino/jstype/FunctionType.java内JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope)	97485ec652a6d3471c539d5b0ead4f05707db139	c5e143f7df0c3d73f6634488cac8ad8e7054fe05	274	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-274.json	@this emits warning when used with a typedef	What steps will reproduce the problem?   1. Compile this with r520:    goog.provide('bug');    /**   * @this {bug.Thing}   */  bug.sharedMethod = function() {};    /**   * @constructor   */  bug.A = function() {};    /**   * @constructor   */  bug.B = function() {};    /**   * @type {bug.A|bug.B}   */  bug.Thing = goog.typedef;    2. Observe this warning:    Oct 28, 2010 9:59:15 PM com.google.javascript.jscomp.PhaseOptimizer$NamedPass process  INFO: sanityCheckVars  Oct 28, 2010 9:59:15 PM com.google.javascript.jscomp.LoggerErrorManager println  WARNING: /home/elf/JSPATH/compiler_bug_this_typedef.js:6: WARNING - @this type of a function must be an object  Actual type: (bug.A|bug.B|null)  bug.sharedMethod = function() {};      Note that @this {!bug.Thing} doesn't work either, while @this {bug.A|bug.B} works.  This code did not emit a warning in r481.    This code is what caused me to run into http://code.google.com/p/closure-compiler/issues/detail?id=268	src
91	src/com/google/javascript/jscomp/CheckGlobalThis.java内public boolean shouldTraverse(NodeTraversal t, Node n, Node parent)	8eee751ff9f460c4a769d598c65b1cd643dabc7b	7eb2d84de101a125d41d3a1157f4eed789ca4a0d	248	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-248.json	support @lends annotation	Some javascript toolkits (dojo, base, etc.) have a special way of declaring (what java calls) classes, for example in dojo:    dojo.declare("MyClass", [superClass1, superClass2], {       foo: function(){ ... }       bar: function(){ ... }   });     JSDoc (or at least JSDoc toolkit) supports this via annotations:     /**    * @name MyClass    * @class    * @extends superClass1    * @extends superClass2    */   dojo.declare("MyClass", [superClass1, superClass2], /** @lends   MyClass.prototype */ {       foo: function(){ ... }       bar: function(){ ... }   });     The @lends keyword in particular is useful since it tells JSDoc that foo and bar are part of MyClass's prototype.   But closure compiler isn't picking up on that, thus I get a bunch of errors about "dangerous use of this" inside of foo() and bar().     So, can @lends support be added to the closure compiler?    The workaround is to use @this on every method, but not sure if that is sufficient to make advanced mode compilation work correctly.	src
92	src/com/google/javascript/jscomp/ProcessClosurePrimitives.java内void replace()	39dde4ca5df6263d7058029e081a710d7fa13de9	8980b60033b1c6853cbca593ec89d3d332adf7dc	261	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-261.json	bug with implicit namespaces across modules	If there are three modules, the latter two of which depend on the root module:    // Module A  goog.provide('apps');    // Module B  goog.provide('apps.foo.bar.B');    // Module C  goog.provide('apps.foo.bar.C');    and this is compiled in SIMPLE_OPTIMIZATIONS mode, the following code will be produced:    // Module A  var apps={};apps.foo.bar={};apps.foo={};    // Module B  apps.foo.bar.B={};    // Module C  apps.foo.bar.C={};    This will result in a runtime error in Module A because apps.foo.bar is assigned before apps.foo.    The patch for the fix (with regression test) is available at:  http://codereview.appspot.com/2416041    	src
93	src/com/google/javascript/jscomp/ProcessClosurePrimitives.java内void replace()	386ab6da410291c7b9b4880354dae764275a9518	9d1e18e87a41f2a610ed70f3a1d57abbce7a1cd7	261	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-261.json	bug with implicit namespaces across modules	If there are three modules, the latter two of which depend on the root module:    // Module A  goog.provide('apps');    // Module B  goog.provide('apps.foo.bar.B');    // Module C  goog.provide('apps.foo.bar.C');    and this is compiled in SIMPLE_OPTIMIZATIONS mode, the following code will be produced:    // Module A  var apps={};apps.foo.bar={};apps.foo={};    // Module B  apps.foo.bar.B={};    // Module C  apps.foo.bar.C={};    This will result in a runtime error in Module A because apps.foo.bar is assigned before apps.foo.    The patch for the fix (with regression test) is available at:  http://codereview.appspot.com/2416041    	src
94	src/com/google/javascript/jscomp/NodeUtil.java内static boolean isValidDefineValue(Node val, Set<String> defines)	9d72612f028076aa43a9b259c29b2a940398465f	7cc748592670105f9d783b1b85f0f27e938db4ff	255	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-255.json	closure-compiler @define annotation does not allow line to be split on 80 characters.	What steps will reproduce the problem? 1.  Create a JavaScript file with the followiing:  /** @define {string} */  var CONSTANT = "some very long string name that I want to wrap " +                 "and so break using a + since I don't want to " +                 "introduce a newline into the string."  2.  Run closure-compiler on the .js file.  3.  See it generate an error on the '+'.    What is the expected output? What do you see instead? It should work, since the line is assigning a constant value to the var.    Please provide any additional information below. Removing the '+' and making the string all one line does work correctly.  	src
95	src/com/google/javascript/jscomp/TypedScopeCreator.java内void defineSlot(Node n, Node parent, JSType type, boolean inferred)	f93cdf97ea803c4702023daf1326dc45172de611	f6607996d6d3bd6820ce3848d147991b27600a12	66	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-66.json	Use @public tag to prevent compression of symbol names	Given this input code:     Glow = {};   /** @public */ Glow.versions = [1,2,3];   Glow.showVersions = function() { alert(Glow.versions); }      // exports   window['Glow'] = Glow;   Glow['versions'] = Glow.versions;   Glow['showVersions'] = Glow.showVersions;    The compiler (with ADVANCED_OPTIMIZATIONS on) will produce the following  output code:     Glow = {};   Glow.a = [1, 2, 3];   Glow.b = function() { alert(Glow.a) };   window.Glow = Glow;   Glow.versions = Glow.a;   Glow.showVersions = Glow.b    From outside the Glow library, a user may do the following (in their own,  uncompressed code):     Glow.versions = [4,5,6];   Glow.showVersions();    Only in the compiled code will the user-code produces "1,2,3" instead of  the expected "4,5,6". This is because the compiler renamed the reference to  [1,2,3] in `showVersions()` to "Glow.a", whilst the user assigned a new  array to "Glow.versions", and therefore the two different names now refer  to two different arrays.    I can avoid this by using the stringy-name to refer to Glow["versions"],  but I would then have to do that everywhere in my code which is a annoying  and bug-prone (if I or someone else should ever forget). I'd prefer to tell  the compiler once about my wish to have a property name left uncompresed,  rather than relying on a side effect (the fact that the compiler won't  compress stringy-named properties) and then having to invoke that  side-effect consistently everywhere.    Instead I'm requesting that when the compiler sees a property is marked by  the author as @public it should then leave that name uncompressed everywhere.    So, given the input code above, the desired output would be:     Glow = {};   Glow.versions = [1, 2, 3];   Glow.b = function() { alert(Glow.versions) };   window.Glow = Glow;   Glow.versions = Glow.versions; // not needed now   Glow.showVersions = Glow.b    I'm not fixed on a particular tag, but @public seems an obvious choice, and  I'd prefer to use tags that already exist in JsDoc Toolkit.    Note that my proposed feature is different than the `@export Glow.versions`  tag proposal, as that tag would merely be a shortcut for "Glow['versions']  = Glow.versions;", which, as I've shown above, doesn't solve this problem.  	src
96	src/com/google/javascript/jscomp/TypeCheck.java内private void visitParameterList(NodeTraversal t, Node call, FunctionType functionType)	b9bc1534921f1e98da5a373e39ea2d71a4a39175	807aaf2569e9eb09761068c5aeb95654daea30d9	229	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-229.json	Missing type-checks for var_args notation	What steps will reproduce the problem? 1. Compile this:  //-------------------------------------  // ==ClosureCompiler==  // @compilation_level SIMPLE_OPTIMIZATIONS  // @warning_level VERBOSE  // @output_file_name default.js  // @formatting pretty_print  // ==/ClosureCompiler==    /**  * @param {...string} var_args  */  function foo(var_args) {      return arguments.length;  }    foo('hello'); // no warning - ok  foo(123); // warning - ok  foo('hello', 123); // no warning! error.  //-------------------------------------    What is the expected output? What do you see instead? Should get a type-mismatch warning for the second parameter in the third foo() call.    What version of the product are you using? On what operating system? Both online compiler and the 20100616 release.    Please provide any additional information below. Seems like the type-checker treats 'var_args' as a single param and thus fails to type check the subsequent parameters.    // Fredrik	src
97	src/com/google/javascript/jscomp/PeepholeFoldConstants.java内private Node tryFoldShift(Node n, Node left, Node right)	4cf197f69d8733ac68b02672b2e23d7939e5eb76	ee749e286b477f8d6f53ff5960a38453baf50f31	200	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-200.json	Unsigned Shift Right (>>>) bug operating on negative numbers	What steps will reproduce the problem? i = -1 >>> 0 ;    What is the expected output? What do you see instead? Expected: i = -1 >>> 0 ;  // or // i = 4294967295 ;  Instead: i = -1 ;    What version of the product are you using? On what operating system? The UI version as of 7/18/2001 (http://closure-compiler.appspot.com/home)    Please provide any additional information below. -1 >>> 0 == 4294967295 == Math.pow( 2, 32 ) - 1  Test in any browser and/or See ECMA-262-5 11.7.3    	src
98	src/com/google/javascript/jscomp/ReferenceCollectingCallback.java内boolean isAssignedOnceInLifetime()外src/com/google/javascript/jscomp/ReferenceCollectingCallback.java内public String getSourceName()外src/com/google/javascript/jscomp/ReferenceCollectingCallback.java内public String getSourceName()	d768bbc4212ee0d95d20d52426fbad47f0f9c56e	d1df970451b5a18956448097b3afb43f3a82263d	174	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-174.json	bad variable inlining in closure	// ==ClosureCompiler==  // @compilation_level SIMPLE_OPTIMIZATIONS  // @output_file_name default.js  // @formatting pretty_print  // ==/ClosureCompiler==    function foo() {   var arr = [1, 2, 3, 4, 5];   for (var i = 0, l = arr.length; i < l; i++) {     var j = arr[i];     (function() {       var k = j;       setTimeout(function() { console.log(k); }, 0);     })();   }  }  foo();    "k" will get incorrectly inlined.	src
99	src/com/google/javascript/jscomp/CheckGlobalThis.java内public boolean shouldTraverse(NodeTraversal t, Node n, Node parent)外src/com/google/javascript/jscomp/CheckGlobalThis.java内public boolean shouldTraverse(NodeTraversal t, Node n, Node parent)	ccbbcbf71b1cb8771c9cdad1d28b367ce6ea0da2	8aa879a4eeb18cfc8d13e6c843a32b7f41ccd516	125	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-125.json	Prototypes declared with quotes produce a JSC_USED_GLOBAL_THIS warning.	Compiling the following code (in advanced optimizations with VERBOSE  warning levels):    /** @constructor */  function MyClass() {}  MyClass.prototype["MyMethod"] = function(a) {    this.a = a;  }  window["MyClass"] = MyClass;    Results in the following warning: "dangerous use of the global this  object." This notation is convenient to declare a prototype that is purely  used for export purposes. The warning can be suppressed by using an @this  notation.    Given the following externs:    /**@interface */  function MyParent() {}  /** @param {*} a */  MyParent.prototype.MyMethod = function(a) {}    And the following code:    /**  * @constructor  * @implements {MyParent}  */  function MyClass() {}  MyClass.prototype["MyMethod"] = function(a) {    this.a2 = a;  }  window["MyClass"] = MyClass;    The compiler also produces the waring: "property MyMethod on interface  MyParent is not implemented by type MyClass".	src
100	src/com/google/javascript/jscomp/CheckGlobalThis.java内public boolean shouldTraverse(NodeTraversal t, Node n, Node parent)外src/com/google/javascript/jscomp/CheckGlobalThis.java内private boolean shouldReportThis(Node n, Node parent)	71a6f6049d9359ea047adafc2a77e4dfb1398f41	6d00ac1a68612aade8a19d7ecc9b180f00ae5234	144	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-144.json	Only assignment to "this" issues a "dangerous use of the global this object" warning.	What steps will reproduce the problem? 1. Compile this:  //////////////////////////////////////////  // ==ClosureCompiler==  // @compilation_level ADVANCED_OPTIMIZATIONS  // @output_file_name default.js  // ==/ClosureCompiler==    /** @constructor */  function Foo()  {      this._bar = null;  };    /** @this {Foo} */  function writeMethodWithAnnotation()  {     this._bar = 123; // no warning. ok  }    /** @this {Foo} */  function readMethodWithAnnotation()  {     return this._bar; // no warning. ok  }    //----    function writeMethodWithoutAnnotation()  {     this._bar = 123; // warning. ok.  }    function readMethodWithoutAnnotation()  {     return this._bar; // <- No warning!  }  //////////////////////////////////////////    What is the expected output? What do you see instead? - Should get two "dangerous use of the global this object" warnings in the   readMethodWithAnnotation and writeMethodWithoutAnnotation functions.  - Only writeMethodWithoutAnnotation warns.    What version of the product are you using? On what operating system? Both 20100330 and online compiler.    Please provide any additional information below. ref: http://code.google.com/closure/compiler/docs/js-for-compiler.html   "To prevent compiler warnings, you must use a @this annotation whenever   this appears in a function that is neither a prototype method nor a   function marked as a @constructor."    This also means the example code in the docs won't trig a warning.  -----  /**   * Returns the roster widget element.   * @this {Widget} <-- currently this doesn't matter   * @return {Element}   */  function() {    return this.getComponent().getElement();  });  ------    // Fredrik	src
101	src/com/google/javascript/jscomp/CommandLineRunner.java内protected CompilerOptions createOptions()	2d892b164f41c053de4d56e424f0815576c6dc54	369282db85567f1bf2c9635d0c0043d47f114814	130	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-130.json	--process_closure_primitives can't be set to false	What steps will reproduce the problem? 1. compile a file with "--process_closure_primitives false"  2. compile a file with "--process_closure_primitives true" (default)  3. result: primitives are processed in both cases.    What is the expected output? What do you see instead? The file should still have its goog.provide/require tags in place.  Instead they are processed.    What version of the product are you using? On what operating system? current SVN (also tried two of the preceding binary releases with same   result)    Please provide any additional information below. Flag can't be set to false due to a missing "else" in the command-line   parser.	src
102	src/com/google/javascript/jscomp/Normalize.java内private void reportCodeChange(String changeDescription)	9a1ddf5f982e54ecbc3e028dfa84ef9bd07a8044	d48c365ba8251057a71a2e2b7aabff640209e31b	115	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-115.json	compiler assumes that 'arguments' can be shadowed	The code:  function name() {     var arguments = Array.prototype.slice.call(arguments, 0);  }    gets compiled to:  function name(){ var c=Array.prototype.slice.call(c,0); }    Thanks to tescosquirrel for the report.	src
103	src/com/google/javascript/jscomp/DisambiguateProperties.java内public JSTypeSystem(AbstractCompiler compiler)外src/com/google/javascript/jscomp/ControlFlowAnalysis.java内private static boolean mayThrowException(Node n)	67289ae4cbaba3ae70cd2e8fb92f3f2898039dfb	2f5cb1622371de540fe20dcbe0411651ec89f952	113	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-113.json	Compiler gives false error with respect to unreachable code	Try compiling the following in the Closure Compiler UI:    // ==ClosureCompiler==  // @compilation_level SIMPLE_OPTIMIZATIONS  // @output_file_name default.js  // ==/ClosureCompiler==    function instanceOf(value, type) {    try {      // first try built-in test -- if it succeeds, we're golden.      if (value instanceof type) {        return true;      }    } catch (exception) {      if (exception instanceof TypeError) {        throw exception; // indicates that "type" is not a type      }      // Otherwise, assume the exception was caused by       // the Firefox 1.0.3 bug.  Work around it.      return (type === Object);    }  }    The Compiler issues the following warning:    JSC_UNREACHABLE_CODE: unreachable code at line 7 character 0    } catch (exception) {    This code is from a Firefox extension (Chickenfoot) where (at least  historically) calling instanceof in this manner could throw a security  exception (or something else, I forget what -- Chickenfoot has been around  since Firefox 1.0) which is why the catch blocks is there and is indeed  reachable.	src
104	src/com/google/javascript/rhino/jstype/UnionType.java内JSType meet(JSType that)	1be1c2636ef14071afa7da5cb8988972bd90149f	67289ae4cbaba3ae70cd2e8fb92f3f2898039dfb	114	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-114.json	Typos in externs/html5.js	Line 354:  CanvasRenderingContext2D.prototype.globalCompositingOperation;    Line 366:  CanvasRenderingContext2D.prototype.mitreLimit;    They should be globalCompositeOperation and miterLimit, respectively.  	src
105	src/com/google/javascript/jscomp/FoldConstants.java内void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent)外src/com/google/javascript/jscomp/FoldConstants.java内void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent)	8e121a1fe0cea18df772320da1b663a6d663a0e8	113a08f59e8116fb11a7d4ceb11d5bb09b74ac3c	106	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-106.json	Array Join Munged Incorrectly	$.fn.hasClass = function(selector) {   return ( this.length > 0 ?       !( ( ['', this[0].className, ''].join(' ') ).indexOf( ['', selector,   ''].join(' ') ) == -1 )      : false );  };    munges into    $.fn.hasClass=function(a){return this.length>0?  (""+this[0].className).indexOf(""+a)!=-1:false};    which is not identical. Looks like there might be an issue with join and ' '.	src
106	src/com/google/javascript/rhino/JSDocInfoBuilder.java内public void markName(String name, int lineno, int charno)外src/com/google/javascript/jscomp/GlobalNamespace.java内boolean canCollapseUnannotatedChildNames()	6a36f04485599820ff86441accee002b4deec2eb	e609670bb56e0c7216c9476a5f6a5594e7f1acdb	19	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-19.json	Exception thrown from com.google.javascript.jscomp.CollapseProperties.addStubsForUndeclaredProperties	The attached javascript file results in a Java exception being thrown when compiling with ADVANCED_OPTIMIZATIONS    [~/Projects/Music Theory/trunk] # java -jar ./ext/closure-compiler/compiler.jar --js /tmp/musictheory.net/v2/js/core.js --compilation_level   ADVANCED_OPTIMIZATIONS  java.lang.RuntimeException: java.lang.IllegalArgumentException   at com.google.javascript.jscomp.Compiler.runInCompilerThread(Unknown Source)   at com.google.javascript.jscomp.Compiler.compile(Unknown Source)   at com.google.javascript.jscomp.Compiler.compile(Unknown Source)   at com.google.javascript.jscomp.AbstractCompilerRunner.doRun(Unknown Source)   at com.google.javascript.jscomp.AbstractCompilerRunner.run(Unknown Source)   at com.google.javascript.jscomp.CompilerRunner.main(Unknown Source)  Caused by: java.lang.IllegalArgumentException   at com.google.common.base.Preconditions.checkArgument(Preconditions.java:71)   at com.google.javascript.jscomp.CollapseProperties.addStubsForUndeclaredProperties(Unknown Source)   at com.google.javascript.jscomp.CollapseProperties.updateObjLitOrFunctionDeclarationAtAssignNode(Unknown Source)   at com.google.javascript.jscomp.CollapseProperties.updateObjLitOrFunctionDeclaration(Unknown Source)   at com.google.javascript.jscomp.CollapseProperties.collapseDeclarationOfNameAndDescendants(Unknown Source)   at com.google.javascript.jscomp.CollapseProperties.collapseDeclarationOfNameAndDescendants(Unknown Source)   at com.google.javascript.jscomp.CollapseProperties.collapseDeclarationOfNameAndDescendants(Unknown Source)   at com.google.javascript.jscomp.CollapseProperties.collapseDeclarationOfNameAndDescendants(Unknown Source)   at com.google.javascript.jscomp.CollapseProperties.process(Unknown Source)   at com.google.javascript.jscomp.PhaseOptimizer$PassFactoryDelegate.processInternal(Unknown Source)   at com.google.javascript.jscomp.PhaseOptimizer$NamedPass.process(Unknown Source)   at com.google.javascript.jscomp.PhaseOptimizer.process(Unknown Source)   at com.google.javascript.jscomp.Compiler.optimize(Unknown Source)   at com.google.javascript.jscomp.Compiler.compileInternal(Unknown Source)   at com.google.javascript.jscomp.Compiler.access$000(Unknown Source)   at com.google.javascript.jscomp.Compiler$1.call(Unknown Source)   at com.google.javascript.jscomp.Compiler$1.call(Unknown Source)   at com.google.javascript.jscomp.Compiler$2.run(Unknown Source)   at java.lang.Thread.run(Thread.java:637)    I'm guessing that I did something wrong in my script which adds the goog.exportSymbol() calls, but it probably should give me a nice warning or error instead   of throwing a Java exception ;)	src
107	src/com/google/javascript/jscomp/CommandLineRunner.java内protected CompilerOptions createOptions()	aae547f4d911dfbf42ca5a31aeb401ac83725a14	49e9565febba904484396e2aef7dbe86f55e9cc5	1135	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1135.json	Variable names prefixed with MSG_ cause error with advanced optimizations	Variables named something with MSG_ seem to cause problems with the module system, even if no modules are used in the code.    $ echo "var MSG_foo='bar'" | closure --compilation_level ADVANCED_OPTIMIZATIONS  stdin:1: ERROR - message not initialized using goog.getMsg  var MSG_foo='bar'      ^    It works fine with msg_foo, MSG2_foo, etc.	src
108	src/com/google/javascript/jscomp/ScopedAliases.java内public void applyAlias()外src/com/google/javascript/jscomp/ScopedAliases.java内public void exitScope(NodeTraversal t)外src/com/google/javascript/jscomp/ScopedAliases.java内private void findAliases(NodeTraversal t)外src/com/google/javascript/jscomp/ScopedAliases.java内public void visit(NodeTraversal t, Node n, Node parent)	acd31d1221421da27c4fd1a55ec751488ad85744	aae547f4d911dfbf42ca5a31aeb401ac83725a14	1144	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1144.json	precondition crash: goog.scope local with aliased in the type declaration	var goog = {};  goog.scope;    var ns = {};  ns.sub = {};  /** @constructor */  ns.sub.C = function() {};      goog.scope(function() {    var sub = ns.sub;    /** @type {sub.C} */    var x = null;  });      produces:    java.lang.IllegalStateException at com.google.common.base.Preconditions.checkState(Preconditions.java:137) at com.google.javascript.jscomp.ScopedAliases$AliasedTypeNode.applyAlias(ScopedAliases.java:236) at com.google.javascript.jscomp.ScopedAliases.hotSwapScript(ScopedAliases.java:147) at com.google.javascript.jscomp.ScopedAliases.process(ScopedAliases.java:128) at 	src
109	src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java内private Node parseTypeExpression(JsDocToken token)	bb893266036cbc7f0b434794d4fd9306513357be	7d26b7bcae8311f3c032bae3f1df27b590a4c174	1105	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1105.json	Constructor types that return all or unknown fail to parse	Constructor types that return the all type or the unknown type currently fail to parse:    /** @type {function(new:?)} */ var foo = function() {};  /** @type {function(new:*)} */ var bar = function() {};    foo.js:1: ERROR - Bad type annotation. type not recognized due to syntax error  /** @type {function(new:?)} */ var foo = function() {};                          ^    foo.js:2: ERROR - Bad type annotation. type not recognized due to syntax error  /** @type {function(new:*)} */ var bar = function() {};                          ^    This is an issue for a code generator that I'm working on.  	src
110	src/com/google/javascript/jscomp/ScopedAliases.java内private void findAliases(NodeTraversal t)外src/com/google/javascript/jscomp/ScopedAliases.java内private void findAliases(NodeTraversal t)外src/com/google/javascript/jscomp/ScopedAliases.java内private void findAliases(NodeTraversal t)外src/com/google/javascript/jscomp/ScopedAliases.java内private void findAliases(NodeTraversal t)外src/com/google/javascript/jscomp/ScopedAliases.java内private void findAliases(NodeTraversal t)外src/com/google/javascript/rhino/Node.java内public Node getChildBefore(Node child)	5917817198c13401d7eb4e15f3e462fa7f46f1fe	13fb7fcbcad87f8df63535491627bf7b01471064	1111	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1111.json	Allow @private top-level functions in goog.scope	What steps will reproduce the problem? 1. goog.scope(function() {      /* @private */      function test() {}  });    2. The code above gives an error "The local variable test is in a goog.scope and is not an alias."    What is the expected output?    The code above should compile, and function test() be referenceable only from inside the file in question. If I replace "function test" with "var test = function", the code compiles.	src
111	src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java内noLeftCurtyIn1stLine:	450f0f6ef5d9b1bea2bc556e6029fa4f2f8554a2	6f981f77e5bd9e2eecbd851a2a02933cdb9af0d8	1114	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1114.json	goog.isArray doesn't hint compiler	What steps will reproduce the problem? 1.   /**   * @param {*} object   * @return {*}   */  var test = function(object) {    if (goog.isArray(object)) {      /** @type {Array} */ var x = object;      return x;    }  };    2. ADVANCED_OPTIMIZATIONS    What is the expected output? What do you see instead?   ERROR - initializing variable  found   : *  required: (Array|null)      /** @type {Array} */ var x = object;                                   ^  What version of the product are you using? On what operating system?   Closure Compiler (http://code.google.com/closure/compiler)  Version: v20130411-90-g4e19b4e  Built on: 2013/06/03 12:07    Please provide any additional information below.   goog.is* is supposed to help the compiler to check which type we're dealing with.	src
112	src/com/google/javascript/jscomp/TypeInference.java内private boolean inferTemplatedTypesForCall( Node n, FunctionType fnType)	fb0f2fd881cd00766b90d78072ea9ab30e5d7da7	b168c8822b2d3d12515ec6477812674c8805bcf3	1058	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1058.json	Template types on methods incorrectly trigger inference of a template on the class if that template type is unknown	See i.e.        /**    * @constructor    * @template CLASS    */  var Class = function() {};    /**    * @param {function(CLASS):CLASS} a    * @template T    */  Class.prototype.foo = function(a) {    return 'string';  };    /** @param {number} a    * @return {string} */  var a = function(a) { return '' };    new Class().foo(a);      The CLASS type is never specified. If the @template T line is removed from the foo method, the block compiles with but with the @annotation on the method, the compiler seems to try to infer CLASS from the usage and fails compilation.	src
113	src/com/google/javascript/jscomp/ProcessClosurePrimitives.java内private void processRequireCall(NodeTraversal t, Node n, Node parent)	fa1e469dde0bdfd6978a3266db7803b8d39d1d69	0fb76a81bbdd8ab84a00b8be2099abfb83c88668	1079	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1079.json	Bug in require calls processing	The Problem    ProcessClosurePrimitives pass has a bug in processRequireCall method.  The method processes goog.require calls. If a require symbol is invalid i.e is not provided anywhere, the method collects it for further error reporting. If the require symbol is valid, the method removes it from the ast.    All invalid require calls must be left for further using/checking of the code! The related comment in the code confirms this.    Nevertheless, the second condition (requiresLevel.isOn() -> see source code) is invalid and always causes removing of the requires when we want to check these requires.    In any case, the method should not use the requiresLevel to decide if we need removing. The requiresLevel should be used to check if we need error reporting.     The Solution    Remove the condition.  Please see the attached patch.  	src
114	src/com/google/javascript/jscomp/NameAnalyzer.java内private void recordAssignment(NodeTraversal t, Node n, Node recordNode)	a44af4540d0f2bf5fc5ecd0a34c9fea656ee574c	5f03c6817341d39d8dead76c7511fd6bb0b9009f	1085	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1085.json	Crash on the web closure compiler	With the web application (http://closure-compiler.appspot.com/home)    Config:    // ==ClosureCompiler==  // @output_file_name default.js  // @compilation_level ADVANCED_OPTIMIZATIONS  // ==/ClosureCompiler==      Code:    var g=function(m){return m*Math.random()|0},d=document,h=d.getElementById('h'),c=d.getElementById('c'),l;  (l=function(){requestAnimationFrame(l);h.style.textShadow="0 0 1px #000,"+(g(10)-5)+"px "+(g(10)-5)+"px 0 #888,0 0 180px rgb("+g(255)+","+g(255)+","+g(255)+")"})();  d.addEventListener('mousemove',function(v){c.style.marginTop=(v.pageY/10+15|0)+'px'})      Cause:    var l; // DĂŠclare l variable    // Store function in l var and call  (l = function(){ ... })       ();      Crash repport: (long)    23: java.lang.RuntimeException: INTERNAL COMPILER ERROR.  Please report this problem.  Unexpected variable l    Node(NAME l): Input_0:2:36  (l=function(){requestAnimationFrame(l);h.style.textShadow="0 0 1px #000,"+(g(10)-5)+"px "+(g(10)-5)+"px 0 #888,0 0 180px rgb("+g(255)+","+g(255)+","+g(255)+")"})();    Parent(CALL): Input_0:2:14  (l=function(){requestAnimationFrame(l);h.style.textShadow="0 0 1px #000,"+(g(10)-5)+"px "+(g(10)-5)+"px 0 #888,0 0 180px rgb("+g(255)+","+g(255)+","+g(255)+")"})();     at com.google.javascript.jscomp.VarCheck.visit(VarCheck.java:159)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:544)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:538)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:538)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:538)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:538)   at com.google.javascript.jscomp.NodeTraversal.traverseRoots(NodeTraversal.java:318)   at com.google.javascript.jscomp.NodeTraversal.traverseRoots(NodeTraversal.java:507)   at com.google.javascript.jscomp.VarCheck.process(VarCheck.java:102)   at com.google.javascript.jscomp.PhaseOptimizer$NamedPass.process(PhaseOptimizer.java:271)   at com.google.javascript.jscomp.PhaseOptimizer.process(PhaseOptimizer.java:215)   at com.google.javascript.jscomp.Compiler.optimize(Compiler.java:1918)   at com.google.javascript.jscomp.Compiler.compileInternal(Compiler.java:751)   at com.google.javascript.jscomp.Compiler.access$000(Compiler.java:85)   at com.google.javascript.jscomp.Compiler$2.call(Compiler.java:652)   at com.google.javascript.jscomp.Compiler$2.call(Compiler.java:649)   at com.google.javascript.jscomp.Compiler.runInCompilerThread(Compiler.java:709)   at com.google.javascript.jscomp.Compiler.compile(Compiler.java:649)   at com.google.javascript.jscomp.Compiler.compile(Compiler.java:605)   at com.google.javascript.jscomp.webservice.backend.CompilerInvokerImpl.compile(CompilerInvokerImpl.java:47)   at com.google.javascript.jscomp.webservice.backend.ServerController.executeRequest(ServerController.java:174)   at com.google.javascript.jscomp.webservice.backend.CompilationRequestHandler.serviceParsedRequest(CompilationRequestHandler.java:180)   at com.google.javascript.jscomp.webservice.backend.CompilationRequestHandler.service(CompilationRequestHandler.java:162)   at com.google.javascript.jscomp.webservice.frontend.CompilationServlet.doPost(CompilationServlet.java:83)   at javax.servlet.http.HttpServlet.service(HttpServlet.java:637)   at javax.servlet.http.HttpServlet.service(HttpServlet.java:717)   at org.mortbay.jetty.servlet.ServletHolder.handle(ServletHolder.java:511)   at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1166)   at com.google.apphosting.utils.servlet.ParseBlobUploadFilter.doFilter(ParseBlobUploadFilter.java:125)   at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1157)   at com.google.apphosting.runtime.jetty.SaveSessionFilter.doFilter(SaveSessionFilter.java:35)   at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1157)   at com.google.apphosting.utils.servlet.JdbcMySqlConnectionCleanupFilter.doFilter(JdbcMySqlConnectionCleanupFilter.java:60)   at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1157)   at com.google.apphosting.utils.servlet.TransactionCleanupFilter.doFilter(TransactionCleanupFilter.java:43)   at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1157)   at org.mortbay.jetty.servlet.ServletHandler.handle(ServletHandler.java:388)   at org.mortbay.jetty.security.SecurityHandler.handle(SecurityHandler.java:216)   at org.mortbay.jetty.servlet.SessionHandler.handle(SessionHandler.java:182)   at org.mortbay.jetty.handler.ContextHandler.handle(ContextHandler.java:765)   at org.mortbay.jetty.webapp.WebAppContext.handle(WebAppContext.java:418)   at com.google.apphosting.runtime.jetty.AppVersionHandlerMap.handle(AppVersionHandlerMap.java:266)   at org.mortbay.jetty.handler.HandlerWrapper.handle(HandlerWrapper.java:152)   at org.mortbay.jetty.Server.handle(Server.java:326)   at org.mortbay.jetty.HttpConnection.handleRequest(HttpConnection.java:542)   at org.mortbay.jetty.HttpConnection$RequestHandler.headerComplete(HttpConnection.java:923)   at com.google.apphosting.runtime.jetty.RpcRequestParser.parseAvailable(RpcRequestParser.java:76)   at org.mortbay.jetty.HttpConnection.handle(HttpConnection.java:404)   at com.google.apphosting.runtime.jetty.JettyServletEngineAdapter.serviceRequest(JettyServletEngineAdapter.java:146)   at com.google.apphosting.runtime.JavaRuntime$RequestRunnable.run(JavaRuntime.java:439)   at com.google.tracing.TraceContext$TraceContextRunnable.runInContext(TraceContext.java:435)   at com.google.tracing.TraceContext$TraceContextRunnable$1.run(TraceContext.java:442)   at com.google.tracing.CurrentContext.runInContext(CurrentContext.java:186)   at com.google.tracing.TraceContext$AbstractTraceContextCallback.runInInheritedContextNoUnref(TraceContext.java:306)   at com.google.tracing.TraceContext$AbstractTraceContextCallback.runInInheritedContext(TraceContext.java:298)   at com.google.tracing.TraceContext$TraceContextRunnable.run(TraceContext.java:439)   at com.google.apphosting.runtime.ThreadGroupPool$PoolEntry.run(ThreadGroupPool.java:251)   at java.lang.Thread.run(Thread.java:722)  Caused by: java.lang.IllegalStateException: Unexpected variable l   ... 58 more    Original Post Data:   output_format=json&output_info=compiled_code&output_info=warnings&output_info=errors&output_info=statistics&compilation_level=ADVANCED_OPTIMIZATIONS&warning_level=verbose&output_file_name=default.js&js_code=var%20g%3Dfunction(m)%7Breturn%20m*Math.random()%7C0%7D%2Cd%3Ddocument%2Ch%3Dd.getElementById('h')%2Cc%3Dd.getElementById('c')%2Cl%3B%0A(l%3Dfunction()%7BrequestAnimationFrame(l)%3Bh.style.textShadow%3D%220%200%201px%20%23000%2C%22%2B(g(10)-5)%2B%22px%20%22%2B(g(10)-5)%2B%22px%200%20%23888%2C0%200%20180px%20rgb(%22%2Bg(255)%2B%22%2C%22%2Bg(255)%2B%22%2C%22%2Bg(255)%2B%22)%22%7D)()%3B%0Ad.addEventListener('mousemove'%2Cfunction(v)%7Bc.style.marginTop%3D(v.pageY%2F10%2B15%7C0)%2B'px'%7D)  	src
115	src/com/google/javascript/jscomp/FunctionInjector.java内private CanInlineResult canInlineReferenceDirectly( Node callNode, Node fnNode)外src/com/google/javascript/jscomp/FunctionInjector.java内private CanInlineResult canInlineReferenceDirectly( Node callNode, Node fnNode)	2d6e1c78f41248fbbb1eec43b23e7430e2bc7885	4597738e8898f738c1f969fe90479728be81cc80	1101	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1101.json	Erroneous optimization in ADVANCED_OPTIMIZATIONS mode	What steps will reproduce the problem?   1. Create a file input.js with the following "minimal" test case:        window["anchor"] = function (obj, modifiesProp) {          return (function (saved) {              return modifiesProp(obj) + saved;          })(obj["prop"]);      }    2. Compile it with:        java -jar .../build/compiler.jar                    \          --compilation_level ADVANCED_OPTIMIZATIONS      \          --warning_level VERBOSE                         \          --externs window.js                             \          --js input.js                                   \          --js_output_file output.js    3. That's all!    What is the expected output?        window.foo=function(a,b){var HOLD=a.prop;return b(a)+HOLD};    What do you see instead?        window.foo=function(a,b){return b(a)+a.prop};    Note how this is semantically very different if modifiesProp/b (whose  semantics are unknown to the compiler) side-effects a.prop.    The evaluation order of + is well-defined in EcmaScript 5, but even  then, this happens even if one substitutes the , (comma) operator.    What version of the product are you using? On what operating system?   Git HEAD        commit 4a62ee4bca02169dd77a6f26ed64a624b3f05f95      Author: Chad Killingsworth <chadkillingsworth@missouristate.edu>      Date:   Wed Sep 25 14:52:28 2013 -0500                Add history.state to html5 externs    on Linux.	src
116	src/com/google/javascript/jscomp/FunctionInjector.java内private CanInlineResult canInlineReferenceDirectly( Node callNode, Node fnNode)外src/com/google/javascript/jscomp/FunctionInjector.java内private CanInlineResult canInlineReferenceDirectly( Node callNode, Node fnNode)	b9262dcd42d1b8f53c2a974c182feba2899dc74c	b80dfd3b0e5e4b490b7afb469320d18bac4520b4	1101	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1101.json	Erroneous optimization in ADVANCED_OPTIMIZATIONS mode	What steps will reproduce the problem?   1. Create a file input.js with the following "minimal" test case:        window["anchor"] = function (obj, modifiesProp) {          return (function (saved) {              return modifiesProp(obj) + saved;          })(obj["prop"]);      }    2. Compile it with:        java -jar .../build/compiler.jar                    \          --compilation_level ADVANCED_OPTIMIZATIONS      \          --warning_level VERBOSE                         \          --externs window.js                             \          --js input.js                                   \          --js_output_file output.js    3. That's all!    What is the expected output?        window.foo=function(a,b){var HOLD=a.prop;return b(a)+HOLD};    What do you see instead?        window.foo=function(a,b){return b(a)+a.prop};    Note how this is semantically very different if modifiesProp/b (whose  semantics are unknown to the compiler) side-effects a.prop.    The evaluation order of + is well-defined in EcmaScript 5, but even  then, this happens even if one substitutes the , (comma) operator.    What version of the product are you using? On what operating system?   Git HEAD        commit 4a62ee4bca02169dd77a6f26ed64a624b3f05f95      Author: Chad Killingsworth <chadkillingsworth@missouristate.edu>      Date:   Wed Sep 25 14:52:28 2013 -0500                Add history.state to html5 externs    on Linux.	src
117	src/com/google/javascript/jscomp/TypeValidator.java内private String formatFoundRequired(String description, JSType found, JSType required)外src/com/google/javascript/jscomp/TypeValidator.java内String getReadableJSTypeName(Node n, boolean dereference)	6c43134465d961e19098964c6be69bf48fe8e860	871bca1f36c5c06aa880ce21429da63a76f8f6e9	1047	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1047.json	Wrong type name reported on missing property error.	/**   * @constructor   */  function C2() {}    /**   * @constructor   */  function C3(c2) {    /**     * @type {C2}      * @private     */    this.c2_;      use(this.c2_.prop);  }    Produces:    Property prop never defined on C3.c2_    But should be:    Property prop never defined on C2    	src
118	src/com/google/javascript/jscomp/DisambiguateProperties.java内private void handleObjectLit(NodeTraversal t, Node n)	046e0b226e963bc584c2a6cd3c2b471777c5cc53	f17961ae4d3d7cf5ea291d82804239982d009ef7	1024	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1024.json	Prototype method incorrectly removed	// ==ClosureCompiler==  // @compilation_level ADVANCED_OPTIMIZATIONS  // @output_file_name default.js  // @formatting pretty_print  // ==/ClosureCompiler==    /** @const */  var foo = {};  foo.bar = {    'bar1': function() { console.log('bar1'); }  }    /** @constructor */  function foobar() {}  foobar.prototype = foo.bar;    foo.foobar = new foobar;    console.log(foo.foobar['bar1']);	src
119	src/com/google/javascript/jscomp/GlobalNamespace.java内public void collect(JSModule module, Scope scope, Node n)	3e0d176234636b3dfba0a3060b18488c6752ae8c	046e0b226e963bc584c2a6cd3c2b471777c5cc53	1070	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1070.json	catch(e) yields JSC_UNDEFINED_NAME warning when e is used in catch in advanced mode	What steps will reproduce the problem? 1. set closure for advanced compilation  2. compile this:  // ==ClosureCompiler==  // @compilation_level ADVANCED_OPTIMIZATIONS  // @output_file_name default.js  // ==/ClosureCompiler==    try {  var x = 5;  }  catch(e) {  var s = "FAIL" + e.name + ": "+ e.message;  }    What is the expected output? What do you see instead? I expect no warning or error for this.  Instead I see this:    JSC_UNREACHABLE_CODE: unreachable code at line 4 character 0  catch(e) {  ^  JSC_UNDEFINED_NAME: e is never defined at line 5 character 17  var s = "FAIL" + e.name + ": "+ e.message;                   ^  JSC_UNDEFINED_NAME: e is never defined at line 5 character 32  var s = "FAIL" + e.name + ": "+ e.message;                                  ^  In my case I'm especially complaining about the JSC_UNDEFINED_NAME warning...  Also it seems the unreachable complaint isn't right, but i'm not sure.    What version of the product are you using? On what operating system? I'm using this url: http://closure-compiler.appspot.com/home  using chrome browser on windows: Version 28.0.1500.95 m   ... but this is a server side error from what I see...    Please provide any additional information below.	src
120	src/com/google/javascript/jscomp/ReferenceCollectingCallback.java内boolean isAssignedOnceInLifetime()	9f890320310e8ecb8dd2b6dc043eb24d8b0a25c6	0123fd5303c85d0d26add64aa2e19fee33f73aaa	1053	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1053.json	Overzealous optimization confuses variables	The following code:     // ==ClosureCompiler==   // @compilation_level ADVANCED_OPTIMIZATIONS   // ==/ClosureCompiler==   var uid;   function reset() {    uid = Math.random();   }   function doStuff() {    reset();    var _uid = uid;      if (uid < 0.5) {     doStuff();    }      if (_uid !== uid) {     throw 'reset() was called';    }   }   doStuff();    ...gets optimized to:     var a;function b(){a=Math.random();0.5>a&&b();if(a!==a)throw"reset() was called";}b();    Notice how _uid gets optimized away and (uid!==_uid) becomes (a!==a) even though doStuff() might have been called and uid's value may have changed and become different from _uid.    As an aside, replacing the declaration with "var _uid = +uid;" fixes it, as does adding an extra "uid = _uid" after "var _uid = uid".	src
121	src/com/google/javascript/jscomp/InlineVariables.java内private void inlineNonConstants( Var v, ReferenceCollection referenceInfo, boolean maybeModifiedArguments)	1af41ab430be090a9a6177648b18c1ff9fb88c3f	2aee36e667526ff8b0b5e6dad66506acee920ea6	1053	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1053.json	Overzealous optimization confuses variables	The following code:     // ==ClosureCompiler==   // @compilation_level ADVANCED_OPTIMIZATIONS   // ==/ClosureCompiler==   var uid;   function reset() {    uid = Math.random();   }   function doStuff() {    reset();    var _uid = uid;      if (uid < 0.5) {     doStuff();    }      if (_uid !== uid) {     throw 'reset() was called';    }   }   doStuff();    ...gets optimized to:     var a;function b(){a=Math.random();0.5>a&&b();if(a!==a)throw"reset() was called";}b();    Notice how _uid gets optimized away and (uid!==_uid) becomes (a!==a) even though doStuff() might have been called and uid's value may have changed and become different from _uid.    As an aside, replacing the declaration with "var _uid = +uid;" fixes it, as does adding an extra "uid = _uid" after "var _uid = uid".	src
122	src/com/google/javascript/jscomp/parsing/IRFactory.java内private Node transformBlock(AstNode node)	f22a0e8b289e8ed26f04ea0d3af3612b6e15414a	a8a456b183c9600658bcb0c72091bae1a30a4fda	1037	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1037.json	Inconsistent handling of non-JSDoc comments	What steps will reproduce the problem? 1. 2. 3. What is the expected output? What do you see instead?   When given:        /* @preserve Foo License */      alert("foo");    It spits out:        stdin:1: WARNING - Parse error. Non-JSDoc comment has annotations. Did you mean to start it with '/**'?      /* @license Foo License */      ^            0 error(s), 1 warning(s)      alert("foo");    If I take the suggestion and change the opening of the comment to '/**', everything is great.  However, if I change it to '/*!', the warning goes away, but it doesn't preserve the comment either.    I expect it to print the above warning, or preserve the comment.  That it does neither when starting with "/*!" (and every other character I tried) is confusing.    What version of the product are you using? On what operating system?   Tested with my compilation of the "v20130603" tag:        Closure Compiler (http://code.google.com/closure/compiler)      Version: v20130603      Built on: 2013/07/07 15:04    And with the provided binary:        Closure Compiler (http://code.google.com/closure/compiler)      Version: v20130411-90-g4e19b4e      Built on: 2013/06/03 12:07    I'm on Parabola GNU/Linux-libre with Java:        java version "1.7.0_40"      OpenJDK Runtime Environment (IcedTea 2.4.0) (ArchLinux build 7.u40_2.4.0-1-i686)      OpenJDK Server VM (build 24.0-b40, mixed mode)    Please provide any additional information below. 	src
123	src/com/google/javascript/jscomp/CodeGenerator.java内void add(Node n, Context context)	60dac870c77b5de63d981f4be40106fe1c87b7d1	8d11b8cc7a6183222b61c9bd398fed5448c59109	1033	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1033.json	Generates code with invalid for/in left-hand assignment	What steps will reproduce the problem? 1. Compile this:    window.Foo = function(A, B, C, D) {    if ( A ) {                              if ( B ) {        C = 0;      } else {        C = 0 in D;      }      while ( C-- ) {}    }  }    What is the expected output? What do you see instead?   Expected: Something that doesn't have a syntax error, maybe    window.Foo=function(b,c,a,d){if(b)for(a=c?0:(0 in d);a--;);};    Actual:    window.Foo=function(b,c,a,d){if(b)for(a=c?0:0 in d;a--;);};    SyntaxError: Unexpected token ; (Chrome)  invalid for/in left-hand side (Firefox)      What version of the product are you using? On what operating system?   http://closure-compiler.appspot.com/home      Please provide any additional information below.   I noticed this while attempting to minify jquery	src
124	src/com/google/javascript/jscomp/ExploitAssigns.java内private boolean isSafeReplacement(Node node, Node replacement)	95ff0484a76d60d30145f4e3da4bf9b517029361	e7f4269d0289f4d47217207ec456219db8efe47c	1017	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1017.json	Different output from RestAPI and command line jar	When I compile using the jar file from the command line I get a result that is not correct. However, when I test it via the REST API or the Web UI I get a correct output. I've attached a file with the code that we are compiling.    What steps will reproduce the problem? 1. Compile the attached file with "java -jar compiler.jar --js test.js"  2. Compile the content of the attached file on http://closure-compiler.appspot.com/home  3. Compare the output, note how the following part is converted in the two cases:    "var foreignObject = gfx.parentNode.parentNode;  var parentContainer = foreignObject.parentNode.parentNode;"    What is the expected output? What do you see instead? The Web UI converts the lines into: if(b){if(a=b.parentNode.parentNode,b=a.parentNode.parentNode,null!==b)  The command line converts it into: var b=a=a.parentNode.parentNode;  The Web UI results in correct code, the other results in code that tries to do "c.appendChild(b)" with c = b (c=a=a.parentNode.parentNode)    What version of the product are you using? On what operating system? compiler.jar: v20130411-90-g4e19b4e  Mac OSX 10.8.3  Java: java 1.6.0_45    Please provide any additional information below. We are also using the compiler form within our java code, with the same result.  Web UI was called with:  // ==ClosureCompiler==  // @compilation_level SIMPLE_OPTIMIZATIONS  // @output_file_name default.js  // ==/ClosureCompiler==	src
125	src/com/google/javascript/jscomp/TypeCheck.java内private void visitNew(NodeTraversal t, Node n)	ddc1299802e88b9814250c369e3fe6f7ee07d4e5	8cef00180a5cf67d047919c89668a6405030dbab	1002	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1002.json	IllegalStateException at com.google.javascript.rhino.jstype.FunctionType.getInstanceType	> What steps will reproduce the problem?  1. Unpack attached test case.  2. Ensure make, wget, unzip, and java are on your PATH  3. make prep (or just set up the build manually, it's not complicated)  4. make crash    > What is the expected output? What do you see instead?  Expected output: either successful compilation, or a compilation error.  Actual output:   $ java \     -jar ./compiler.jar \     --js crash.js \     --warning_level=VERBOSE \     --compilation_level=SIMPLE_OPTIMIZATIONS  java.lang.RuntimeException: java.lang.IllegalStateException   at com.google.javascript.jscomp.Compiler.runInCompilerThread(Compiler.java:715)   at com.google.javascript.jscomp.Compiler.compile(Compiler.java:647)   at com.google.javascript.jscomp.Compiler.compile(Compiler.java:603)   at com.google.javascript.jscomp.AbstractCommandLineRunner.doRun(AbstractCommandLineRunner.java:783)   at com.google.javascript.jscomp.AbstractCommandLineRunner.run(AbstractCommandLineRunner.java:379)   at com.google.javascript.jscomp.CommandLineRunner.main(CommandLineRunner.java:972)  Caused by: java.lang.IllegalStateException   at com.google.common.base.Preconditions.checkState(Preconditions.java:133)   at com.google.javascript.rhino.jstype.FunctionType.getInstanceType(FunctionType.java:1071)   at com.google.javascript.jscomp.TypeCheck.visitNew(TypeCheck.java:1567)   at com.google.javascript.jscomp.TypeCheck.visit(TypeCheck.java:569)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:534)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:528)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:528)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:528)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:528)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:528)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:528)   at com.google.javascript.jscomp.NodeTraversal.traverseFunction(NodeTraversal.java:569)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:522)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:528)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:528)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:528)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:528)   at com.google.javascript.jscomp.NodeTraversal.traverseWithScope(NodeTraversal.java:353)   at com.google.javascript.jscomp.TypeCheck.check(TypeCheck.java:400)   at com.google.javascript.jscomp.TypeCheck.process(TypeCheck.java:371)   at com.google.javascript.jscomp.DefaultPassConfig$30$1.process(DefaultPassConfig.java:1237)   at com.google.javascript.jscomp.PhaseOptimizer$NamedPass.process(PhaseOptimizer.java:293)   at com.google.javascript.jscomp.PhaseOptimizer.process(PhaseOptimizer.java:237)   at com.google.javascript.jscomp.Compiler.check(Compiler.java:830)   at com.google.javascript.jscomp.Compiler.compileInternal(Compiler.java:742)   at com.google.javascript.jscomp.Compiler.access$000(Compiler.java:83)   at com.google.javascript.jscomp.Compiler$2.call(Compiler.java:650)   at com.google.javascript.jscomp.Compiler$2.call(Compiler.java:647)   at com.google.javascript.jscomp.Compiler$3.call(Compiler.java:677)   at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)   at java.util.concurrent.FutureTask.run(FutureTask.java:138)   at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:895)   at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:918)   at java.lang.Thread.run(Thread.java:680)  make: *** [crash] Error 254    > What version of the product are you using? On what operating system?  closure-compiler release 20130411.  I have also encountered this error on earlier versions of closure-compiler, but the above repro recipe uses 20130411.  I'm currently testing on OS X but this probably happens on other platforms too.    > Please provide any additional information below.    Here's the contents of crash.js (included in the attached archive):    -----begin snip-----  var test = {};    /**   * @interface   */  test.T = function() {};    /**   * @constructor   * @implements {test.T}   */  test.A = function() {};    /**   * @constructor   * @implements {test.T}   */  test.B = function() {};    /**   * @constructor   */  test.X = function() {      this.type = test.A;      this.t = this.f();  };    /**   * @return {test.T}   */  test.X.prototype.f = function() {      if (this.type === test.A) {          return new test.A();      } else if (this.type === test.B) {          return new test.B();      }  };  -----end snip-----  	src
126	src/com/google/javascript/jscomp/MinimizeExitPoints.java内void tryMinimizeExits(Node n, int exitType, String labelName)	211dc0161ae737f59cac22f30b048d56a059d14b	bd2803b6d9ab600906b262ae51cb3591160b5f3c	936	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-936.json	Break in finally block isn't optimized properly	b: try { throw("throw me") } finally { /* fake catcher */ ; break b }; console.log("ok then...")    ... gets optimized into ...      throw"throw me";    ... which is not the same.    The break in the finally block should prevent the exception from being passed on. The expected result is:       console.log("ok then...")    ECMA-262 says:    The production TryStatement : try Block Finally is evaluated as follows:    Let B be the result of evaluating Block.  Let F be the result of evaluating Finally.  If F.type is normal, return B.  Return F.    F.type in this case would be 'break' and not 'normal', so 'break' overrides the 'throw' of B    This is with the build available for download on Feb 28 2013.  	src
127	src/com/google/javascript/jscomp/UnreachableCodeElimination.java内private void tryRemoveUnconditionalBranching(Node n)	437a9e47d1a371f9e6724210b16d11d75366c3a0	211dc0161ae737f59cac22f30b048d56a059d14b	936	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-936.json	Break in finally block isn't optimized properly	b: try { throw("throw me") } finally { /* fake catcher */ ; break b }; console.log("ok then...")    ... gets optimized into ...      throw"throw me";    ... which is not the same.    The break in the finally block should prevent the exception from being passed on. The expected result is:       console.log("ok then...")    ECMA-262 says:    The production TryStatement : try Block Finally is evaluated as follows:    Let B be the result of evaluating Block.  Let F be the result of evaluating Finally.  If F.type is normal, return B.  Return F.    F.type in this case would be 'break' and not 'normal', so 'break' overrides the 'throw' of B    This is with the build available for download on Feb 28 2013.  	src
128	src/com/google/javascript/jscomp/CodeGenerator.java内private void unrollBinaryOperator( Node n, int op, String opStr, Context context, Context rhsContext, int leftPrecedence, int rightPrecedence)	79a8906570f44e5f519282bd32595985ed089aed	d82fb38b0121bf690cea58df293185c7e91ded9c	942	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-942.json	The compiler quotes the "0" keys in object literals	What steps will reproduce the problem? 1. Compile alert({0:0, 1:1});    What is the expected output?  alert({0:0, 1:1});    What do you see instead?  alert({"0":0, 1:1});    What version of the product are you using? On what operating system? Latest version on Goobuntu.  	src
129	src/com/google/javascript/jscomp/PrepareAst.java内private void annotateCalls(Node n)	4ff5d0b989360d785c63978faf8eed6284e030e1	79a8906570f44e5f519282bd32595985ed089aed	937	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-937.json	Casting a function before calling it produces bad code and breaks plugin code	1. Compile this code with ADVANCED_OPTIMIZATIONS:  console.log( /** @type {function(!string):!string} */ ((new window.ActiveXObject( 'ShockwaveFlash.ShockwaveFlash' ))['GetVariable'])( '$version' ) );    produces:    'use strict';console.log((0,(new window.ActiveXObject("ShockwaveFlash.ShockwaveFlash")).GetVariable)("$version"));    2. Compare with this code:  console.log( /** @type {!string} */ ((new window.ActiveXObject( 'ShockwaveFlash.ShockwaveFlash' ))['GetVariable']( '$version' )) )    produces:    'use strict';console.log((new window.ActiveXObject("ShockwaveFlash.ShockwaveFlash")).GetVariable("$version"));      Notice the (0,...) wrapping around the GetVariable function in the first example. This causes the call to fail in every browser (this code is IE-only but it's just for a minimal example). The second version produces a warning that the type of GetVariable could not be determined (I enabled type warnings), and it wouldn't be possible to define these in an externs file without making a horrible mess.    This applies to all cases where functions are cast, but only causes problems (other than bloat) with plugins like this. It seems to serve no purpose whatsoever, so I assume it is a bug.    Running on a mac, not sure what version but it reports Built on: 2013/02/12 17:00, so will have been downloaded about that time.	src
130	src/com/google/javascript/jscomp/CollapseProperties.java内private void inlineAliases(GlobalNamespace namespace)	8a37f1089f62deaebc29fe5c8a22f48d04a6c8b1	9fac3ccd2fa9e6137584f079db1a6f5962a65cf4	931	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-931.json	arguments is moved to another scope	Using ADVANCED_OPTIMIZATIONS with CompilerOptions.collapsePropertiesOnExternTypes = true a script I used broke, it was something like:    function () {    return function () {      var arg = arguments;      setTimeout(function() { alert(args); }, 0);    }  }    Unfortunately it was rewritten to:    function () {    return function () {      setTimeout(function() { alert(arguments); }, 0);    }  }    arguments should not be collapsed.	src
131	src/com/google/javascript/rhino/TokenStream.java内public static boolean isJSIdentifier(String s)	602dc3845e92d39a0701396666635ccc4a321599	7f6700e2b54af3af409f3e8851a0d98a72beef4b	921	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-921.json	unicode characters in property names result in invalid output	What steps will reproduce the problem? 1. use unicode characters in a property name for an object, like this:  var test={"a\u0004b":"c"};    2. compile    What is the expected output? What do you see instead? Because unicode characters are not allowed in property names without quotes, the output should be the same as the input. However, the compiler converts the string \u0004 to the respective unicode character, and the output is:   var test={ab:"c"}; // unicode character between a and b can not be displayed here    What version of the product are you using? On what operating system? newest current snapshot on multiple os (OSX/linux)    Please provide any additional information below.	src
132	src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java内private Node tryMinimizeIf(Node n)	f5a77bb416ab2223fda83de118da1007e5962498	5b9485903b5e7d926f49dc91b915a256df92591c	925	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-925.json	if statement	What steps will reproduce the problem? INPUT:  if( es[--esi][ es[esi+1] ] === 1)  {   es[esi] = 0;  }  else  {   es[esi] = 1;  }  OUTPUT:    es[esi] = 1 === es[--esi][es[esi + 1]] ? 0 : 1;    BUT MUST BE  es[--esi] = 1 === es[esi][es[esi + 1]] ? 0 : 1;    Im using latest version on windows  	src
133	src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java内private void skipEOLs()	c5e6df9c0f84de1eee287d530ef8721c05e9cf14	4fbbc47cb18f241b23dd2d4bf9c15d45b2473523	919	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-919.json	Exception when parsing erroneous jsdoc: /**@return {@code foo} bar   *    baz. */	The following causes an exception in JSDocInfoParser.    /**    * @return {@code foo} bar    *    baz. */  var x;        Fix to follow.	src
134	src/com/google/javascript/jscomp/AmbiguateProperties.java内public void process(Node externs, Node root)外src/com/google/javascript/jscomp/AmbiguateProperties.java内public boolean isIndependentOf(Property prop)外src/com/google/javascript/jscomp/AmbiguateProperties.java内public boolean isIndependentOf(Property prop)外src/com/google/javascript/jscomp/AmbiguateProperties.java内private JSType getJSType(Node n)外src/com/google/javascript/jscomp/AmbiguateProperties.java内private void addNonUnionType(JSType newType)外src/com/google/javascript/jscomp/TypedScopeCreator.java内private FunctionType findOverriddenFunction( ObjectType ownerType, String propName)	86860111110ec7a96d92fbefb6c3ae15e3575405	6d374c3ee4c9c2651ffb44048924e127fd2bf37c	86	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-86.json	@inheritDoc doesn't play well with interfaces	If I use interface inheritance with @inheritDoc, the compiler doesn't   know about the types used in the method signature.    Sample code:    /**   * Interface   * @interface   */  A = function() {};    /**   * @param {string} a   */  A.prototype.foo = function(a) {};    /**   * @constructor   * @implements {A}   */  B = function() {};    /**   * @inheritDoc   */  B.prototype.foo = function(a) {    alert(a.substring(0));   //  ERROR - could not determine the type of   this expression  };	src
135	src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java内private void replaceReferencesToThis(Node node, String name)外src/com/google/javascript/rhino/jstype/FunctionType.java内public boolean hasProperty(String name)外src/com/google/javascript/rhino/jstype/FunctionType.java内boolean defineProperty(String name, JSType type, boolean inferred, boolean inExterns)	37bc6d41f17d17a822bbcd9aed9f17649a3384fd	d1f25380b5d74c5303533491e36ae4b33a50e2da	59	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-59.json	Inheritance not detected when prototype directly assigned	Given the following input JS:  //--------------------------  /**  * @constructor  */  function SuperClass () {  }    SuperClass.prototype.CustomMethod = function() {  }    /**  * @constructor  * @extends {SuperClass}  */  function SubClass () {  }  SubClass.prototype = new SuperClass();    /**  * @override  */  SubClass.prototype.CustomMethod = function() {   this.myProperty = "value";  }    window['SubClassInstance'] = new SubClass();  //---------------------------------    When compiled with ADVANCED_OPTIMIZATIONS produces the warning:  JSC_UNKNOWN_OVERRIDE: property CustomMethod not defined on any superclass  of SubClass    This error has been reproduced in both the downloaded compiler and the  Compiler Service UI.    When the prototype assignment is wrapped in a function, it is correctly  detected. See below:  //---------------------------------  function inherit(Child, Parent) {      Child.prototype = new Parent();  }   inherit(SubClass, SuperClass);  //---------------------------------  	src
136	src/com/google/javascript/jscomp/RenameVars.java内public void visit(NodeTraversal t, Node n, Node parent)外src/com/google/javascript/jscomp/MethodCompilerPass.java内public void process(Node externs, Node root)	2131059de15ba858adf7646bfba5cbd04b661336	938f48a60c544f6b7bdb5d49006f654a51ca9a22	103	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-103.json	$super is replaced when it should not be replaced	What steps will reproduce the problem? 1. Have javascript using prototype's $super  2. Compile with advanced_optimizations  3. See that $super is replaced by for example $super$$4    What is the expected output? What do you see instead? $super should not be renamed as it is used by prototype.    What version of the product are you using? On what operating system? Latest from svn.    Please provide any additional information below. Personally I made a quick fix in MakeDeclaredNamesUnique.java line 79:  if (t.getCompiler().getCodingConvention().isExported(name)) { continue; }  This fixed it for me, but not sure if that's the right place or method to  solve this, as I am unfamiliar with the project.	src
137	src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java内noLeftCurtyIn1stLine:外src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java内noLeftCurtyIn1stLine:外src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java内private void findDeclaredNames(Node n, Node parent, Renamer renamer)外src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java内private static int indexOfSeparator(String name)外src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java内public Renamer forChildScope()外src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java内public void addDeclaredName(String name)外src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java内public boolean stripConstIfReplaced()外src/com/google/javascript/jscomp/Normalize.java内private void reportCodeChange(String changeDescription)外src/com/google/javascript/jscomp/Normalize.java内public void process(Node externs, Node root)外src/com/google/javascript/jscomp/NodeUtil.java内static boolean isSwitchCase(Node n)	e185090c145950cc1eaba599e9f64bc305dec4c7	da30f170f29e983f014fb029fe5779bfd5d3b04f	124	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-124.json	Invalid JSC_DETERMINISTIC_TEST	What steps will reproduce the problem?   1. Compile following code:    // ==ClosureCompiler==  // @output_file_name default.js  // @compilation_level ADVANCED_OPTIMIZATIONS  // ==/ClosureCompiler==    var t = null;    window.test = function()  {      if (t != null)      {         t = null;      }        t = 1;  };    What is the expected output? What do you see instead?   Code should be compiled without warnings, but I see   "JSC_DETERMINISTIC_TEST: condition always evaluates to false".	src
138	src/com/google/javascript/jscomp/ClosureReverseAbstractInterpreter.java内public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome)外src/com/google/javascript/jscomp/ClosureReverseAbstractInterpreter.java内public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome)外src/com/google/javascript/jscomp/TypeInference.java内private FlowScope traverseName(Node n, FlowScope scope)	da30f170f29e983f014fb029fe5779bfd5d3b04f	1f5edbcd2b5b09ec59151137e643d9ce75ef1055	124	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-124.json	Invalid JSC_DETERMINISTIC_TEST	What steps will reproduce the problem?   1. Compile following code:    // ==ClosureCompiler==  // @output_file_name default.js  // @compilation_level ADVANCED_OPTIMIZATIONS  // ==/ClosureCompiler==    var t = null;    window.test = function()  {      if (t != null)      {         t = null;      }        t = 1;  };    What is the expected output? What do you see instead?   Code should be compiled without warnings, but I see   "JSC_DETERMINISTIC_TEST: condition always evaluates to false".	src
139	src/com/google/javascript/jscomp/Normalize.java内public void visit(NodeTraversal t, Node n, Node parent)外src/com/google/javascript/jscomp/Normalize.java内public void visit(NodeTraversal t, Node n, Node parent)外src/com/google/javascript/jscomp/Normalize.java内public void visit(NodeTraversal t, Node n, Node parent)外src/com/google/javascript/jscomp/Normalize.java内public void onRedeclaration( Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber)	6f2539acd3c37bd7f0d031b43364f75a5cd6d5f7	b347ce3a71e23a4ab92dc0a6c07d43e2f497c953	33	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-33.json	Redefinition of a function in third party code can be miscompiled	What steps will reproduce the problem? 1. Run this code snippet and observe that it doesn't raise an error:    function assert(b) {if (!b) throw "error"}    assert(f() === 1)  var f = function() {return 2;}  assert(f() === 2)    function f() {return 1;}    2. Compile it as third_party:  3. Observe that the first definition of f has been changed from an assignment to a declaration, and that the code now raises an error.    What version of the product are you using? On what operating system? r8    Please provide any additional information below.   This bug is originally from a blog comment[1], I don't know if it has hit anyone in the wild yet.    1) http://webreflection.blogspot.com/2009/11/google-closure-im-not-impressed.html#1604178721861066706	src
140	src/com/google/javascript/jscomp/Compiler.java内public void init(JSSourceFile[] externs, JSModule[] modules, CompilerOptions options)外src/com/google/javascript/jscomp/Compiler.java内private void checkFirstModule(JSModule[] modules)外src/com/google/javascript/jscomp/Compiler.java内Node getNodeForCodeInsertion(JSModule module)	b347ce3a71e23a4ab92dc0a6c07d43e2f497c953	a70a7c599e53a7752cf4b9e6e82b4408c3c4c04b	126	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-126.json	Google Common Loader Extern	I needed this for one of my projects.    Chad Killingsworth	src
141	src/com/google/javascript/jscomp/PureFunctionIdentifier.java内String getDebugReport()外src/com/google/javascript/jscomp/PureFunctionIdentifier.java内String getDebugReport()外src/com/google/javascript/jscomp/NodeUtil.java内static boolean canBeSideEffected(Node n, Set<String> knownConstants)	8ff053c723ec20f5b8e1e9e87164bbd657f7d2ca	3ce4716848eb71b6e78a4545a2cc0c27e74a29b3	116	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-116.json	The side effects of function1||function2 are not calculated	What steps will reproduce the problem? 1. Compile (Math.sin||Math.cos)(0)    What is the expected output? What do you see instead? Empty output.    What version of the product are you using? On what operating system? The closure-compiler web service at r114.    Please provide any additional information below. As a result of this issue goog.now() is considered to have side effects.	src
142	src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java内private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option)外src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java内private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option)外src/com/google/javascript/jscomp/CoalesceVariableNames.java内public void enterScope(NodeTraversal t)	222eafd303155b3eac5cd244584b2cb3c4c11975	c25df7eca2462861bf42ad8b74215099c3f81ae6	58	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-58.json	Internet Explorer runtime error after compilation.	What steps will reproduce the problem? See attached HTML file in IE6+ (does not work in IE8 unless Compatibility View is turned *on* for   some reason).    What is the expected output? What do you see instead? Expected output is on the left-hand side of the page (it is generated by the raw source). Google   Closure's output is on the right-hand side of the page.    What version of the product are you using? On what operating system? I downloaded compiler-latest.zip today (Nov. 24, 2009, ~ 12:00 PM EST)    Please provide any additional information below. There is a variable called "threshold" which is used to generate an array of arrays in the attached   HTML file. If it is a small number, IE seems to pass arrays into the sort method (sorting an array   of arrays) by value like all other browsers do. But when threshold is large enough (on my   machine that happens around 250) IE starts passing the arrays in by value. Google Closure   compiler has changed my original source from making local copies to modifying the arguments   being passed into the sort comparator ... but as a result of this IE behavior the Closure compiled   code breaks.	src
143	src/com/google/javascript/jscomp/RemoveConstantExpressions.java内private void trySimplify(Node parent, Node node)外src/com/google/javascript/jscomp/AbstractCommandLineRunner.java内static void createDefineReplacements(List<String> definitions, CompilerOptions options)	45fd54a488cfbf27978fc4811a722f1fedb8ddaa	7eaa0d8eca2549742649af34671eaf3da83b5c08	139	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-139.json	@define does not support strings	$ java -jar compiler.jar --compilation_level ADVANCED_OPTIMIZATIONS --define='test.VERSION=1.0.0' --js_output_file   test-min.js --js test.js  java.lang.RuntimeException: --define flag syntax invalid: test.VERSION=1.0.0   at com.google.javascript.jscomp.AbstractCommandLineRunner.createDefineReplacements(Unknown Source)   at com.google.javascript.jscomp.AbstractCommandLineRunner.initOptionsFromFlags(Unknown Source)   at com.google.javascript.jscomp.CommandLineRunner.createOptions(Unknown Source)   at com.google.javascript.jscomp.AbstractCommandLineRunner.doRun(Unknown Source)   at com.google.javascript.jscomp.AbstractCommandLineRunner.run(Unknown Source)   at com.google.javascript.jscomp.CommandLineRunner.main(Unknown Source)    test.js:  /** @define {string} */  test.VERSION = "";      I have tried both of these:  --define='test.VERSION=1.0.0'  --define='test.VERSION="1.0.0"'    Both generate the same error.	src
144	src/com/google/javascript/rhino/jstype/FunctionBuilder.java内public FunctionBuilder withReturnType(JSType returnType)外src/com/google/javascript/jscomp/FunctionTypeBuilder.java内noLeftCurtyIn1stLine:外src/com/google/javascript/jscomp/FunctionTypeBuilder.java内FunctionTypeBuilder inferFromOverriddenFunction( FunctionType oldType, @Nullable Node paramsParent)外src/com/google/javascript/jscomp/FunctionTypeBuilder.java内methodPartNotInFile:Nullable JSDocInfo info) {外src/com/google/javascript/jscomp/FunctionTypeBuilder.java内FunctionType buildAndRegister()外src/com/google/javascript/rhino/jstype/FunctionType.java内private JSType supAndInfHelper(JSType that, boolean leastSuper)外src/com/google/javascript/jscomp/TypedScopeCreator.java内private FunctionType getFunctionType(String name, Node rValue, JSDocInfo info, @Nullable Node lvalueNode)外src/com/google/javascript/jscomp/TypedScopeCreator.java内private FunctionType getFunctionType(String name, Node rValue, JSDocInfo info, @Nullable Node lvalueNode)外src/com/google/javascript/jscomp/TypedScopeCreator.java内private FunctionType getFunctionType(String name, Node rValue, JSDocInfo info, @Nullable Node lvalueNode)	c9e89727dc8063d087d28e42629606f4fd74a6e5	465282f1ca28a208b06c47b55fd292d4631c55da	143	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-143.json	Auto-identify void functions	function f() {  }    alert(f());    should emit a warning	src
145	src/com/google/javascript/jscomp/CodeGenerator.java内private void addNonEmptyExpression( Node n, Context context, boolean allowNonBlockChild)	b1ffe42efdaaf0266b4ba10e05de124a885cf979	dff6e0114f19c20aeb63393d67aa0880ff5745b5	190	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-190.json	Bug with labeled loops and breaks	What steps will reproduce the problem? Try to compile this code with the closure compiler :   var i = 0;   lab1: do{       lab2: do{           i++;           if (1) {               break lab2;           } else {               break lab1;           }       } while(false);   } while(false);     console.log(i);     What is the expected output? What do you see instead? The generated code produced is :  var a=0;do b:do{a++;break b}while(0);while(0);console.log(a);     Which works on all browsers except IE (Looks like IE doesn't like   the missing brackets just after the first do instruction).    What version of the product are you using? On what operating system? I am using the version of Jun 16 (latest) on ubuntu 10    Please provide any additional information below. Strangely, this bug doesn't happen when I use PRETTY_PRINT formatting option.	src
146	src/com/google/javascript/rhino/jstype/JSType.java内public TypePair getTypesUnderInequality(JSType that)	8d53308bb1d34c16af002ce5fe46cf0ae6c38128	35d56dd1fadec0ed50797d222de4e05f78bbf1c9	172	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-172.json	bad type inference for != undefined	What steps will reproduce the problem?   // ==ClosureCompiler==  // @compilation_level ADVANCED_OPTIMIZATIONS  // @output_file_name default.js  // ==/ClosureCompiler==    /** @param {string} x */  function g(x) {}    /** @param {undefined} x */  function f(x) {    if (x != undefined) { g(x); }  }    What is the expected output? What do you see instead?   JSC_DETERMINISTIC_TEST: condition always evaluates to false  left : undefined  right: undefined at line 6 character 6  if (x != undefined) { g(x); }        ^  JSC_TYPE_MISMATCH: actual parameter 1 of g does not match formal parameter  found   : undefined  required: string at line 6 character 24  if (x != undefined) { g(x); }                          ^    the second warning is bogus.    	src
147	src/com/google/javascript/jscomp/RuntimeTypeCheck.java内private void visitFunction(NodeTraversal t, Node n)外src/com/google/javascript/jscomp/CheckGlobalThis.java内public boolean shouldTraverse(NodeTraversal t, Node n, Node parent)	91d0d35fba40aac9316db9e2f8aa94cd3a3b6c2e	82a9956c6337d2f5d4a94ebe624d64faa54d9182	182	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-182.json	Lost a JSC_USED_GLOBAL_THIS warning in 0616 release vs 0514	What steps will reproduce the problem? //------------------  // should warn "JSC_USED_GLOBAL_THIS: dangerous use of the global this object" in both methods  // none of these warns in 0616 release  var NS = {   read: function()   {    return this.foo; // does not warn in 0514 release   },     write: function()   {    this.foo = 123; // warns in 0514 release   }  };    // only the non-inline notation warns in 0616 release  NS.write2 = function()  {   this.foo = 123;  };    //-----------------------  What is the expected output? What do you see instead? Since the 0514 release warned in in the "write" case above I would expect the 0616 to also report this.     What version of the product are you using? On what operating system? As said above, 20100514 and 20100616 releases.    Please provide any additional information below. I understand that the status is that inline-notation isn't preferred, though I wouldn't expect a previous, correct, warning to disappear. (Since I reported issue #144 I'm also aware of the previous limitation in global this).	src
148	src/com/google/javascript/jscomp/SourceMap.java内noLeftCurtyIn1stLine:外src/com/google/javascript/jscomp/SourceMap.java内noLeftCurtyIn1stLine:外src/com/google/javascript/jscomp/SourceMap.java内noLeftCurtyIn1stLine:外src/com/google/javascript/jscomp/SourceMap.java内void appendTo(Appendable out)外src/com/google/javascript/jscomp/SourceMap.java内void addMapping(Node node, Position startPosition, Position endPosition)外src/com/google/javascript/jscomp/SourceMap.java内void addMapping(Node node, Position startPosition, Position endPosition)外src/com/google/javascript/jscomp/SourceMap.java内void reset()外src/com/google/javascript/jscomp/SourceMap.java内public void appendTo(Appendable out, String name)外src/com/google/javascript/jscomp/SourceMap.java内public void appendTo(Appendable out, String name)外src/com/google/javascript/jscomp/SourceMap.java内public void appendTo(Appendable out, String name)外src/com/google/javascript/jscomp/SourceMap.java内void appendLineMappings()外src/com/google/javascript/jscomp/SourceMap.java内void appendLineMappings()外src/com/google/javascript/jscomp/SourceMap.java内void appendLineMappings()外src/com/google/javascript/jscomp/SourceMap.java内void appendLineMappings()外src/com/google/javascript/jscomp/SourceMap.java内private boolean isOverlapped(Mapping m1, Mapping m2)外src/com/google/javascript/jscomp/PeepholeFoldConstants.java内private Node tryFoldTypeof(Node originalTypeofNode)	4d09ce45270187fa65a891e56081960a0ae449e5	f86b8929454da31fbc59cbf95293c7138e0b8200	196	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-196.json	CSS3 'writingMode' not recognised in advanced mode	element.style.writingMode was defined in CSS3 but later dropped. However it is supported by IE7 (possibly earlier). It's a useful way to achieve vertical text in IE.    Closure Compiler will change references of element.style.writingMode to element.style.a, breaking implementation.    I've attached a patch adding this to the IE css properties.    Cheers,  Jake.	src
149	src/com/google/javascript/jscomp/CompilerOptions.java内noLeftCurtyIn1stLine:外src/com/google/javascript/jscomp/CompilerOptions.java内public boolean isExternExportsEnabled()外src/com/google/javascript/jscomp/CommandLineRunner.java内protected CompilerOptions createOptions()外src/com/google/javascript/jscomp/AbstractCommandLineRunner.java内final protected void setRunOptions(CompilerOptions options)外src/com/google/javascript/jscomp/AbstractCommandLineRunner.java内protected int doRun()外src/com/google/javascript/jscomp/AbstractCommandLineRunner.java内private Charset getInputCharset()外src/com/google/javascript/jscomp/Compiler.java内private String toSource(Node n, SourceMap sourceMap)	52547e61d187e102f21e5545c24e8d232fefe92f	053636cbd1a8fb97e55b4f82bc4b5bee8beaf47e	205	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-205.json	Add option to turn off string escaping	What steps will reproduce the problem?   1. I'm having large files with strings (patterns for hyphenation, see http://code.google.com/p/hyphenator/) and no-ASCII-characters.  2. Minifying with closure compiler makes them bigger      ru.js (orig): 41'216 Bytes      ru.js (orig, gzip): 17'124 Bytes      ru.js (mini): 110'770 Bytes      ru.js (mini, gzip): 18'860 Bytes    What is the expected output?  I'd like to be able to turn OFF the string escaping mechanism.    Thanks	src
150	src/com/google/javascript/jscomp/TypedScopeCreator.java内void build()	07dd3707c1a61ff21de3f7a7f15585bbb5f70573	bf8fc4533884f914182f861576808e71c18410cc	61	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-61.json	Type checker misses annotations on functions defined within functions	What steps will reproduce the problem? 1. Compile the following code under --warning_level VERBOSE    var ns = {};    /** @param {string=} b */  ns.a = function(b) {}    function d() {      ns.a();      ns.a(123);  }    2. Observe that the type checker correctly emits one warning, as 123   doesn't match the type {string}    3. Now compile the code with ns.a defined within an anonymous function,   like so:    var ns = {};    (function() {      /** @param {string=} b */      ns.a = function(b) {}  })();    function d() {      ns.a();      ns.a(123);  }    4. Observe that a warning is emitted for calling ns.a with 0 parameters, and   not for the type error, as though the @param declaration were ignored.     What version of the product are you using? On what operating system? r15    Please provide any additional information below.   This sort of module pattern is common enough that it strikes me as worth   supporting.    One last note to make matters stranger: if the calling code isn't itself within   a function, no warnings are emitted at all:    var ns = {};    (function() {      /** @param {string=} b */      ns.a = function(b) {}  })();    ns.a();  ns.a(123);  	src
151	src/com/google/javascript/jscomp/CommandLineRunner.java内noLeftCurtyIn1stLine:外src/com/google/javascript/jscomp/CommandLineRunner.java内private void applyToOptions(CompilerOptions options)外src/com/google/javascript/jscomp/CommandLineRunner.java内private void initConfigFromFlags(String[] args, PrintStream err)	d00fc0c64dba6762b649f9690cd52c68b849e118	fe58a5d1750bab2c5d1d0ef16102c1000e761bd8	74	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-74.json	Add a --version option for the compiler.	What steps will reproduce the problem? 1. Run java -jar compiler.jar --version    What is the expected output? What do you see instead? Expected: A version statement.  Actual: An error that --version is not supported.    What version of the product are you using? On what operating system? See above. This is a compiler.jar I downloaded from this project (didn't   build it myself), file is dated 04/12/2009.  On Windows XP.    Please provide any additional information below. This information doesn't seem to be given anywhere, don't see it on --help   either.    This is an enhancement request, not a bug report.  	src
152	src/com/google/javascript/rhino/jstype/FunctionType.java内JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope)	08fc2551ca3c811a02407d593b6ae39d2439a88c	de491e70b971caca03f07531c2caf97b878cd1ff	268	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-268.json	resolveTypes: jstype.UnionType cannot be cast to jstype.ObjectType	What steps will reproduce the problem?   1. Compile a bunch of JavaScript files that I can't release with these options: ['--create_name_map_files', 'true', '--jscomp_warning', 'missingProperties', '--jscomp_warning', 'undefinedVars', '--jscomp_warning', 'checkTypes', '--warning_level', 'VERBOSE', '--summary_detail_level', '3', '--process_closure_primitives', 'true', '--jscomp_error', 'strictModuleDepCheck', '--jscomp_error', 'invalidCasts', '--logging_level', 'ALL', '--compilation_level', 'ADVANCED_OPTIMIZATIONS']    2. During this pass:            Oct 26, 2010 12:09:38 AM com.google.javascript.jscomp.PhaseOptimizer$NamedPass process          INFO: resolveTypes    , compilation terminates with:            java.lang.RuntimeException: java.lang.ClassCastException: com.google.javascript.rhino.jstype.UnionType cannot be cast to com.google.javascript.rhino.jstype.ObjectType                  at com.google.javascript.jscomp.Compiler.runInCompilerThread(Unknown Source)                  at com.google.javascript.jscomp.Compiler.compile(Unknown Source)                  at com.google.javascript.jscomp.Compiler.compile(Unknown Source)                  at com.google.javascript.jscomp.AbstractCommandLineRunner.doRun(Unknown Source)                  at com.google.javascript.jscomp.AbstractCommandLineRunner.run(Unknown Source)                  at com.google.javascript.jscomp.CommandLineRunner.main(Unknown Source)          Caused by: java.lang.ClassCastException: com.google.javascript.rhino.jstype.UnionType cannot be cast to com.google.javascript.rhino.jstype.ObjectType                  at com.google.javascript.rhino.jstype.FunctionType.resolveInternal(Unknown Source)                  at com.google.javascript.rhino.jstype.JSType.resolve(Unknown Source)                  at com.google.javascript.jscomp.TypedScopeCreator$DeferredSetType.resolve(Unknown Source)                  at com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.resolveTypes(Unknown Source)                  at com.google.javascript.jscomp.TypedScopeCreator.createScope(Unknown Source)                  at com.google.javascript.jscomp.MemoizedScopeCreator.createScope(Unknown Source)                  at com.google.javascript.jscomp.DefaultPassConfig$GlobalTypeResolver.process(Unknown Source)                  at com.google.javascript.jscomp.PhaseOptimizer$PassFactoryDelegate.processInternal(Unknown Source)                  at com.google.javascript.jscomp.PhaseOptimizer$NamedPass.process(Unknown Source)                  at com.google.javascript.jscomp.PhaseOptimizer.process(Unknown Source)                  at com.google.javascript.jscomp.Compiler.check(Unknown Source)                  at com.google.javascript.jscomp.Compiler.compileInternal(Unknown Source)                  at com.google.javascript.jscomp.Compiler.access$000(Unknown Source)                  at com.google.javascript.jscomp.Compiler$1.call(Unknown Source)                  at com.google.javascript.jscomp.Compiler$1.call(Unknown Source)                  at com.google.javascript.jscomp.Compiler$2.run(Unknown Source)                  at java.lang.Thread.run(Thread.java:662)      What version of the product are you using? On what operating system?   I'm using Closure Compiler r506.  The problem first appeared in r482.	src
153	src/com/google/javascript/jscomp/Normalize.java内private void removeDuplicateDeclarations(Node externs, Node root)外src/com/google/javascript/jscomp/Normalize.java内private void removeDuplicateDeclarations(Node externs, Node root)外src/com/google/javascript/jscomp/Normalize.java内public void onRedeclaration( Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber)外src/com/google/javascript/jscomp/Normalize.java内public void onRedeclaration( Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber)外src/com/google/javascript/jscomp/SyntacticScopeCreator.java内noLeftCurtyIn1stLine:外src/com/google/javascript/jscomp/SyntacticScopeCreator.java内private void scanRoot(Node n, Scope parent)外src/com/google/javascript/jscomp/SyntacticScopeCreator.java内private void scanRoot(Node n, Scope parent)外src/com/google/javascript/jscomp/SyntacticScopeCreator.java内private void scanVars(Node n, Node parent)外src/com/google/javascript/jscomp/SyntacticScopeCreator.java内private void scanVars(Node n, Node parent)外src/com/google/javascript/jscomp/SyntacticScopeCreator.java内private void scanVars(Node n, Node parent)外src/com/google/javascript/jscomp/SyntacticScopeCreator.java内private void scanVars(Node n, Node parent)外src/com/google/javascript/jscomp/SyntacticScopeCreator.java内void onRedeclaration( Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber)外src/com/google/javascript/jscomp/SyntacticScopeCreator.java内public void onRedeclaration( Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber)	ff1a3d71ca63efdfc79112b6212fd10bd9aecce8	86caf52b53f53d8b83e9c1092f4b15ddeb6ca5bb	290	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-290.json	Namespace definition in Prototype is broken	What steps will reproduce the problem? 1. Namespace definition in prototype.js (Prototype library) looks like:  if (!Node) var Node = { };  2. Compile with latest command line compiler (Version: 20100917 (revision 440) Built on: 2010/09/17 17:55), with default options  3. Open html which uses this script in IE8 - IE will show error message (something like "Node - definition is missing", I use localized version and cannot write exact english message).    What is the expected output?  Something like:  if(!Node)var Node={};    What do you see instead?  Node||(Node={});    What version of the product are you using? On what operating system? Command line compiler (Version: 20100917 (revision 440) Built on: 2010/09/17 17:55), with default options, OS Linux Mint 7.  	src
154	src/com/google/javascript/jscomp/TypeValidator.java内noLeftCurtyIn1stLine:外src/com/google/javascript/jscomp/TypeValidator.java内noLeftCurtyIn1stLine:外src/com/google/javascript/jscomp/TypeValidator.java内private void expectInterfaceProperty(NodeTraversal t, Node n, ObjectType instance, ObjectType implementedInterface, String prop)外src/com/google/javascript/jscomp/TypeCheck.java内noLeftCurtyIn1stLine:外src/com/google/javascript/jscomp/TypeCheck.java内noLeftCurtyIn1stLine:外src/com/google/javascript/jscomp/TypeCheck.java内private void checkDeclaredPropertyInheritance( NodeTraversal t, Node n, FunctionType ctorType, String propertyName, JSDocInfo info, JSType propertyType)	d8624db8004fc8ef596d4ccedff7f307f444ad30	09ed556367fbe81b3003881dfacad643939664c0	204	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-204.json	Add support for data members on interfaces	/**   * @interface   */  function I() {};    /** @type {string} */  I.prototype.foobar;    /**   * @constructor   * @implements {I}   */  function C() {    // No warning generated here.    this.foobar = 2;  };    /** @type {I} */  var test = new C();   alert(test.foobar);	src
155	src/com/google/javascript/jscomp/Scope.java内noLeftCurtyIn1stLine:外src/com/google/javascript/jscomp/Scope.java内public String toString()外src/com/google/javascript/jscomp/Scope.java内public Var getVar(String name)外src/com/google/javascript/jscomp/ReferenceCollectingCallback.java内public ReferenceCollection getReferenceCollection(Var v)外src/com/google/javascript/jscomp/InlineVariables.java内private void collectAliasCandidates(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap)外src/com/google/javascript/jscomp/InlineVariables.java内private void doInlinesForScope(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap)外src/com/google/javascript/jscomp/InlineVariables.java内private void inlineNonConstants( Var v, ReferenceCollection referenceInfo)	86a7d25f3cc1177f35dc6480260fb807912c03fa	ba0119710233a1be87c10c5e71424dc5922cc627	378	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-378.json	Overzealous arguments optimisation	Consider the following JavaScript code:    function d3_call(callback) {    var f = callback;    arguments[0] = this;    f.apply(this, arguments);    return this;  }    This is optimised to:    function d3_call(a){arguments[0]=this;a.apply(this,arguments);return this};    However, the use of a temporary variable `f` is necessary to avoid `arguments[0] = this` from overwriting the first argument.    In the above optimised code, `arguments[0] = this` causes `this` to be assigned to `a`.    Verified on latest SVN r878.    See also: https://github.com/mbostock/d3/issues/closed#issue/68	src
156	src/com/google/javascript/jscomp/CollapseProperties.java内private void collapseDeclarationOfNameAndDescendants(Name n, String alias)外src/com/google/javascript/jscomp/CollapseProperties.java内private void updateSimpleDeclaration(String alias, Name refName, Ref ref)外src/com/google/javascript/jscomp/CollapseProperties.java内private void updateObjLitOrFunctionDeclaration(Name n, String alias)外src/com/google/javascript/jscomp/CollapseProperties.java内private void updateObjLitOrFunctionDeclaration(Name n, String alias)外src/com/google/javascript/jscomp/CollapseProperties.java内private void updateObjLitOrFunctionDeclarationAtAssignNode( Name n, String alias)外src/com/google/javascript/jscomp/CollapseProperties.java内public void visit(NodeTraversal t, Node n, Node parent)外src/com/google/javascript/jscomp/CollapseProperties.java内private void updateObjLitOrFunctionDeclarationAtVarNode(Name n)	bae144ca994994d3ada90c9311286e9277f86288	f39bbdd39c9ec2136f0a58a677bd2fdae77075a2	389	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-389.json	Compiler crashes on assign statement	It is a large app (containing the entire Dojo Toolkit library). Code fragment that fails:    /** @constructor   *  @param {...Object} params   */  dojox.gfx.shape.Shape = function(params) {};  dojox.gfx.shape.Shape = dojo.declare("dojox.gfx.shape.Shape", null, /** @lends dojox.gfx.shape.Shape.prototype */ { .......      Error message:    java.lang.RuntimeException: java.lang.RuntimeException: INTERNAL COMPILER ERROR.  Please report this problem.  Unexpected variable dojox$gfx$shape$Shape    Node(NAME dojox$gfx$shape$Shape): release\src\dijit.js.uncompressed.js:15135:0  dojox.gfx.shape.Shape = dojo.declare("dojox.gfx.shape.Shape", null, /** @lends dojox.gfx.shape.Shape.prototype */ {    Parent(ASSIGN): release\src\dijit.js.uncompressed.js:15135:22  dojox.gfx.shape.Shape = dojo.declare("dojox.gfx.shape.Shape", null, /** @lends dojox.gfx.shape.Shape.prototype */ {     at com.google.javascript.jscomp.Compiler.runCallable(Unknown Source)   at com.google.javascript.jscomp.Compiler.runInCompilerThread(Unknown Source)   at com.google.javascript.jscomp.Compiler.compile(Unknown Source)   at com.google.javascript.jscomp.Compiler.compile(Unknown Source)   at com.google.javascript.jscomp.AbstractCommandLineRunner.doRun(Unknown Source)   at com.google.javascript.jscomp.AbstractCommandLineRunner.run(Unknown Source)   at com.google.javascript.jscomp.CommandLineRunner.main(Unknown Source)  Caused by: java.lang.RuntimeException: INTERNAL COMPILER ERROR.  Please report this problem.  Unexpected variable dojox$gfx$shape$Shape    Node(NAME dojox$gfx$shape$Shape): release\src\dijit.js.uncompressed.js:15135:0  dojox.gfx.shape.Shape = dojo.declare("dojox.gfx.shape.Shape", null, /** @lends dojox.gfx.shape.Shape.prototype */ {    Parent(ASSIGN): release\src\dijit.js.uncompressed.js:15135:22  dojox.gfx.shape.Shape = dojo.declare("dojox.gfx.shape.Shape", null, /** @lends dojox.gfx.shape.Shape.prototype */ {     at com.google.javascript.jscomp.VarCheck.visit(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseRoots(Unknown Source)   at com.google.javascript.jscomp.NodeTraversal.traverseRoots(Unknown Source)   at com.google.javascript.jscomp.VarCheck.process(Unknown Source)   at com.google.javascript.jscomp.PhaseOptimizer$PassFactoryDelegate.processInternal(Unknown Source)   at com.google.javascript.jscomp.PhaseOptimizer$NamedPass.process(Unknown Source)   at com.google.javascript.jscomp.PhaseOptimizer.process(Unknown Source)   at com.google.javascript.jscomp.Compiler.optimize(Unknown Source)   at com.google.javascript.jscomp.Compiler.compileInternal(Unknown Source)   at com.google.javascript.jscomp.Compiler.access$000(Unknown Source)   at com.google.javascript.jscomp.Compiler$1.call(Unknown Source)   at com.google.javascript.jscomp.Compiler$1.call(Unknown Source)   at com.google.javascript.jscomp.Compiler$2.run(Unknown Source)   at java.lang.Thread.run(Unknown Source)  Caused by: java.lang.IllegalStateException: Unexpected variable dojox$gfx$shape$Shape   ... 47 more  	src
157	src/com/google/javascript/jscomp/parsing/IRFactory.java内private Node transformNameAsString(Name node)外src/com/google/javascript/jscomp/parsing/IRFactory.java内private Node transformAsString(AstNode n)外src/com/google/javascript/jscomp/CodeGenerator.java内void add(Node n, Context context)外src/com/google/javascript/jscomp/CodeGenerator.java内void add(Node n, Context context)外src/com/google/javascript/jscomp/CodeGenerator.java内void add(Node n, Context context)外src/com/google/javascript/jscomp/RenamePrototypes.java内public void visit(NodeTraversal t, Node n, Node parent)外src/com/google/javascript/jscomp/RenamePrototypes.java内private void processPrototypeParent(Node n, CompilerInput input)	9f19220fbd022e8fbcee16d117564d5412e4ffa7	41acde3e8e5e8d37ade765b41d9fd29861f03e5e	347	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-347.json	Numbers and quoted property names reject for get and set properties.	- Use --language_in=ECMASCRIPT5.  - Note that these definitions cause parse errors:    var x = { get 'x'() { return 1 } };  var x = { get 1() { return 1 } };    ES5 allow these.  The Rhino parser needs to be updated.	src
158	src/com/google/javascript/jscomp/DiagnosticGroups.java内noLeftCurtyIn1stLine:外src/com/google/javascript/jscomp/DiagnosticGroups.java内protected DiagnosticGroup forName(String name)外src/com/google/javascript/jscomp/CommandLineRunner.java内noLeftCurtyIn1stLine:外src/com/google/javascript/jscomp/CommandLineRunner.java内noLeftCurtyIn1stLine:外src/com/google/javascript/jscomp/CommandLineRunner.java内noLeftCurtyIn1stLine:外src/com/google/javascript/jscomp/CommandLineRunner.java内public String getDefaultMetaVariable()外src/com/google/javascript/jscomp/CommandLineRunner.java内private void processFlagFile(PrintStream err)外src/com/google/javascript/jscomp/CommandLineRunner.java内private void initConfigFromFlags(String[] args, PrintStream err)外src/com/google/javascript/jscomp/CommandLineRunner.java内private void initConfigFromFlags(String[] args, PrintStream err)外src/com/google/javascript/jscomp/AbstractCommandLineRunner.java内final protected void setRunOptions(CompilerOptions options)外src/com/google/javascript/jscomp/AbstractCommandLineRunner.java内CommandLineConfig setSourceMapFormat(SourceMap.Format format)外src/com/google/javascript/jscomp/AbstractCommandLineRunner.java内CommandLineConfig setLanguageIn(String languageIn)	87ff82f73e843495a887ef08bc92a98b4c7c105c	fcccf543e85a214f0948d1ac5cab3fa05363e845	407	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-407.json	Order of jscomp_error, jscomp_warning, jscomp_off flags are not preserved	"off" always takes precedence over "warning", and "warning" always takes precedence over "error"    This should be changed so that the last arguments always has highest precedence.  	src
159	src/com/google/javascript/jscomp/InlineFunctions.java内private void findCalledFunctions( Node node, Set<String> changed)	303a90a0e1fea556eec005e8b0934e87045810a3	a4f32ed8acef2880288fe9559f8c60fba444bbe3	423	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-423.json	Closure Compiler failed to translate all instances of a function name	What steps will reproduce the problem? 1. Compile the attached jQuery Multicheck plugin using SIMPLE optimization.    What is the expected output? What do you see instead? You expect that the function preload_check_all() gets its name translated appropriately. In fact, the Closure Compiler breaks the code by changing the function declaration but NOT changing the call to the function on line 76.	src
160	src/com/google/javascript/jscomp/Compiler.java内public void initOptions(CompilerOptions options)外src/com/google/javascript/jscomp/Compiler.java内public void initOptions(CompilerOptions options)	d5dad765e6cbdf512f80a1331e08d3e54baea3fa	29312d9f6d01e6c1fce4da0a644881c83864549f	467	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-467.json	checkVars / undefinedVars diagnostics not working from command line	It seems that setting neither checkVars nor undefinedVars via the jscomp_warning command line argument does anything. The check(s) do work when "warning_level VERBOSE" is set though. Other diagnostic groups, such as globalThis, do work however.    Here's what I'm seeing on the console:    ---------------------    >java -jar compiler.jar --js test.js  foo={bar:function(){alert(this.baz)}};    >java -jar compiler.jar --js test.js --warning_level VERBOSE  test.js:2: WARNING - dangerous use of the global this object    test.js:1: ERROR - variable foo is undefined  foo = {};  ^    1 error(s), 1 warning(s)    >java -jar compiler.jar --js test.js --jscomp_warning globalThis  test.js:2: WARNING - dangerous use of the global this object    0 error(s), 1 warning(s)  foo={bar:function(){alert(this.baz)}};    >java -jar compiler.jar --js test.js --jscomp_warning checkVars  foo={bar:function(){alert(this.baz)}};    >java -jar compiler.jar --js test.js --jscomp_warning undefinedVars  foo={bar:function(){alert(this.baz)}};    ---------------------    My test.js file looks like this:    ---------------------    foo = {};  foo.bar = function() { alert(this.baz); };    ---------------------    Tested against r1123 which was committed 5/20/11.	src
161	src/com/google/javascript/jscomp/PeepholeFoldConstants.java内private Node tryFoldArrayAccess(Node n, Node left, Node right)	dffa868e080b54544e05b96c81dceef522439180	89441fcc27e2d7f36d7b2f3990bbc894235bb5b4	522	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-522.json	peephole constants folding pass is trying to fold [][11] as if it were a property lookup instead of a property assignment	What steps will reproduce the problem? 1.Try on line CC with Advance  2.On the following 2-line code  3. What is the expected output? What do you see instead? // ==ClosureCompiler==  // @output_file_name default.js  // @compilation_level ADVANCED_OPTIMIZATIONS  // ==/ClosureCompiler==      var Mdt=[];  Mdt[11] = ['22','19','19','16','21','18','16','20','17','17','21','17'];    The error:  JSC_INDEX_OUT_OF_BOUNDS_ERROR: Array index out of bounds: NUMBER 11.0  2 [sourcename: Input_0] : number at line 2 character 4      What version of the product are you using? On what operating system? The online version on 201.07.27	src
162	src/com/google/javascript/jscomp/ScopedAliases.java内public void enterScope(NodeTraversal t)外src/com/google/javascript/jscomp/ScopedAliases.java内private void report(NodeTraversal t, Node n, DiagnosticType error, String... arguments)外src/com/google/javascript/jscomp/ScopedAliases.java内public void visit(NodeTraversal t, Node n, Node parent)外src/com/google/javascript/jscomp/ScopedAliases.java内public void visit(NodeTraversal t, Node n, Node parent)外src/com/google/javascript/jscomp/ScopedAliases.java内public void visit(NodeTraversal t, Node n, Node parent)外src/com/google/javascript/jscomp/Scope.java内public boolean isDeclared(String name, boolean recurse)	6b825fb7dbe65d4523f2af9c850ed7e7f43862c2	3395eb68a19a8492196df62fb9e38c814de80f08	548	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-548.json	Type aliases cannot be used in type annotations before their definitions	What steps will reproduce the problem? 1. Compile the following with full warnings:    goog.provide('foo.Foo');  goog.provide('foo.Foo.Bar');    goog.scope(function() {    /**     * @param {Foo.Bar} bar     * @constructor     */    foo.Foo = function(bar) {      this.bar = bar;    };    var Foo = foo.Foo;      /** @type {Foo.Bar} */    Foo.prototype.bar = null;      /** @constructor */    Foo.Bar = function() {};  });      What is the expected output? What do you see instead? This should work, but instead I get an error:    ERROR - Bad type annotation. Unknown type Foo.Bar     * @param {Foo.Bar} bar                      ^    This can be worked around by writing explicitly foo.Foo.Bar, but this leads to strange inconsistencies in the code before vs. after the alias definition.      What version of the product are you using? On what operating system? r1346 in Linux    Please provide any additional information below. 	src
163	src/com/google/javascript/jscomp/CrossModuleMethodMotion.java内private void moveMethods(Collection<NameInfo> allNameInfo)外src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java内private NameInfo getNameInfoForName(String name, SymbolType type)外src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java内public void visit(NodeTraversal t, Node n, Node parent)外src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java内public void visit(NodeTraversal t, Node n, Node parent)外src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java内public void visit(NodeTraversal t, Node n, Node parent)外src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java内private void addSymbolUse(String name, JSModule module, SymbolType type)外src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java内private void addSymbolUse(String name, JSModule module, SymbolType type)外src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java内private boolean isPrototypePropertyAssign(Node assign)外src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java内private boolean isPrototypePropertyAssign(Node assign)外src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java内private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps)外src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java内private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps)外src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java内private void processPrototypeParent(NodeTraversal t, Node n)外src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java内private void processPrototypeParent(NodeTraversal t, Node n)外src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java内public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest)外src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java内public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest)外src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java内public Node getFunctionNode()外src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java内public JSModule getModule()外src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java内public JSModule getModule()	acc3c458096b1eb7bfc5d7371eafb30af5f7b66c	f5bcee992bf149fa39f9eafc870ea2046d5809b4	600	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-600.json	VarCheck Crash When Using Modules	java -jar \users\chad\workspace\closure-compiler\build\compiler.jar --compilation_level ADVANCED_OPTIMIZATIONS --formatting PRETTY_PRINT --debug --module jquery:1 --module core:1:jquery --module_output_path_prefix mod_ --js ..\..\dist\jquery.js --js core.js --externs ..\qunit_externs.js    java.lang.RuntimeException: java.lang.RuntimeException: INTERNAL COMPILER ERROR.  Please report this problem.  Unexpected variable jQuery$$2    Node(NAME jQuery$$2): core.js:100:12          equal( jQuery(" <div/> ").length, 1, "Make sure whitespace is trimmed." );    Parent(GETPROP): core.js:100:12          equal( jQuery(" <div/> ").length, 1, "Make sure whitespace is trimmed." );            at com.google.javascript.jscomp.Compiler.runCallable(Compiler.java:628)          at com.google.javascript.jscomp.Compiler.runInCompilerThread(Compiler.java:573)          at com.google.javascript.jscomp.Compiler.compile(Compiler.java:555)          at com.google.javascript.jscomp.Compiler.compileModules(Compiler.java:546)          at com.google.javascript.jscomp.AbstractCommandLineRunner.doRun(AbstractCommandLineRunner.java:709)          at com.google.javascript.jscomp.AbstractCommandLineRunner.run(AbstractCommandLineRunner.java:329)          at com.google.javascript.jscomp.CommandLineRunner.main(CommandLineRunner.java:825)  Caused by: java.lang.RuntimeException: INTERNAL COMPILER ERROR.  Please report this problem.  Unexpected variable jQuery$$2    Node(NAME jQuery$$2): core.js:100:12          equal( jQuery(" <div/> ").length, 1, "Make sure whitespace is trimmed." );    Parent(GETPROP): core.js:100:12          equal( jQuery(" <div/> ").length, 1, "Make sure whitespace is trimmed." );            at com.google.javascript.jscomp.VarCheck.visit(VarCheck.java:170)          at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:498)          at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:491)          at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:491)          at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:491)          at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:491)          at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:491)          at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:491)          at com.google.javascript.jscomp.NodeTraversal.traverseRoots(NodeTraversal.java:304)          at com.google.javascript.jscomp.NodeTraversal.traverseRoots(NodeTraversal.java:464)          at com.google.javascript.jscomp.VarCheck.process(VarCheck.java:108)          at com.google.javascript.jscomp.PhaseOptimizer$PassFactoryDelegate.processInternal(PhaseOptimizer.java:273)          at com.google.javascript.jscomp.PhaseOptimizer$NamedPass.process(PhaseOptimizer.java:250)          at com.google.javascript.jscomp.PhaseOptimizer.process(PhaseOptimizer.java:168)          at com.google.javascript.jscomp.Compiler.optimize(Compiler.java:1636)          at com.google.javascript.jscomp.Compiler.compileInternal(Compiler.java:663)          at com.google.javascript.jscomp.Compiler.access$1(Compiler.java:634)          at com.google.javascript.jscomp.Compiler$2.call(Compiler.java:558)          at com.google.javascript.jscomp.Compiler$2.call(Compiler.java:1)          at com.google.javascript.jscomp.Compiler$3.run(Compiler.java:600)          at java.lang.Thread.run(Unknown Source)  Caused by: java.lang.IllegalStateException: Unexpected variable jQuery$$2          ... 21 more	src
164	src/com/google/javascript/rhino/jstype/ArrowType.java内public boolean isSubtype(JSType other)外src/com/google/javascript/rhino/jstype/ArrowType.java内public boolean isSubtype(JSType other)	32f4884ca5aa648d48d988d8d7dada88212d6dbe	e414f154d5c4dae483f251ebeb2d9ef598aaa0f6	634	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-634.json	{function(number, string)} should not be assignable to {function(number)}	Consider the following snippet. I don't think the "second call" should compile. As a side note: it would be great if none of the compiled in some pseudo-strict compile mode.    /** @param {function(string,number):boolean} param */  function func(param) {}    /** @type {function(string,number,boolean):boolean} */  function paramFunc1() {}    /** @type {function(string):boolean} */  function paramFunc2() {}    // first call  func(paramFunc1);    // second call  func(paramFunc2);  	src
165	src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java内noLeftCurtyIn1stLine:外src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java内public RecordTypeBuilder(JSTypeRegistry registry)外src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java内public JSType build()外src/com/google/javascript/rhino/jstype/JSTypeRegistry.java内public boolean canPropertyBeDefined(JSType type, String propertyName)外src/com/google/javascript/rhino/jstype/RecordType.java内noLeftCurtyIn1stLine:外src/com/google/javascript/rhino/jstype/RecordType.java内noLeftCurtyIn1stLine:外src/com/google/javascript/rhino/jstype/RecordType.java内noLeftCurtyIn1stLine:外src/com/google/javascript/rhino/jstype/RecordType.java内noLeftCurtyIn1stLine:外src/com/google/javascript/rhino/jstype/RecordType.java内JSType getGreatestSubtypeHelper(JSType that)外src/com/google/javascript/rhino/jstype/ObjectType.java内public final boolean defineDeclaredProperty(String propertyName, JSType type, Node propertyNode)	2e904fcdc3bc09e3bff557fcfca383ba7e450095	61336bdc14f94b57ba58042f958c2a3227a55a3f	725	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-725.json	Properties defined on any record type applying to unrelated record types	Consider the following code:    /** @typedef {{name: string, id: number}} */  var RecordType1;    /**  * @param {RecordType1} rec  */  var func = function(rec) {    alert(rec.name2);  };  func({name: 'jim', id: 0});    Compiled with:   java -jar build/compiler.jar --compilation_level=ADVANCED_OPTIMIZATIONS --jscomp_error=accessControls --jscomp_error=checkTypes --jscomp_error=checkVars --js ~/Desktop/test.js    Properly errors:  /Users/dolapo/Desktop/test.js:9: ERROR - Property name2 never defined on rec    alert(rec.name2);      However, add another recordtype with name2 defined:    /** @typedef {{name: string, id: number}} */  var RecordType1;    /** @typedef {{name2: string}} */  var RecordType2;    /**  * @param {RecordType1} rec  */  var func = function(rec) {    alert(rec.name2);  };  func({name: 'jim', id: 0});        and this compiles with no errors.	src
166	src/com/google/javascript/rhino/jstype/PrototypeObjectType.java内public void matchConstraint(JSType constraint)	4f663a93dcdc8130cf92c3ad31ce8a8ac1fd0804	8d58355140bfdfbfc85c4629b90ed1d78225b520	785	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-785.json	anonymous object type inference inconsistency when used in union	Code:  /** @param {{prop: string, prop2: (string|undefined)}} record */  var func = function(record) {    window.console.log(record.prop);  }    /** @param {{prop: string, prop2: (string|undefined)}|string} record */  var func2 = function(record) {    if (typeof record == 'string') {      window.console.log(record);    } else {      window.console.log(record.prop);    }  }    func({prop: 'a'});  func2({prop: 'a'});          errors with:  ERROR - actual parameter 1 of func2 does not match formal parameter  found   : {prop: string}  required: (string|{prop: string, prop2: (string|undefined)})  func2({prop: 'a'});      the type of the record input to func and func2 are identical but the parameters to func2 allow some other type.	src
167	src/com/google/javascript/rhino/jstype/JSType.java内static JSType filterNoResolvedType(JSType type)外src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java内private FlowScope caseEquality(Node left, Node right, FlowScope blindScope, Function<TypePair, TypePair> merging)外src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java内private FlowScope caseAndOrNotShortCircuiting(Node left, Node right, FlowScope blindScope, boolean condition)外src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java内private FlowScope caseAndOrMaybeShortCircuiting(Node left, Node right, FlowScope blindScope, boolean condition)外src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java内private FlowScope maybeRestrictName( FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)外src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java内private FlowScope caseNameOrGetProp(Node name, FlowScope blindScope, boolean outcome)	d9b11f3334dcb04cd35abe5f7a5fbfb000fa0986	d58006a939b740ea78dc61128065a6fdb8f303ca	783	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-783.json	invalid property not erroring in for loop in prototype function	I think this example can be simplified to use a typedef instead of externs, but using an extern for the repro case.    Compile the attached with:  java -jar build/compiler.jar --formatting=PRETTY_PRINT --jscomp_error=checkTypes --jscomp_error=externsValidation --compilation_level=SIMPLE_OPTIMIZATIONS --externs=inloop-externs.js inloop.js (pasted below for completeness)    I would expect an error on the line in the for loop in the doIt function, but this compiles just fine. The commented out line above it properly errors, and if the same code is outside a prototype function, it errors. It does not error within the prototype function.    Thanks      /**   * @param {ns.Thing} thing   * @constructor   */  ns.MyClass = function(thing) {    /** @type {ns.Thing} */ this.thing_ = thing;  };    ns.MyClass.prototype.doIt = function() {    var subthing = this.thing_.subthing;    // ERRORS:    // window.console.log(subthing.noprop);      // NO ERROR:    for (var i = 0; i < subthing.noprop; i++) {      window.console.log(i);    }  };    var thing = /** @type {ns.Thing} */({subthing: {prop: 3}});    /*    ERRORS:    var subthing = thing.subthing;    for (var i = 0; i < subthing.noprop; i++) {      window.console.log(i);    } */    var c = new ns.MyClass(thing);  co.doIt();      	src
168	src/com/google/javascript/jscomp/TypedScopeCreator.java内private void declareArguments(Node functionNode)	d06ac163013a3779fcec7c2f544ba99d08f69f58	b675d1da9d5f8b36849db4943f580969105901a4	726	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-726.json	Wrong argument count error not reported on this aliasing (on function with @this annotation)	The following code (attached as test2-1.js) when compiled with:  java -jar build/compiler.jar --compilation_level=ADVANCED_OPTIMIZATIONS --jscomp_error=accessControls --jscomp_error=checkTypes --jscomp_error=checkVars --jscomp_error=uselessCode --jscomp_off=globalThis --js ~/Desktop/test2.js     correctly fails with:    /Users/dolapo/Desktop/test2.js:28: ERROR - Function Person.prototype.getName: called with 1 argument(s). Function requires at least 0 argument(s) and no more than 0 argument(s).    However, if the say function is modified such that this is aliased and the function is called within a setTimeout (test2-2.js), the error is not caught            test2-1.js:  var makeClass = function(protoMethods) {    var clazz = function() {      this.initialize.apply(this, arguments);    }    for (var i in protoMethods) {      clazz.prototype[i] = protoMethods[i];    }      return clazz;  }    /** @constructor */  var Person = function(name){};  Person = makeClass(/** @lends Person.prototype */ {    /** @this {Person} */    initialize: function(name) {      this.name = name;    },      /** @this {Person} */    getName: function() { return this.name; },      /**     * @param {string} message     * @this {Person}     */    say: function(message) {      window.console.log(this.getName(1) + ' says: ' + message);    }  });      var joe = new Person('joe');  joe.say('hi');  var jane = new Person('jane');  jane.say('hello');        test2-2.js:    var makeClass = function(protoMethods) {    var clazz = function() {      this.initialize.apply(this, arguments);    }    for (var i in protoMethods) {      clazz.prototype[i] = protoMethods[i];    }      return clazz;  }    /** @constructor */  var Person = function(name){};  Person = makeClass(/** @lends Person.prototype */ {    /** @this {Person} */    initialize: function(name) {      this.name = name;    },      /** @this {Person} */    getName: function() { return this.name; },      /**     * @param {string} message     * @this {Person}     */    say: function(message) {      // window.console.log(this.getName(1) + ' says: ' + message);      var self = this;      setTimeout(function() {        window.console.log(self.getName(1) + ' says: ' + message);      }, 500);     }  });      var joe = new Person('joe');  joe.say('hi');  var jane = new Person('jane');  jane.say('hello');	src
169	src/com/google/javascript/rhino/jstype/ArrowType.java内public boolean isSubtype(JSType other)外src/com/google/javascript/rhino/jstype/ArrowType.java内boolean hasEqualParameters(ArrowType that, boolean tolerateUnknowns)外src/com/google/javascript/rhino/jstype/ArrowType.java内boolean hasEqualParameters(ArrowType that, boolean tolerateUnknowns)外src/com/google/javascript/rhino/jstype/RecordType.java内boolean isSynthetic()外src/com/google/javascript/rhino/jstype/RecordType.java内boolean checkRecordEquivalenceHelper( RecordType otherRecord, boolean tolerateUnknowns)外src/com/google/javascript/rhino/jstype/RecordType.java内JSType getGreatestSubtypeHelper(JSType that)外src/com/google/javascript/rhino/jstype/RecordType.java内static boolean isSubtype(ObjectType typeA, RecordType typeB)外src/com/google/javascript/rhino/jstype/RecordType.java内static boolean isSubtype(ObjectType typeA, RecordType typeB)外src/com/google/javascript/rhino/jstype/FunctionType.java内FunctionType supAndInfHelper(FunctionType that, boolean leastSuper)外src/com/google/javascript/rhino/jstype/FunctionType.java内public ObjectType getTopMostDefiningType(String propertyName)外src/com/google/javascript/rhino/jstype/FunctionType.java内boolean checkFunctionEquivalenceHelper( FunctionType that, boolean tolerateUnknowns)外src/com/google/javascript/rhino/jstype/FunctionType.java内public int hashCode()外src/com/google/javascript/rhino/jstype/UnionType.java内JSType meet(JSType that)外src/com/google/javascript/rhino/jstype/JSType.java内public boolean isOrdinaryFunction()外src/com/google/javascript/rhino/jstype/JSType.java内public final boolean isEquivalentTo(JSType that)外src/com/google/javascript/rhino/jstype/JSType.java内public final boolean isInvariant(JSType that)外src/com/google/javascript/rhino/jstype/JSType.java内boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns)外src/com/google/javascript/rhino/jstype/JSType.java内boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns)外src/com/google/javascript/rhino/jstype/JSType.java内boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns)外src/com/google/javascript/rhino/jstype/JSType.java内boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns)外src/com/google/javascript/rhino/jstype/JSType.java内boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns)	b4c6a605c0aee776bf195c8d71fe2aeebb47665a	ac239c7c53aa4d6c3105f600dec8af69da530883	791	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-791.json	Strange "wrong parameter" warning for callback function	What steps will reproduce the problem? Compile the followed code:     /** @param {{func: function()}} obj */     function test1(obj) {};     var fnStruc1 = {};     fnStruc1.func = function() {};     test1(fnStruc1);     What is the expected output? What do you see instead? Expected: compiled OK  I see:  WARNING - actual parameter 1 of func does not match formal parameter  found   : {func: function (): undefined}  required: {func: function (): ?}  func(fnStruc);       ^    What version of the product are you using? On what operating system? r2102, Win7 x64    Please provide any additional information below. The followed code compiles OK:     /** @param {{func: function()}} obj */     function test2(obj) {};     var fnStruc2 = { func: function() {} };     test2(fnStruc2);    Discussion: https://groups.google.com/d/topic/closure-compiler-discuss/JuzERhGo48I/discussion	src
170	src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java内private void getNumUseInUseCfgNode(final Node cfgNode)	d5b7f2d9a109eefee69a6554eb4a899e60139101	49f54b28376a4ed5f72ec52d314020bd1f6cf3c6	965	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-965.json	Overly aggressive comma removal	When I compile the following code using simple optimizations,   function Test(n) {    var i = 0;    return typeof n !== "undefined" ? (i = n.length) : (n = "foo"), i  }  var dummy = "6chars";  console && console.log( Test(dummy) );    I get this:  function Test(a) {    return 0  }  var dummy = "6chars";  console && console.log(Test(dummy));    Which provides a different result than the original code.  	src
171	src/com/google/javascript/jscomp/TypeInference.java内private FlowScope traverseObjectLiteral(Node n, FlowScope scope)外src/com/google/javascript/jscomp/TypedScopeCreator.java内private boolean isQualifiedNameInferred( String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType)	d38ce5675419b30040bc44413e77e7317ed0c7f2	6d38965a1e0a3a61435b9bebc91ff1ba0a64013a	1023	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1023.json	Assigning object literals to obj.prototype in a immediately executed function not recognized.	/** @constructor */  function foo() {}  (function() {    foo.prototype = {      alert: function() {        alert("hello world");      }    };  })()  window.console.log(foo.prototype.alert); //undefined property warning  	src
172	src/com/google/javascript/jscomp/TypedScopeCreator.java内private boolean isQualifiedNameInferred( String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType)	a8a456b183c9600658bcb0c72091bae1a30a4fda	ce86cc8e460060e1280f365f22ccd5c375e2f5ed	1042	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1042.json	Type of prototype property incorrectly inferred to string	What steps will reproduce the problem? 1. Compile the following code:    /** @param {Object} a */  function f(a) {    a.prototype = '__proto';  }    /** @param {Object} a */  function g(a) {    a.prototype = function(){};  }    What is the expected output? What do you see instead?   Should type check. Instead, gives error:    WARNING - assignment to property prototype of Object  found   : function (): undefined  required: string    a.prototype = function(){};    ^  	src
173	src/com/google/javascript/jscomp/CodeGenerator.java内void add(Node n, Context context)外src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java内public Node optimizeSubtree(Node node)	ecd0a7791a772cfa27a6f7dc071b2bd711517b80	e96ce395944edfe9ba8e9de6b475cb64a7f8d626	1062	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1062.json	Operator precedence breaks with certain combinations of *, / and %.	What steps will reproduce the problem? 1. Try to compile this: x = a % b / b * c * 2; using either simple or advanced optimizations    What is the expected output? What do you see instead?   Expected: probably x=a%b/b*c*2;  Actual: x=2*a%b/b*c; (2 is incorrectly bumped to the beginning)      What version of the product are you using? On what operating system?   Happens on latest version and online. By the looks of things the change occurred somewhere between versions 20111003 and 20111114.      Please provide any additional information below.   As *, / and % all have the same operator precedence they should be left-to-right, but hoisting the 2 to the beginning means it's on the wrong side of the modulus operator.	src
174	src/com/google/javascript/jscomp/ScopedAliases.java内private void findAliases(NodeTraversal t)外src/com/google/javascript/jscomp/ScopedAliases.java内private void findAliases(NodeTraversal t)外src/com/google/javascript/jscomp/ScopedAliases.java内private void findAliases(NodeTraversal t)外src/com/google/javascript/jscomp/ScopedAliases.java内private void findAliases(NodeTraversal t)外src/com/google/javascript/jscomp/NodeUtil.java内public static Node newQualifiedNameNodeDeclaration( CodingConvention convention, String name, Node value, JSDocInfo info)外src/com/google/javascript/jscomp/JsAst.java内public void setSourceFile(SourceFile file)外src/com/google/javascript/jscomp/JsAst.java内private void parse(AbstractCompiler compiler)	095dd84b712332cd74dff3d1d2fc236aa93e7b78	d2b3ca66b6088c1c08437c120ae215d91d313b7c	1103	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1103.json	compiler crash on goog.scope locals	goog.provide("main");  goog.scope (function (){    var a = foo, b, c = 1;  });    Reported by Thomas Fischer    There are 2 separate issues here: that there's an error, and that the error make the compiler crash.	src
175	src/com/google/javascript/jscomp/FunctionInjector.java内noLeftCurtyIn1stLine:外src/com/google/javascript/jscomp/FunctionInjector.java内CanInlineResult canInlineReferenceToFunction(NodeTraversal t, Node callNode, Node fnNode, Set<String> needAliases, InliningMode mode, boolean referencesThis, boolean containsFunctions)外src/com/google/javascript/jscomp/FunctionInjector.java内public boolean apply(Node n)外src/com/google/javascript/jscomp/FunctionInjector.java内private CanInlineResult canInlineReferenceDirectly( Node callNode, Node fnNode)	94623ace4074dea70ffdde117a2d5e11c76de5fa	038da2119223818ee1c56eaf600a583f755f9b30	1101	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1101.json	Erroneous optimization in ADVANCED_OPTIMIZATIONS mode	What steps will reproduce the problem?   1. Create a file input.js with the following "minimal" test case:        window["anchor"] = function (obj, modifiesProp) {          return (function (saved) {              return modifiesProp(obj) + saved;          })(obj["prop"]);      }    2. Compile it with:        java -jar .../build/compiler.jar                    \          --compilation_level ADVANCED_OPTIMIZATIONS      \          --warning_level VERBOSE                         \          --externs window.js                             \          --js input.js                                   \          --js_output_file output.js    3. That's all!    What is the expected output?        window.foo=function(a,b){var HOLD=a.prop;return b(a)+HOLD};    What do you see instead?        window.foo=function(a,b){return b(a)+a.prop};    Note how this is semantically very different if modifiesProp/b (whose  semantics are unknown to the compiler) side-effects a.prop.    The evaluation order of + is well-defined in EcmaScript 5, but even  then, this happens even if one substitutes the , (comma) operator.    What version of the product are you using? On what operating system?   Git HEAD        commit 4a62ee4bca02169dd77a6f26ed64a624b3f05f95      Author: Chad Killingsworth <chadkillingsworth@missouristate.edu>      Date:   Wed Sep 25 14:52:28 2013 -0500                Add history.state to html5 externs    on Linux.	src
176	src/com/google/javascript/jscomp/TypeInference.java内private void updateScopeForTypeChange( FlowScope scope, Node left, JSType leftType, JSType resultType)外src/com/google/javascript/jscomp/TypeInference.java内private void updateScopeForTypeChange( FlowScope scope, Node left, JSType leftType, JSType resultType)外src/com/google/javascript/jscomp/TypeInference.java内private void updateScopeForTypeChange( FlowScope scope, Node left, JSType leftType, JSType resultType)	d6eebf3357f6f06b44cefbe55aabeab5bf25216e	aeed47f424d93d9ff82e0782fca53259829362b1	1056	https://storage.googleapis.com/google-code-archive/v2/code.google.com/closure-compiler/issues/issue-1056.json	initial type of variable wrong when initialize in a "var" statement with type declaration.	The following code doesn't give any warning even though it is an obvious bug:    -------------===============================---------  /**   * @constructor   */  function MyClass() {    this.value = 1;  }    MyClass.prototype.show = function() {    window.console.log(this.value)  }    /**   * @type {MyClass}   */  var x = null;  x.show();  -------------===============================---------    However, if you remove the @type from the var declaration, then closure realizes the problem and warns about x being null rather than an Object.    In any case, since x "can be null", closure should warn about a potential null pointer error, and suggest to guard against the null value, like it does if we try to pass x as an argument where a non-null type is expected. That could be an optional behavior protected behind a flag, but it would definitely help catch lots of errors and write safer code.    I am using the latest closure version available to date, on Ubuntu 13.04, on an amd64 machine.  	src