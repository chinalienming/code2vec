1	src/main/java/org/apache/commons/lang3/math/NumberUtils.java内methodPartNotInFile:public static Number createNumber(final String str) throws NumberFormatException	2c454a4ce3fe771098746879b166ede2284b94f4	687b2e62b7c6e81cd9d5c872b7fa9cc8fd3f1509	LANG-747	https://issues.apache.org/jira/browse/LANG-747	NumberUtils does not handle Long Hex numbers	NumberUtils.createLong() does not handle hex numbers, but createInteger() handles hex and octal. This seems odd. NumberUtils.createNumber() assumes that hex numbers can only be Integer. Again, why not handle bigger Hex numbers? == It is trivial to fix createLong() - just use Long.decode() instead of valueOf(). It's not clear why this was not done originally - the decode() method was added to both Integer and Long in Java 1.2. Fixing createNumber() is also fairly easy - if the hex string has more than 8 digits, use Long. Should we allow for leading zeros in an Integer?  If not, the length check is trivial.	src/main/java
2	src/main/java/org/apache/commons/lang3/LocaleUtils.java内public static Locale toLocale(final String str)	aefc12c38171e1a84a90dc26e51b2c7aa111fdee	09d39029b16dee61022dc8afde4d84f523f37813	LANG-879	https://issues.apache.org/jira/browse/LANG-879	LocaleUtils test fails with new Locale "ja_JP_JP_#u-ca-japanese" of JDK7	The Test below fails with the following error on JDK7, but succeeds on JDK6: testAllLocales "java.lang.AssertionError:  Expected: <ja_JP_JP_#u-ca-japanese>      but: was <ja_JP_JP_#u-ca-japanese>  at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:20)  at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:8)  at com.scispike.foundation.test.unit.i18n.LocaleStringConverterTest.testStringToLocale(LocaleStringConverterTest.java:20)  at com.scispike.foundation.test.unit.i18n.LocaleStringConverterTest.testAllLocales(LocaleStringConverterTest.java:28)  at org.apache.maven.surefire.testng.TestNGExecutor.run(TestNGExecutor.java:76)  at org.apache.maven.surefire.testng.TestNGDirectoryTestSuite.executeMulti(TestNGDirectoryTestSuite.java:161)  at org.apache.maven.surefire.testng.TestNGDirectoryTestSuite.execute(TestNGDirectoryTestSuite.java:101)  at org.apache.maven.surefire.testng.TestNGProvider.invoke(TestNGProvider.java:115)  at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)  at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)  at org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)  at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:103)  at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:74) ... Removed 25 stack frames  java.lang.AssertionError:  Expected: <ja_JP_JP_#u-ca-japanese>      but: was <ja_JP_JP_#u-ca-japanese>  at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:20)  at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:8)  at com.scispike.foundation.test.unit.i18n.LocaleStringConverterTest.testStringToLocale(LocaleStringConverterTest.java:20)  at com.scispike.foundation.test.unit.i18n.LocaleStringConverterTest.testAllLocales(LocaleStringConverterTest.java:28)  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)  at java.lang.reflect.Method.invoke(Method.java:601)  at org.testng.internal.MethodInvocationHelper.invokeMethod(MethodInvocationHelper.java:80)  at org.testng.internal.Invoker.invokeMethod(Invoker.java:715)  at org.testng.internal.Invoker.invokeTestMethod(Invoker.java:907)  at org.testng.internal.Invoker.invokeTestMethods(Invoker.java:1237)  at org.testng.internal.TestMethodWorker.invokeTestMethods(TestMethodWorker.java:127)  at org.testng.internal.TestMethodWorker.run(TestMethodWorker.java:111)  at org.testng.TestRunner.privateRun(TestRunner.java:767)  at org.testng.TestRunner.run(TestRunner.java:617)  at org.testng.SuiteRunner.runTest(SuiteRunner.java:334)  at org.testng.SuiteRunner.runSequentially(SuiteRunner.java:329)  at org.testng.SuiteRunner.privateRun(SuiteRunner.java:291)  at org.testng.SuiteRunner.run(SuiteRunner.java:240)  at org.testng.SuiteRunnerWorker.runSuite(SuiteRunnerWorker.java:51)  at org.testng.SuiteRunnerWorker.run(SuiteRunnerWorker.java:85)  at org.testng.TestNG.runSuitesSequentially(TestNG.java:1197)  at org.testng.TestNG.runSuitesLocally(TestNG.java:1122)  at org.testng.TestNG.run(TestNG.java:1030)  at org.apache.maven.surefire.testng.TestNGExecutor.run(TestNGExecutor.java:76)  at org.apache.maven.surefire.testng.TestNGDirectoryTestSuite.executeMulti(TestNGDirectoryTestSuite.java:161)  at org.apache.maven.surefire.testng.TestNGDirectoryTestSuite.execute(TestNGDirectoryTestSuite.java:101)  at org.apache.maven.surefire.testng.TestNGProvider.invoke(TestNGProvider.java:115)  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)  at java.lang.reflect.Method.invoke(Method.java:601)  at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)  at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)  at org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)  at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:103)  at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:74) " org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:20) org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:8) com.scispike.foundation.test.unit.i18n.LocaleStringConverterTest.testStringToLocale(LocaleStringConverterTest.java:20) com.scispike.foundation.test.unit.i18n.LocaleStringConverterTest.testAllLocales(LocaleStringConverterTest.java:28) sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) java.lang.reflect.Method.invoke(Method.java:601) org.testng.internal.MethodInvocationHelper.invokeMethod(MethodInvocationHelper.java:80) org.testng.internal.Invoker.invokeMethod(Invoker.java:715) org.testng.internal.Invoker.invokeTestMethod(Invoker.java:907) org.testng.internal.Invoker.invokeTestMethods(Invoker.java:1237) org.testng.internal.TestMethodWorker.invokeTestMethods(TestMethodWorker.java:127) org.testng.internal.TestMethodWorker.run(TestMethodWorker.java:111) org.testng.TestRunner.privateRun(TestRunner.java:767) org.testng.TestRunner.run(TestRunner.java:617) org.testng.SuiteRunner.runTest(SuiteRunner.java:334) org.testng.SuiteRunner.runSequentially(SuiteRunner.java:329) org.testng.SuiteRunner.privateRun(SuiteRunner.java:291) org.testng.SuiteRunner.run(SuiteRunner.java:240) org.testng.SuiteRunnerWorker.runSuite(SuiteRunnerWorker.java:51) org.testng.SuiteRunnerWorker.run(SuiteRunnerWorker.java:85) org.testng.TestNG.runSuitesSequentially(TestNG.java:1197) org.testng.TestNG.runSuitesLocally(TestNG.java:1122) org.testng.TestNG.run(TestNG.java:1030) org.apache.maven.surefire.testng.TestNGExecutor.run(TestNGExecutor.java:76) org.apache.maven.surefire.testng.TestNGDirectoryTestSuite.executeMulti(TestNGDirectoryTestSuite.java:161) org.apache.maven.surefire.testng.TestNGDirectoryTestSuite.execute(TestNGDirectoryTestSuite.java:101) org.apache.maven.surefire.testng.TestNGProvider.invoke(TestNGProvider.java:115) sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) java.lang.reflect.Method.invoke(Method.java:601) org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189) org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165) org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85) org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:103) org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:74) ========== Test import static org.hamcrest.MatcherAssert.assertThat; import static org.hamcrest.Matchers.equalTo; import java.util.Locale; import org.testng.annotations.Test; import com.scispike.foundation.i18n.StringToLocaleConverter; public class LocaleStringConverterTest {  StringToLocaleConverter converter = new StringToLocaleConverter();  public void testStringToLocale(Locale l)  {   String s = l.toString();    assertThat(converter.convert(s), equalTo(l));  }   @Test  public void testAllLocales() {   Locale[] locales = Locale.getAvailableLocales();   for (Locale l : locales)  {    testStringToLocale(l);   }  } } ========== StringToLocaleConverter import java.util.Locale; import org.apache.commons.lang3.LocaleUtils; import org.springframework.core.convert.converter.Converter; public class StringToLocaleConverter implements Converter<String, Locale> {  @Override  public Locale convert(String source) {   if (source == null)  {    return LocaleToStringConverter.DEFAULT;   }   return LocaleUtils.toLocale(source);  } }	src/main/java
3	src/main/java/org/apache/commons/lang3/math/NumberUtils.java内methodPartNotInFile:public static Number createNumber(final String str) throws NumberFormatException	1f001d06a2bde5ee4e3204ab38c4b1db8e95db0b	2c9c8753165dc7ce5dd1d5a6d741b445b33302c2	LANG-693	https://issues.apache.org/jira/browse/LANG-693	Method createNumber from NumberUtils doesn't work for floating point numbers other than Float	Method createNumber from NumberUtils is trying to parse a string with a floating point number always first as a Float, that will cause that if we send a string with a number that will need a Double or even a BigDecimal the number will be truncate to accommodate into the Float without an exception to be thrown, so in fact we will no be returning ever neither a Double nor a BigDecimal.	src/main/java
4	src/main/java/org/apache/commons/lang3/text/translate/LookupTranslator.java内noLeftCurtyIn1stLine:外src/main/java/org/apache/commons/lang3/text/translate/LookupTranslator.java内noLeftCurtyIn1stLine:外src/main/java/org/apache/commons/lang3/text/translate/LookupTranslator.java内methodPartNotInFile:public int translate(final CharSequence input, final int index, final Writer out	4ddbd99c5805781bd3c2287ab7920fecc23dab53	fb47b96ab635d7cc6e9edefdddc46f1baf63b117	LANG-882	https://issues.apache.org/jira/browse/LANG-882	LookupTranslator accepts CharSequence as input, but fails to work with implementations other than String	The core of org.apache.commons.lang3.text.translate is a HashMap<CharSequence, CharSequence> lookupMap. From the Javadoc of CharSequence (emphasis mine):  This interface does not refine the general contracts of the equals and hashCode methods. The result of comparing two objects that implement CharSequence is therefore, in general, undefined. Each object may be implemented by a different class, and there is no guarantee that each class will be capable of testing its instances for equality with those of the other. It is therefore inappropriate to use arbitrary CharSequence instances as elements in a set or as keys in a map. The current implementation causes code such as the following to not work as expected:  CharSequence cs1 = "1 < 2"; CharSequence cs2 = CharBuffer.wrap("1 < 2".toCharArray());  System.out.println(StringEscapeUtils.ESCAPE_HTML4.translate(cs1)); System.out.println(StringEscapeUtils.ESCAPE_HTML4.translate(cs2));   ... which gives the following results (but should be identical):  1 &lt; 2 1 < 2   The problem, at a minimum, is that CharBuffer.equals is even documented in the Javadoc that:  A char buffer is not equal to any other type of object. ... so a lookup on a CharBuffer in the Map will always fail when compared against the String implementations that it contains. An obvious work-around is to instead use something along the lines of either of the following:  System.out.println(StringEscapeUtils.ESCAPE_HTML4.translate(cs2.toString())); System.out.println(StringEscapeUtils.escapeHtml4(cs2.toString()));   ... which forces everything back to a String.  However, this is not practical when working with large sets of data, which would require significant heap allocations and garbage collection concerns.  (As such, I was actually trying to use the translate method that outputs to a Writer - but simplified the above examples to omit this.) Another option that I'm considering is to use a custom CharSequence wrapper around a char[] that implements hashCode() and equals() to work with those implemented on String.  (However, this will be interesting due to the symmetric assumption - which is further interesting that String.equals is currently implemented using instanceof - even though String is final...)	src/main/java
5	src/main/java/org/apache/commons/lang3/LocaleUtils.java内public static Locale toLocale(final String str)外src/main/java/org/apache/commons/lang3/LocaleUtils.java内public static Locale toLocale(final String str)	379151bad9c5402c335db67f9494351b99298732	75944e541d358d5b06ebbba3098a919fbf2539d4	LANG-865	https://issues.apache.org/jira/browse/LANG-865	LocaleUtils.toLocale does not parse strings starting with an underscore	Hi, Javadocs of Locale.toString() states that "If the language is missing, the string will begin with an underbar.". This is not handled in the LocaleUtils.toLocale method if it is meant to be the inversion method of Locale.toString(). The fix for the ticket 328 does not handle well the case "fr__P", which I found out during fixing the first bug. I am attaching the patch for both problems.	src/main/java
6	src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java内public final void translate(CharSequence input, Writer out)	6823c3742ee16f5b28e550a6afb685553befc0c2	cff0f1ae37bb2b7ab2dcdb10dec1f3cad7532e1c	LANG-857	https://issues.apache.org/jira/browse/LANG-857	StringIndexOutOfBoundsException in CharSequenceTranslator	I found that there is bad surrogate pair handling in the CharSequenceTranslator This is a simple test case for this problem. \uD83D\uDE30 is a surrogate pair.  @Test public void testEscapeSurrogatePairs() throws Exception {     assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30")); }   You'll get the exception as shown below.  java.lang.StringIndexOutOfBoundsException: String index out of range: 2  at java.lang.String.charAt(String.java:658)  at java.lang.Character.codePointAt(Character.java:4668)  at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:95)  at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:59)  at org.apache.commons.lang3.StringEscapeUtils.escapeCsv(StringEscapeUtils.java:556)   Patch attached, the method affected:  public final void translate(CharSequence input, Writer out) throws IOException  	src/main/java
7	src/main/java/org/apache/commons/lang3/math/NumberUtils.java内public static Number createNumber(String str)外src/main/java/org/apache/commons/lang3/math/NumberUtils.java内public static BigDecimal createBigDecimal(String str)	f0c7e60bbaf975b64ab5bf1b75ba6b7dbc256300	e71f6dd3f2f70c640ae73d28b432b3a69ffcab4b	LANG-822	https://issues.apache.org/jira/browse/LANG-822	NumberUtils#createNumber - bad behaviour for leading "--"	NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal. Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException. It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.	src/main/java
8	src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java内methodPartNotInFile:static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Local外src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java内methodPartNotInFile:static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Local外src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java内public int estimateLength()	8d192d7063cc747a3c6226122ea83c7348e199e7	a4a455053e7e4a77320efd6db0814f4de82d754d	LANG-818	https://issues.apache.org/jira/browse/LANG-818	FastDateFormat's "z" pattern does not respect timezone of Calendar instances passed to format()	The work on LANG-462 has introduced a time zone formatting bug in FastDateFormat in commons-lang3. The problem can be seen by this snippet:  // Always prints timezone name of machine's default timezone, ignoring TZ // set on calendar, even though the printed time itself respects calendar's TZ. Calendar myCal = Calendar.getInstance(TimeZone.getTimeZone("US/Central")); System.out.println(FastDateFormat.getInstance("h:mma z").format(myCal));   If you happen to be in US/Central, this will print the right thing, but just try it with US/Eastern, US/Pacific, etc.  It will print the time in the correct timezone, but the timezone name at the end (the "z" pattern) will always be the system default timezone.  This is a regression against commons-lang 2.x. Basically, when the "forced time zone" code was removed, the TimeZoneNameRule class stopped respecting the Calendar instance's timezone, and instead now always uses the mTimeZone of the FastDateFormat instance itself (which is only supposed to be used when formatting timezone-less objects such as Date or long). The removal of the forced time zone stuff is surely the right thing to do (it was a mess).  I think the fix is to change the TimeZoneNameRule inner class to not take a TimeZone instance, but rather to use the TimeZone on the Calendar instance passed into appendTo(), just like TimeZoneNumberRule does.  Presumably then for efficiency, one would use the getTimeZoneDisplay() package-static method to quickly retrieve the required timezone's display name.	src/main/java
9	src/main/java/org/apache/commons/lang3/time/FastDateParser.java内private void init()	afe5dff79fc23d222ba1f1481fbbf55e09d2e6da	c45d5bff75edfef6387d40e681f9dc7c9b517bbb	LANG-832	https://issues.apache.org/jira/browse/LANG-832	FastDateParser does not handle unterminated quotes correctly	FDP does not handled unterminated quotes the same way as SimpleDateFormat For example: Format: 'd'd' Date: d3 This should fail to parse the format and date but it actually works. The format is parsed as: Pattern: d(\p {IsNd} ++)	src/main/java
10	src/main/java/org/apache/commons/lang3/time/FastDateParser.java内public Date parse(String source, ParsePosition pos)	0afcd15e183205a85a45a2775f1fb75a162a1389	afe5dff79fc23d222ba1f1481fbbf55e09d2e6da	LANG-831	https://issues.apache.org/jira/browse/LANG-831	FastDateParser does not handle white-space properly	The SimpleDateFormat Javadoc does not treat white-space specially, however FastDateParser treats a single white-space as being any number of white-space characters. This means that FDP will parse dates that fail when parsed by SDP.	src/main/java
11	src/main/java/org/apache/commons/lang3/RandomStringUtils.java内methodPartNotInFile:public static String random(int count, int start, int end, boolean letters, bool	c9d786a4fe2639581047d878a64bab6fb24f1ab3	c821fafce06adefc040e8983fb12d49399a48627	LANG-807	https://issues.apache.org/jira/browse/LANG-807	RandomStringUtils throws confusing IAE when end <= start	RandomUtils invokes Random#nextInt where n = end - start. If end <= start, then Random throws: java.lang.IllegalArgumentException: n must be positive This is confusing, and does not identify the source of the problem.	src/main/java
12	src/main/java/org/apache/commons/lang3/RandomStringUtils.java内methodPartNotInFile:public static String random(int count, int start, int end, boolean letters, bool	9351ed93365de2d1c316b8f419566820e88839e3	c9d786a4fe2639581047d878a64bab6fb24f1ab3	LANG-805	https://issues.apache.org/jira/browse/LANG-805	RandomStringUtils.random(count, 0, 0, false, false, universe, random) always throws java.lang.ArrayIndexOutOfBoundsException	In commons-lang 2.6 line 250 :  ch = chars[random.nextInt(gap) + start];  This line of code takes a random int to fetch a char in the chars array regardless of its size. (Besides start is useless here) Fixed version would be :  //ch = chars[random.nextInt(gap)%chars.length];  When user pass 0 as end or when the array is not null but empty this line ends up with an exception	src/main/java
13	src/main/java/org/apache/commons/lang3/SerializationUtils.java内public static Object deserialize(byte[] objectData)外src/main/java/org/apache/commons/lang3/SerializationUtils.java内methodPartNotInFile:public ClassLoaderAwareObjectInputStream(InputStream in, ClassLoader classLoader外src/main/java/org/apache/commons/lang3/SerializationUtils.java内methodPartNotInFile:public ClassLoaderAwareObjectInputStream(InputStream in, ClassLoader classLoader	d0cf0fdd4ff2329f9584c4f663f1af177c1994f6	bd59a1908a1df3364918be7b07782500616b15ac	LANG-788	https://issues.apache.org/jira/browse/LANG-788	SerializationUtils throws ClassNotFoundException when cloning primitive classes	If a serializable object contains a reference to a primitive class, e.g. int.class or int[].class, the SerializationUtils throw a ClassNotFoundException when trying to clone that object.  import org.apache.commons.lang3.SerializationUtils; import org.junit.Test;   public class SerializationUtilsTest {     @Test  public void primitiveTypeClassSerialization(){   Class<?> primitiveType = int.class;      Class<?> clone = SerializationUtils.clone(primitiveType);   assertEquals(primitiveType, clone);  } }   The problem was already reported as a java bug http://bugs.sun.com/view_bug.do?bug_id=4171142 and ObjectInputStream is fixed since java version 1.4. The SerializationUtils problem arises because the SerializationUtils internally use the ClassLoaderAwareObjectInputStream that overrides the ObjectInputStream's resoleClass method without delegating to the super method in case of a ClassNotFoundException. I understand the intention of the ClassLoaderAwareObjectInputStream, but this implementation should also implement a fallback to the original implementation. For example:          protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {             String name = desc.getName();             try {                 return Class.forName(name, false, classLoader);             } catch (ClassNotFoundException ex) {              try {                   return Class.forName(name, false, Thread.currentThread().getContextClassLoader());              } catch (Exception e) {        return super.resolveClass(desc);   }             }         }   Here is the code in ObjectInputStream that fixed the java bug.      protected Class<?> resolveClass(ObjectStreamClass desc)  throws IOException, ClassNotFoundException     {  String name = desc.getName();  try {      return Class.forName(name, false, latestUserDefinedLoader());  } catch (ClassNotFoundException ex) {      Class cl = (Class) primClasses.get(name);      if (cl != null) {   return cl;      } else {   throw ex;      }  }     }  	src/main/java
14	src/main/java/org/apache/commons/lang3/StringUtils.java内public static boolean equals(CharSequence cs1, CharSequence cs2)	c8afaa3e869cc8c25577641553e0d0b5bdac78b5	cf7211f9d7d70d56501d8c4c827bf9ce3cac5f0b	LANG-786	https://issues.apache.org/jira/browse/LANG-786	StringUtils equals() relies on undefined behavior	Since the java.lang.CharSequence class was first introduced in 1.4, the JavaDoc block has contained the following note:  This interface does not refine the general contracts of the equals and hashCode methods. The result of comparing two objects that implement CharSequence is therefore, in general, undefined. Each object may be implemented by a different class, and there is no guarantee that each class will be capable of testing its instances for equality with those of the other. When the signature of the StringUtils equals() method was changed from equals(String, String) to equals(CharSequence, CharSequence) in R920543, the implementation still relied on calling CharSequence#equals(Object) even though, in general, the result is undefined. One example where equals(Object) returns false even though, as CharSequences, two objects represent equal sequences is when one object is an instance of javax.lang.model.element.Name and the other object is a String.	src/main/java
15	src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java内methodPartNotInFile:private static boolean isAssignable(Type type, ParameterizedType toParameterized外src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java内methodPartNotInFile:private static Type substituteTypeVariables(Type type, Map<TypeVariable<?>, Type	76912e0d8aed581ee4bc6b8635d0512ac2695f5d	8185a9e681d6de5f40b0ed07b40730c9761bad37	LANG-775	https://issues.apache.org/jira/browse/LANG-775	TypeUtils.getTypeArguments() misses type arguments for partially-assigned classes	failing test code to add to TypeUtilsTest.testGetTypeArguments():  typeVarAssigns = TypeUtils.getTypeArguments(Other.class, This.class); Assert.assertEquals(2, typeVarAssigns.size()); Assert.assertEquals(String.class, typeVarAssigns.get(This.class.getTypeParameters()[0])); Assert.assertEquals(Other.class.getTypeParameters()[0], typeVarAssigns.get(This.class.getTypeParameters()[1]));   These should pass based on:   public interface This<K, V> { }  public class Other<T> implements This<String, T> { }   This case fails because the current code ignores the Other class due to its specifying its own type variables, which is obviously incorrect.  This report is extrapolated from an offline report received by Hen.	src/main/java
16	src/main/java/org/apache/commons/lang3/math/NumberUtils.java内public static Number createNumber(String str)	a145b6d838914e38ee1027a1497de41140549080	13c7f19a5ad506340a7c8d8601ef4bf2426ab325	LANG-746	https://issues.apache.org/jira/browse/LANG-746	NumberUtils does not handle upper-case hex: 0X and -0X	NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException Integer.decode() handles both upper and lower case hex.	src/main/java
17	src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java内public final void translate(CharSequence input, Writer out)	a7e90b2ffa23ab60c7022e2f94a12651b4fb8ec0	b4255e6d071dc8d48bfc51037cecb29097b9a49d	LANG-720	https://issues.apache.org/jira/browse/LANG-720	StringEscapeUtils.escapeXml(input) outputs wrong results when an input contains characters in Supplementary Planes.	Hello. I use StringEscapeUtils.escapeXml(input) to escape special characters for XML. This method outputs wrong results when input contains characters in Supplementary Planes. String str1 = "\uD842\uDFB7" + "A"; String str2 = StringEscapeUtils.escapeXml(str1); // The value of str2 must be equal to the one of str1, // because str1 does not contain characters to be escaped. // However, str2 is diffrent from str1. System.out.println(URLEncoder.encode(str1, "UTF-16BE")); //%D8%42%DF%B7A System.out.println(URLEncoder.encode(str2, "UTF-16BE")); //%D8%42%DF%B7%FF%FD The cause of this problem is that the loop to translate input character by character is wrong. In CharSequenceTranslator.translate(CharSequence input, Writer out), loop counter "i" moves from 0 to Character.codePointCount(input, 0, input.length()), but it should move from 0 to input.length().	src/main/java
18	src/main/java/org/apache/commons/lang3/time/FastDateFormat.java内private void init()	aefe0749b2f2e63f9d13393694e7d20173bc032a	2aa9dca994b006ccbfcb528de5ff0da6a5578411	LANG-719	https://issues.apache.org/jira/browse/LANG-719	FastDateFormat formats year differently than SimpleDateFormat in Java 7	Starting with Java 7 does SimpleDateFormat format a year pattern of 'Y' or 'YYY' as '2003' instead of '03' as in former Java releases. According Javadoc this pattern should have been always been formatted as number, therefore the new behavior seems to be a bug fix in the JDK. FastDateFormat is adjusted to behave the same.	src/main/java
19	src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java内noLeftCurtyIn1stLine:外src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java内methodPartNotInFile:public int translate(CharSequence input, int index, Writer out) throws IOExcepti外src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java内methodPartNotInFile:public int translate(CharSequence input, int index, Writer out) throws IOExcepti	85481c8f87075c88a97e793d9a6fcfd8d3c6946f	0b3a8a3128890f710700d04e38df48b883d11d91	LANG-710	https://issues.apache.org/jira/browse/LANG-710	StringIndexOutOfBoundsException when calling unescapeHtml4("")	When calling unescapeHtml4() on the String "&#03" (or any String that contains these characters) an Exception is thrown: Exception in thread "main" java.lang.StringIndexOutOfBoundsException: String index out of range: 4  at java.lang.String.charAt(String.java:686)  at org.apache.commons.lang3.text.translate.NumericEntityUnescaper.translate(NumericEntityUnescaper.java:49)  at org.apache.commons.lang3.text.translate.AggregateTranslator.translate(AggregateTranslator.java:53)  at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:88)  at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:60)  at org.apache.commons.lang3.StringEscapeUtils.unescapeHtml4(StringEscapeUtils.java:351)	src/main/java
20	src/main/java/org/apache/commons/lang3/StringUtils.java内methodPartNotInFile:public static String join(Object[] array, char separator, int startIndex, int en外src/main/java/org/apache/commons/lang3/StringUtils.java内methodPartNotInFile:public static String join(Object[] array, String separator, int startIndex, int	0c01b4c48bc886a7e53b517efeb2192d1caaffe2	f08213cc4c35fd71e98aa5233fcb2db3333793a2	LANG-703	https://issues.apache.org/jira/browse/LANG-703	StringUtils.join throws NPE when toString returns null for one of objects in collection	Try    StringUtils.join(new Object[]{         new Object() {           @Override           public String toString() {             return null;           }         }     }, ',');   ToString should probably never return null, but it does in javax.mail.internet.InternetAddress	src/main/java
21	src/main/java/org/apache/commons/lang3/time/DateUtils.java内public static boolean isSameLocalTime(Calendar cal1, Calendar cal2)	a473984ef081ac1c55ce263345c5a54049275935	55f642725742513824975af0e5e91cb1920b6d72	LANG-677	https://issues.apache.org/jira/browse/LANG-677	DateUtils.isSameLocalTime does not work correct	Hi, I think I found a bug in the DateUtils class in the method isSameLocalTime. Example:  Calendar a = Calendar.getInstance(); a.setTimeInMillis(1297364400000L); Calendar b = Calendar.getInstance(); b.setTimeInMillis(1297321200000L); Assert.assertFalse(DateUtils.isSameLocalTime(a, b)); This is because the method compares  cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR)  but I think it has to be  cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) 	src/main/java
22	src/main/java/org/apache/commons/lang3/math/Fraction.java内public Fraction pow(int power)	1b708e343781255f50e17bf10b363cca303120af	0b2b82ad923b0455cde93286e3f504a1abd0863b	LANG-662	https://issues.apache.org/jira/browse/LANG-662	org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE, 2^k)	The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k, and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method. FractionTest.java  // additional test cases  public void testReducedFactory_int_int() {   // ...   f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2);   assertEquals(Integer.MIN_VALUE / 2, f.getNumerator());   assertEquals(1, f.getDenominator());   public void testReduce() {   // ...   f = Fraction.getFraction(Integer.MIN_VALUE, 2);   result = f.reduce();   assertEquals(Integer.MIN_VALUE / 2, result.getNumerator());   assertEquals(1, result.getDenominator());   	src/main/java
23	src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java内noLeftCurtyIn1stLine:外src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java内public void setFormatsByArgumentIndex(Format[] newFormats)	458597c6dcc23b01284930521f1cb80e986b442d	46356183872f2cba5e340993c6d85597a4f3cdbb	LANG-636	https://issues.apache.org/jira/browse/LANG-636	text.ExtendedMessageFormat doesn't override java.text.MessageFormat.equals(Object)	Findbugs: Bug: org.apache.commons.lang3.text.ExtendedMessageFormat doesn't override java.text.MessageFormat.equals(Object) Pattern id: EQ_DOESNT_OVERRIDE_EQUALS, type: Eq, category: STYLE This class extends a class that defines an equals method and adds fields, but doesn't define an equals method itself. Thus, equality on instances of this class will ignore the identity of the subclass and the added fields. Be sure this is what is intended, and that you don't need to override the equals method. Even if you don't need to override the equals method, consider overriding it anyway to document the fact that the equals method for the subclass just return the result of invoking super.equals(o). 	src/main/java
24	src/main/java/org/apache/commons/lang3/math/NumberUtils.java内public static boolean isNumber(String str)	d61f50a3986b983ba0bfc6d2ec2abc26892c6ed2	81903abbb25ff92597d5f1e3acc648d12bdee444	LANG-664	https://issues.apache.org/jira/browse/LANG-664	NumberUtils.isNumber(String)  is not right when the String is "1.1L"	"1.1L"  is not a Java Number . but NumberUtils.isNumber(String) return true. perhaps change:              if (chars[i] == 'l'                 || chars[i] == 'L') {                 // not allowing L with an exponent                 return foundDigit && !hasExp;             }   to:              if (chars[i] == 'l'                 || chars[i] == 'L') {                 // not allowing L with an exponent                 return foundDigit && !hasExp && !hasDecPoint;             }  	src/main/java
25	src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java内noLeftCurtyIn1stLine:	eb94e61a64105bcdd6afd0f6377de7b4fa7fa105	2bae68787d15c3d3540380164e62759485078ec1	LANG-658	https://issues.apache.org/jira/browse/LANG-658	Some Entitys like Ö are not matched properly against its ISO8859-1 representation	In EntityArrays  In  private static final String[][] ISO8859_1_ESCAPE  some matching is wrong, for example            {"\u00D7", "&Ouml;"}, // Ö - uppercase O, umlaut         {"\u00D8", "&times;"}, // multiplication sign   but this must be              {"\u00D6", "&Ouml;"}, // Ö - uppercase O, umlaut         {"\u00D7", "&times;"}, // multiplication sign   according to http://www.fileformat.info/info/unicode/block/latin_supplement/list.htm First look: u00CA is missing in the array and all following entries are matched wrong by an offset of 1. Found on http://stackoverflow.com/questions/4172784/bug-in-apache-commons-stringescapeutil/4172915#4172915	src/main/java
26	src/main/java/org/apache/commons/lang3/time/FastDateFormat.java内public String format(long millis)	e67792f82e7eaccb39007c0fa65f3217f24be10d	75d5b74a1a7ef68c5169f4b44cdf972c1ab07ee0	LANG-645	https://issues.apache.org/jira/browse/LANG-645	FastDateFormat.format() outputs incorrect week of year because locale isn't respected	FastDateFormat apparently doesn't respect the locale it was sent on creation when outputting week in year (e.g. "ww") in format(). It seems to use the settings of the system locale for firstDayOfWeek and minimalDaysInFirstWeek, which (depending on the year) may result in the incorrect week number being output. Here is a simple test program to demonstrate the problem by comparing with SimpleDateFormat, which gets the week number right:  import java.util.Calendar; import java.util.Date; import java.util.Locale; import java.text.SimpleDateFormat;  import org.apache.commons.lang.time.FastDateFormat;  public class FastDateFormatWeekBugDemo {     public static void main(String[] args) {         Locale.setDefault(new Locale("en", "US"));         Locale locale = new Locale("sv", "SE");          Calendar cal = Calendar.getInstance(); // setting locale here doesn't change outcome         cal.set(2010, 0, 1, 12, 0, 0);         Date d = cal.getTime();         System.out.println("Target date: " + d);          FastDateFormat fdf = FastDateFormat.getInstance("EEEE', week 'ww", locale);         SimpleDateFormat sdf = new SimpleDateFormat("EEEE', week 'ww", locale);         System.out.println("FastDateFormat:   " + fdf.format(d)); // will output "FastDateFormat:   fredag, week 01"         System.out.println("SimpleDateFormat: " + sdf.format(d)); // will output "SimpleDateFormat: fredag, week 53"     } }   If sv/SE is passed to Locale.setDefault() instead of en/US, both FastDateFormat and SimpleDateFormat output the correct week number.	src/main/java
27	src/main/java/org/apache/commons/lang3/math/NumberUtils.java内public static Number createNumber(String str)外src/main/java/org/apache/commons/lang3/math/NumberUtils.java内public static Number createNumber(String str)	7c915333685392f7cfc913b2085471709e6d6227	c2560c028173c3bc0a4627d4ce5ce221bcc9be66	LANG-638	https://issues.apache.org/jira/browse/LANG-638	NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in	NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in. One example of such a String is "1eE".	src/main/java
28	src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java内methodPartNotInFile:public int translate(CharSequence input, int index, Writer out) throws IOExcepti	8da5fb28a764eee26c76a5018c293f224017887b	3e1afecc200d7e3be9537c95b7cf52a7c5031300	LANG-617	https://issues.apache.org/jira/browse/LANG-617	StringEscapeUtils.escapeXML() can't process UTF-16 supplementary characters	Supplementary characters in UTF-16 are those whose code points are above 0xffff, that is, require more than 1 Java char to be encoded, as explained here: http://java.sun.com/developer/technicalArticles/Intl/Supplementary/ Currently, StringEscapeUtils.escapeXML() isn't aware of this coding scheme and treats each char as one character, which is not always right. A possible solution in class Entities would be:     public void escape(Writer writer, String str) throws IOException {         int len = str.length();         for (int i = 0; i < len; i++) {             int code = str.codePointAt;             String entityName = this.entityName(code);             if (entityName != null)  {                 writer.write('&');                 writer.write(entityName);                 writer.write(';');             }  else if (code > 0x7F)  {                     writer.write("&#");                     writer.write(code);                     writer.write(';');             }  else  {                     writer.write((char) code);             }              if (code > 0xffff)  {                     i++;             }         }     } Besides fixing escapeXML(), this will also affect HTML escaping functions. I guess that's a good thing, but please remember I have only tested escapeXML().	src/main/java
29	src/main/java/org/apache/commons/lang3/SystemUtils.java内static float toJavaVersionFloat(String version)	cbf8e4eb017a99af9a8f24eb8429e8a12b62af8b	982e295053663787bb0396b81a8956c3c87dc25b	LANG-624	https://issues.apache.org/jira/browse/LANG-624	SystemUtils.getJavaVersionAsFloat throws StringIndexOutOfBoundsException on Android runtime/Dalvik VM	Can be replicated in the Android emulator quite easily. Stack trace:   at org.apache.commons.lang.builder.ToStringBuilder.<clinit>(ToStringBuilder.java:98) E/AndroidRuntime( 1681):  ... 17 more E/AndroidRuntime( 1681): Caused by: java.lang.ExceptionInInitializerError E/AndroidRuntime( 1681):  at org.apache.commons.lang.builder.ToStringStyle$MultiLineToStringStyle.<init>(ToStringStyle.java:2276) E/AndroidRuntime( 1681):  at org.apache.commons.lang.builder.ToStringStyle.<clinit>(ToStringStyle.java:94) E/AndroidRuntime( 1681):  ... 18 more E/AndroidRuntime( 1681): Caused by: java.lang.StringIndexOutOfBoundsException E/AndroidRuntime( 1681):  at java.lang.String.substring(String.java:1571) E/AndroidRuntime( 1681):  at org.apache.commons.lang.SystemUtils.getJavaVersionAsFloat(SystemUtils.java:1153) E/AndroidRuntime( 1681):  at org.apache.commons.lang.SystemUtils.<clinit>(SystemUtils.java:818)  	src/main/java
30	src/main/java/org/apache/commons/lang3/StringUtils.java内public static int indexOfAny(CharSequence cs, char[] searchChars)外src/main/java/org/apache/commons/lang3/StringUtils.java内public static int indexOfAny(CharSequence cs, String searchChars)外src/main/java/org/apache/commons/lang3/StringUtils.java内public static boolean containsAny(CharSequence cs, char[] searchChars)外src/main/java/org/apache/commons/lang3/StringUtils.java内public static boolean containsAny(CharSequence cs, char[] searchChars)外src/main/java/org/apache/commons/lang3/StringUtils.java内public static int indexOfAnyBut(CharSequence cs, char[] searchChars)外src/main/java/org/apache/commons/lang3/StringUtils.java内public static int indexOfAnyBut(String str, String searchChars)外src/main/java/org/apache/commons/lang3/StringUtils.java内public static boolean containsNone(CharSequence cs, char[] searchChars)	24f6517c9d5c1293f0c1209b7b44b6eeaa6ebee2	19b6372018c6b800f8e2bf1b85e15ef4cbd500da	LANG-607	https://issues.apache.org/jira/browse/LANG-607	StringUtils methods do not handle Unicode 2.0+ supplementary characters correctly.	StringUtils.containsAny methods incorrectly matches Unicode 2.0+ supplementary characters. For example, define a test fixture to be the Unicode character U+20000 where U+20000 is written in Java source as "\uD840\uDC00"  private static final String CharU20000 = "\uD840\uDC00";  private static final String CharU20001 = "\uD840\uDC01"; You can see Unicode supplementary characters correctly implemented in the JRE call:  assertEquals(-1, CharU20000.indexOf(CharU20001)); But this is broken:  assertEquals(false, StringUtils.containsAny(CharU20000, CharU20001));  assertEquals(false, StringUtils.containsAny(CharU20001, CharU20000)); This is fine:  assertEquals(true, StringUtils.contains(CharU20000 + CharU20001, CharU20000));  assertEquals(true, StringUtils.contains(CharU20000 + CharU20001, CharU20001));  assertEquals(true, StringUtils.contains(CharU20000, CharU20000));  assertEquals(false, StringUtils.contains(CharU20000, CharU20001)); because the method calls the JRE to perform the match. More than you want to know:  http://java.sun.com/developer/technicalArticles/Intl/Supplementary/  	src/main/java
31	src/main/java/org/apache/commons/lang3/StringUtils.java内public static boolean containsAny(CharSequence cs, char[] searchChars)	0cc451d5e5cb565eb7311308466f487bc534ebaf	38bf7048571f3bc8dd34d14691906426444e4381	LANG-607	https://issues.apache.org/jira/browse/LANG-607	StringUtils methods do not handle Unicode 2.0+ supplementary characters correctly.	StringUtils.containsAny methods incorrectly matches Unicode 2.0+ supplementary characters. For example, define a test fixture to be the Unicode character U+20000 where U+20000 is written in Java source as "\uD840\uDC00"  private static final String CharU20000 = "\uD840\uDC00";  private static final String CharU20001 = "\uD840\uDC01"; You can see Unicode supplementary characters correctly implemented in the JRE call:  assertEquals(-1, CharU20000.indexOf(CharU20001)); But this is broken:  assertEquals(false, StringUtils.containsAny(CharU20000, CharU20001));  assertEquals(false, StringUtils.containsAny(CharU20001, CharU20000)); This is fine:  assertEquals(true, StringUtils.contains(CharU20000 + CharU20001, CharU20000));  assertEquals(true, StringUtils.contains(CharU20000 + CharU20001, CharU20001));  assertEquals(true, StringUtils.contains(CharU20000, CharU20000));  assertEquals(false, StringUtils.contains(CharU20000, CharU20001)); because the method calls the JRE to perform the match. More than you want to know:  http://java.sun.com/developer/technicalArticles/Intl/Supplementary/  	src/main/java
32	src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java内noLeftCurtyIn1stLine:外src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java内noLeftCurtyIn1stLine:外src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java内public static int reflectionHashCode(Object object, String[] excludeFields)外src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java内static void register(Object value)	1c606c3d96838e595a0664cbafdd60caae34aa0e	006fca88e86bd6f650d4d021d2ff3573a572827d	LANG-586	https://issues.apache.org/jira/browse/LANG-586	Use of ThreadLocals in ToStringStyle and HashCodeBuilder trigger memory leaks in container environments	The thread local in org.apache.commons.lang3.builder.ToStringStyle is created but never removed and no API is provided to remove it. If a webapp's use of LANG triggers the loading of this class, a reference chain will be created that will cause a memory leak on web application reload. See http://markmail.org/thread/uetw2fdrsqgbh2cv for more info.	src/main/java
33	src/main/java/org/apache/commons/lang3/ClassUtils.java内private static String toCanonicalName(String className)	575be16474e8e8246d4bbde6f243fdf38c34ad5b	0603aef594fa60126c2d45f2ab164eee39f7b44c	LANG-587	https://issues.apache.org/jira/browse/LANG-587	ClassUtils.toClass(Object[]) throws NPE on null array element	see summary	src/main/java
34	src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java内noLeftCurtyIn1stLine:外src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java内noLeftCurtyIn1stLine:	3f900a7395e31eaa72e0fa2fb43c090e5a8fa4ed	496525b0d626dd5049528cdef61d71681154b660	LANG-586	https://issues.apache.org/jira/browse/LANG-586	Use of ThreadLocals in ToStringStyle and HashCodeBuilder trigger memory leaks in container environments	The thread local in org.apache.commons.lang3.builder.ToStringStyle is created but never removed and no API is provided to remove it. If a webapp's use of LANG triggers the loading of this class, a reference chain will be created that will cause a memory leak on web application reload. See http://markmail.org/thread/uetw2fdrsqgbh2cv for more info.	src/main/java
35	src/main/java/org/apache/commons/lang3/ArrayUtils.java内public static boolean isEmpty(boolean[] array)外src/main/java/org/apache/commons/lang3/ArrayUtils.java内methodPartNotInFile:private static Object copyArrayGrow1(Object array, Class<?> newArrayComponentTyp	48bf241d4149919e0928e39616bee2e3783e2987	80bd78ea0685d28ddec9b8162d652db9dec949ce	LANG-571	https://issues.apache.org/jira/browse/LANG-571	ArrayUtils.add(T[] array, T element) can create unexpected ClassCastException	ArrayUtils.add(T[] array, T element) can create an unexpected ClassCastException. For example, the following code compiles without a warning:  String[] sa = ArrayUtils.add(stringArray, aString);   and works fine, provided at least one of the parameters is non-null. However, if both parameters are null, the add() method returns an Object[] array, hence the Exception. If both parameters are null, it's not possible to determine the correct array type to return, so it seems to me this should be disallowed. I think the method ought to be changed to throw IllegalParameterException when both parameters are null.	src/main/java
36	src/java/org/apache/commons/lang3/math/NumberUtils.java内public static Number createNumber(String str)外src/java/org/apache/commons/lang3/math/NumberUtils.java内public static boolean isNumber(String str)	ec0c4e5508dbd8af83253f7c50f8b728a1003388	da0612b348fcfa7679b92a5e9b8e1603e8e2da3a	LANG-521	https://issues.apache.org/jira/browse/LANG-521	NumberUtils.isNumber() Should Return True for Valid Number with a Trailing Decimal Place	NumberUtils.isNumber() should return true for a valid number ending in a trailing decimal place; e.g., "2." should be considered a number because new BigDecimal("2.") works fine.  This could be done by adding the code below after line 1444, which is the if (chars[i] == 'e' || chars[i] == 'E') block. if (chars[i] == '.') {     if (hasDecPoint || hasExp)  {         // two decimal points or dec in exponent            return false;     }     return foundDigit; // single trailing decimal point after non-exponent is ok }	src/java
37	src/java/org/apache/commons/lang3/ArrayUtils.java内public static boolean isEmpty(boolean[] array)	b5906d3f325ca3a1147d5fa68912975e2e6c347e	ea140fb5c327e2b58f6c5bf1057c7dede909a50c	LANG-567	https://issues.apache.org/jira/browse/LANG-567	ArrayUtils.addAll(T[] array1, T... array2) does not handle mixed types very well	ArrayUtils.addAll(T[] array1, T... array2) does not handle mixed array types very well. The stack trace for  Number[] st = ArrayUtils.addAll(new Integer[] {1} , new Long[] {2L} ); starts: java.lang.ArrayStoreException  at java.lang.System.arraycopy(Native Method)  at org.apache.commons.lang3.ArrayUtils.addAll(ArrayUtils.java:2962) which is not all that obvious. It would be a lot clearer if the method threw an IlegalArgumentException or similar.	src/java
38	src/java/org/apache/commons/lang3/time/FastDateFormat.java内public StringBuffer format(Date date, StringBuffer buf)	e28c95ac2ce95852add84bdf3d2d9c00ac98f5de	a95e76eefb91bdd9cf1c22734874a3d3c95ed327	LANG-538	https://issues.apache.org/jira/browse/LANG-538	DateFormatUtils.format does not correctly change Calendar TimeZone in certain situations	If a Calendar object is constructed in certain ways a call to Calendar.setTimeZone does not correctly change the Calendars fields.  Calling Calenar.getTime() seems to fix this problem.  While this is probably a bug in the JDK, it would be nice if DateFormatUtils was smart enough to detect/resolve this problem. For example, the following unit test fails:    public void testFormat_CalendarIsoMsZulu() {     final String dateTime = "2009-10-16T16:42:16.000Z";      // more commonly constructed with: cal = new GregorianCalendar(2009, 9, 16, 8, 42, 16)     // for the unit test to work in any time zone, constructing with GMT-8 rather than default locale time zone     GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8"));     cal.clear();     cal.set(2009, 9, 16, 8, 42, 16);       FastDateFormat format = FastDateFormat.getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT"));     assertEquals("dateTime", dateTime, format.format(cal));   }   However, this unit test passes:    public void testFormat_CalendarIsoMsZulu() {     final String dateTime = "2009-10-16T16:42:16.000Z";     GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8"));     cal.clear();     cal.set(2009, 9, 16, 8, 42, 16);     cal.getTime();      FastDateFormat format = FastDateFormat.getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT"));     assertEquals("dateTime", dateTime, format.format(cal));   }  	src/java
39	src/java/org/apache/commons/lang3/StringUtils.java内methodPartNotInFile:private static String replaceEach(String text, String[] searchList, String[] rep	0aa57f04ede369a4f813bbb86d3eac1ed20b084c	cb40e35f5e0990fad4c5278964fcc24e112dde8c	LANG-552	https://issues.apache.org/jira/browse/LANG-552	StringUtils replaceEach - Bug or Missing Documentation	The following Test Case for replaceEach fails with a null pointer exception. I have expected that all StringUtils methods are "null-friendly" The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null. I admit the use case is not perfect, because it is unclear what happens on the replace. I outlined three expectations in the test case, of course only one should be met. If it is decided that none of them should be possible, I propose to update the documentation with what happens when null is passed as replacement string  import static org.junit.Assert.assertEquals;  import org.apache.commons.lang.StringUtils; import org.junit.Test;   public class StringUtilsTest {   @Test  public void replaceEach(){   String original = "Hello World!";   String[] searchList = {"Hello", "World"};   String[] replacementList = {"Greetings", null};   String result = StringUtils.replaceEach(original, searchList, replacementList);   assertEquals("Greetings !", result);   //perhaps this is ok as well                 //assertEquals("Greetings World!", result);                 //or even   //assertEquals("Greetings null!", result);  }    }  	src/java
40	src/java/org/apache/commons/lang/StringUtils.java内public static boolean containsIgnoreCase(String str, String searchStr)	c72adf1b7592f302b8abefdb3b2f95782cc75aa2	8b1a8e178abb46cc048a3982636b8ec4e6ffc8dc	LANG-432	https://issues.apache.org/jira/browse/LANG-432	Fix case-insensitive string handling	String.to*Case() is locale-sensitive, this is usually not intended for case-insensitive comparisions. Please see Common Bug #3 for details.	src/java
41	src/java/org/apache/commons/lang/ClassUtils.java内public static String getShortClassName(String className)外src/java/org/apache/commons/lang/ClassUtils.java内public static String getShortClassName(String className)外src/java/org/apache/commons/lang/ClassUtils.java内public static String getPackageName(Class<?> cls)	ac58807ede6d9a0625b489cdca6fd37bad9cacfe	4d3629f310e84cc24c0e5f09d97f5126692d0128	LANG-535	https://issues.apache.org/jira/browse/LANG-535	ClassUtils.getShortClassName() will not work with an array;  it seems to add a semicolon to the end.	A semicolon is introduced into the class name at the end for all arrays... String sArray[] = new String[2]; sArray[0] = "mark"; sArray[1] = "is cool"; String simpleString = "chris"; assertEquals("String", ClassUtils.getShortClassName(simpleString, null)); assertEquals("String;", ClassUtils.getShortClassName(sArray, null));	src/java
42	src/java/org/apache/commons/lang/Entities.java内public String escape(String str)	68217617c54467c7c6098168e714a2fb6a48847d	dd2ae757d12554f290931f0b3c05e33ad993ecd1	LANG-480	https://issues.apache.org/jira/browse/LANG-480	StringEscapeUtils.escapeHtml incorrectly converts unicode characters above U+00FFFF into 2 characters	Characters that are represented as a 2 characters internaly by java are incorrectly converted by the function. The following test displays the problem quite nicely: import org.apache.commons.lang.*; public class J2 {     public static void main(String[] args) throws Exception {         // this is the utf8 representation of the character:         // COUNTING ROD UNIT DIGIT THREE         // in unicode         // codepoint: U+1D362         byte[] data = new byte[]  { (byte)0xF0, (byte)0x9D, (byte)0x8D, (byte)0xA2 } ;         //output is: &#55348;&#57186;         // should be: &#119650;         System.out.println("'" + StringEscapeUtils.escapeHtml(new String(data, "UTF8")) + "'");     } } Should be very quick to fix, feel free to drop me an email if you want a patch.	src/java
43	src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java内private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn)	ac2a39e92a71d5f9eb3ca7c6cc789b6341c582a4	eb3e2ae1f3734986a9f0225c661888baac3cb13b	LANG-477	https://issues.apache.org/jira/browse/LANG-477	ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes	When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur. Example that will cause error: ExtendedMessageFormatTest.java  private static Map<String, Object> formatRegistry = new HashMap<String, Object>();         static {         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());     }          public static void main(String[] args) {         ExtendedMessageFormat mf = new ExtendedMessageFormat("it''s a {dummy} 'test'!", formatRegistry);         String formattedPattern = mf.format(new String[] {"great"});         System.out.println(formattedPattern);     } }    The following change starting at line 421 on the 2.4 release seems to fix the problem: ExtendedMessageFormat.java CURRENT (Broken): if (escapingOn && c[start] == QUOTE) {         return appendTo == null ? null : appendTo.append(QUOTE); }  WORKING: if (escapingOn && c[start] == QUOTE) {         next(pos);         return appendTo == null ? null : appendTo.append(QUOTE); }  	src/java
44	src/java/org/apache/commons/lang/NumberUtils.java内public static Number createNumber(String val)	cf28c89dcf72d27573c478eb91e3b470de060edd	81f10d7f1ef52d44f43b38d81ac3dc1c83d45134	LANG-457	https://issues.apache.org/jira/browse/LANG-457	NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an "l" is passed in.	Seems to be similar to LANG-300, except that if you don't place a digit in front of the "l" or "L" it throws a StringIndexOutOfBoundsException instead.	src/java
45	src/java/org/apache/commons/lang/WordUtils.java内methodPartNotInFile:public static String abbreviate(String str, int lower, int upper, String appendT	cfff06bead88e2c1bb164285f89503a919e0e27f	d95fcd8e24568b4f9d3cb9da922a4029e293c793	LANG-419	https://issues.apache.org/jira/browse/LANG-419	WordUtils.abbreviate bug when lower is greater than str.length	In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower. But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too... Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException The fix is to adjust lower to the length of the string	src/java
46	src/java/org/apache/commons/lang/StringEscapeUtils.java内public StringEscapeUtils()外src/java/org/apache/commons/lang/StringEscapeUtils.java内public static String escapeJava(String str)外src/java/org/apache/commons/lang/StringEscapeUtils.java内public static void escapeJava(Writer out, String str)外src/java/org/apache/commons/lang/StringEscapeUtils.java内public static String escapeJavaScript(String str)外src/java/org/apache/commons/lang/StringEscapeUtils.java内public static void escapeJavaScript(Writer out, String str)外src/java/org/apache/commons/lang/StringEscapeUtils.java内methodPartNotInFile:private static String escapeJavaStyleString(String str, boolean escapeSingleQuot外src/java/org/apache/commons/lang/StringEscapeUtils.java内methodPartNotInFile:private static void escapeJavaStyleString(Writer out, String str, boolean escape	229151ec41339450e4d4f857bf92ed080d3e2430	916639bda234a8e5a030361c4068667764b34cb7	LANG-421	https://issues.apache.org/jira/browse/LANG-421	StringEscapeUtils.escapeJava(String) escapes '/' characters	Commons Lang 2.4 StringEscapeUtils.escapeJava(String) now escapes '/' characters, which is not a valid "escapable" character in Java strings.  I haven't tried the other Java escape/unescape methods to see if they have a similar problem, or that only Java "escapable" characters are escaped by escapeJava(String). This bug may have appeared as an unintended side-effect of the fix for LANG-363. Also the javadoc for escapeJava is now a little off, in that '/' should now be included in the sentence describing the differences between Java and Javascript strings, with respect to escaping rules. The following is a JUnit3 test demonstrating the bug. import junit.framework.TestCase; import org.apache.commons.lang.StringEscapeUtils; public class StringEscapeUtilsTest extends TestCase {     public void testEscapeJavaWithSlash()  {         final String input = "String with a slash (/) in it";                  final String expected = input;         final String actual   = StringEscapeUtils.escapeJava( input );          /**          * In 2.4 StringEscapeUtils.escapeJava(String) escapes '/' characters,          * which are not a valid character to escape in a Java string.            */         assertEquals( expected, actual );     } } 	src/java
47	src/java/org/apache/commons/lang/text/StrBuilder.java内public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar)外src/java/org/apache/commons/lang/text/StrBuilder.java内methodPartNotInFile:public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar)	19f33e4e0d824e732d07f06a08567c27b3c808f3	d5e343049c2610c31ddacb24f0d173942f6d5ac9	LANG-412	https://issues.apache.org/jira/browse/LANG-412	StrBuilder appendFixedWidth does not handle nulls	Appending a null value with fixed width causes a null pointer exception if getNullText() has not been set.	src/java
48	src/java/org/apache/commons/lang/builder/EqualsBuilder.java内public EqualsBuilder append(Object lhs, Object rhs)	3cea4b2af3f9caf6aa72fa56d647c513d320e073	eb8f74efb75e71fc91e515a38becc2aac203e339	LANG-393	https://issues.apache.org/jira/browse/LANG-393	EqualsBuilder don't compare BigDecimals correctly	When comparing a BigDecimal, the comparing is made using equals, not compareTo, which is more appropriate in the case of BigDecimal.  	src/java
49	src/java/org/apache/commons/lang/math/Fraction.java内public double doubleValue()	3905071819a14403d1cdb9437d2e005adf18fc70	0ac772a4e3b07287c435fdc3c812f67277c85cc8	LANG-380	https://issues.apache.org/jira/browse/LANG-380	infinite loop in Fraction.reduce when numerator == 0	Summary pretty much says it all.	src/java
50	src/java/org/apache/commons/lang/time/FastDateFormat.java内methodPartNotInFile:public static synchronized FastDateFormat getDateInstance(int style, TimeZone ti外src/java/org/apache/commons/lang/time/FastDateFormat.java内methodPartNotInFile:public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int	b2f1757bf9ec1632a940b9a2e65a1a022ba54af8	659ef247b1452b6d5b9f92271357381fa59fea50	LANG-368	https://issues.apache.org/jira/browse/LANG-368	FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change	The FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale. If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale. If the Locale is changed subsequently, then the wrong locale is applied. Patch for test case to follow.	src/java
51	src/java/org/apache/commons/lang/BooleanUtils.java内public static boolean toBoolean(String str)	3b46d611b2d595131ce0bce9bdb3209c55391be7	a5589b39e985e64861bd920aa7b13ab32c215b06	LANG-365	https://issues.apache.org/jira/browse/LANG-365	BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException	The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test: assertEquals(false, BooleanUtils.toBoolean("tru")); The end of case 3 should return false. Patch to follow for source and unit test.	src/java
52	src/java/org/apache/commons/lang/StringEscapeUtils.java内methodPartNotInFile:private static void escapeJavaStyleString(Writer out, String str, boolean escape	5209cefa81c9c48a34e5472fdcf2a308a4da2589	868f6976aea222e96259843f56df9aed8e48584b	LANG-363	https://issues.apache.org/jira/browse/LANG-363	StringEscapeUtils.escapeJavaScript() method did not escape '/' into '\/', it will make IE render page uncorrectly	If Javascripts including'/', IE will parse the scripts uncorrectly, actually '/' should be escaped to '\/'. For example, document.getElementById("test").value = '<script>alert(\'aaa\');</script>';this expression will make IE render page uncorrect, it should be document.getElementById("test").value = '<script>alert(\'aaa\');<\/script>'; Btw, Spring's JavascriptEscape behavor is correct. Try  to run below codes, you will find the difference:   String s = "<script>alert('aaa');</script>";   String str = org.springframework.web.util.JavaScriptUtils.javaScriptEscape(s);   System.out.println("Spring JS Escape : "+str);   str = org.apache.commons.lang.StringEscapeUtils.escapeJavaScript(s);   System.out.println("Apache Common Lang JS Escape : "+ str);	src/java
53	src/java/org/apache/commons/lang/time/DateUtils.java内private static void modify(Calendar val, int field, boolean round)	b6f7a8a8be57c9525c59e9f21e958e76cee0dbaf	d3b1163073c7aeb6011a5b65bfadad15bfc0f108	LANG-346	https://issues.apache.org/jira/browse/LANG-346	Dates.round() behaves incorrectly for minutes and seconds	Get unexpected output for rounding by minutes or seconds. public void testRound() {     Calendar testCalendar = Calendar.getInstance(TimeZone.getTimeZone("GMT"));     testCalendar.set(2007, 6, 2, 8, 9, 50);     Date date = testCalendar.getTime();     System.out.println("Before round() " + date);     System.out.println("After round()  " + DateUtils.round(date, Calendar.MINUTE)); } --2.1 produces Before round() Mon Jul 02 03:09:50 CDT 2007 After round()  Mon Jul 02 03:10:00 CDT 2007 – this is what I would expect --2.2 and 2.3 produces Before round() Mon Jul 02 03:09:50 CDT 2007 After round()  Mon Jul 02 03:01:00 CDT 2007 – this appears to be wrong	src/java
54	src/java/org/apache/commons/lang/LocaleUtils.java内public static Locale toLocale(String str)	5ccddb3ff7c65882ad6bbf95cbdac9debc76a871	e89e8d62b911340cc5b293465cdae909f3dfd640	LANG-328	https://issues.apache.org/jira/browse/LANG-328	LocaleUtils.toLocale() rejects strings with only language+variant	LocaleUtils.toLocale() throws an exception on strings containing a language and a variant but no country code. For example : fr__POSIX This string can be produced with the JDK by instanciating a Locale with an empty string for the country : new Locale("fr", "", "POSIX").toString(). According to the javadoc for the Locale class a variant is allowed with just a language code or just a country code. Commons Configuration handles this case in its PropertyConverter.toLocale() method. I'd like to replace our implementation by the one provided by LocaleUtils, but our tests fail due to this case.	src/java
55	src/java/org/apache/commons/lang/time/StopWatch.java内public void stop()	d8c22b8e1c8592bc8c6f6169a5b090082969acd4	3ef8a796b5ddf87e3e9afec9ba94aac62681b394	LANG-315	https://issues.apache.org/jira/browse/LANG-315	StopWatch: suspend() acts as split(), if followed by stop()	In my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:         StopWatch sw = new StopWatch();         sw.start();         Thread.sleep(1000);         sw.suspend();         // Time 1 (ok)         System.out.println(sw.getTime());         Thread.sleep(2000);         // Time 1 (again, ok)         System.out.println(sw.getTime());         sw.resume();         Thread.sleep(3000);         sw.suspend();         // Time 2 (ok)         System.out.println(sw.getTime());         Thread.sleep(4000);         // Time 2 (again, ok)         System.out.println(sw.getTime());         Thread.sleep(5000);         sw.stop();         // Time 2 (should be, but is Time 3 => NOT ok)         System.out.println(sw.getTime()); suspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?	src/java
56	src/java/org/apache/commons/lang/time/FastDateFormat.java内noLeftCurtyIn1stLine:外src/java/org/apache/commons/lang/time/FastDateFormat.java内public String toString()	7d1b54b33b07a570060824a703222a77c35b1fa0	672e3a8ead2970181c32cf5fc70a3ea3d020c1fc	LANG-303	https://issues.apache.org/jira/browse/LANG-303	FastDateFormat.mRules is not transient or serializable	Reported by FindBugs. Either we need to make the Rule interface Serializable, or make mRules transient and add deserializing code to kick off init().	src/java
57	src/java/org/apache/commons/lang/LocaleUtils.java内public static Set availableLocaleSet()	c71373047dc2172b0f06cebf61da284323d6ff99	bbd990b81fd7f8ab9dde75c8070b973b9ce500fc	LANG-304	https://issues.apache.org/jira/browse/LANG-304	NullPointerException in isAvailableLocale(Locale)	FindBugs pointed out:    UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet cAvailableSet is used directly once in the source - and if availableLocaleSet() hasn't been called it will cause a NullPointerException.	src/java
58	src/java/org/apache/commons/lang/math/NumberUtils.java内public static Number createNumber(String str)	8185a5f63e23be852d600a80daa5b848fa836a65	1fd45a4f68ea497dfbdf1a67b8b8805a4a9b1166	LANG-300	https://issues.apache.org/jira/browse/LANG-300	NumberUtils.createNumber throws NumberFormatException for one digit long	NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc... It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"	src/java
59	src/java/org/apache/commons/lang/text/StrBuilder.java内methodPartNotInFile:public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar)	38f8bcc60b90295f0a697f32e760a0082571bc09	c04cd2337786ce7d54ed1fb757192fb8bc8c5e41	LANG-299	https://issues.apache.org/jira/browse/LANG-299	Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException	There's a bug in method appendFixedWidthPadRight of class StrBuilder: public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {         if (width > 0) {             ensureCapacity(size + width);             String str = (obj == null ? getNullText() : obj.toString());             int strLen = str.length();             if (strLen >= width)  {  ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);             }  else {                 int padLen = width - strLen;                 str.getChars(0, strLen, buffer, size);                 for (int i = 0; i < padLen; i++)  {                     buffer[size + strLen + i] = padChar;                 }             }             size += width;         }         return this;     } This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width. It's counterpart method appendFixedWidthPadLeft seems to be ok.	src/java
60	src/java/org/apache/commons/lang/text/StrBuilder.java内public String midString(int index, int length)外src/java/org/apache/commons/lang/text/StrBuilder.java内public int indexOf(char ch, int startIndex)	88c76d207f642831ca899e144159424aaa60cf8e	a8203b65261110c4a30ff69fe0da7a2390d82757	LANG-295	https://issues.apache.org/jira/browse/LANG-295	StrBuilder contains usages of thisBuf.length when they should use size	While fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.	src/java
61	src/java/org/apache/commons/lang/text/StrBuilder.java内public int indexOf(String str, int startIndex)	1313a65c11dea54f1baf492d4185fb2d673b6716	88c76d207f642831ca899e144159424aaa60cf8e	LANG-294	https://issues.apache.org/jira/browse/LANG-294	StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.	StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsException's. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem: StrBuilder.deleteAll() - added to testDeleteAll_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.deleteAll("\n%BLAH%");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the following error: java.lang.ArrayIndexOutOfBoundsException  at java.lang.System.arraycopy(Native Method)  at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114)  at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188)  at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606)  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)  at java.lang.reflect.Method.invoke(Method.java:585)  at junit.framework.TestCase.runTest(TestCase.java:154)  at junit.framework.TestCase.runBare(TestCase.java:127)  at junit.framework.TestResult$1.protect(TestResult.java:106)  at junit.framework.TestResult.runProtected(TestResult.java:124)  at junit.framework.TestResult.run(TestResult.java:109)  at junit.framework.TestCase.run(TestCase.java:118)  at junit.framework.TestSuite.runTest(TestSuite.java:208)  at junit.framework.TestSuite.run(TestSuite.java:203)  at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128)  at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)  at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)  at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)  at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)  at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) StrBuilder.replaceAll() - added to testReplaceAll_String_String():         sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");         sb.replaceAll("\n%BLAH%", "");         assertEquals("\nDo more stuff\neven more stuff\n", sb.toString()); this causes the exception: java.lang.ArrayIndexOutOfBoundsException  at java.lang.System.arraycopy(Native Method)  at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256)  at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339)  at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763)  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)  at java.lang.reflect.Method.invoke(Method.java:585)  at junit.framework.TestCase.runTest(TestCase.java:154)  at junit.framework.TestCase.runBare(TestCase.java:127)  at junit.framework.TestResult$1.protect(TestResult.java:106)  at junit.framework.TestResult.runProtected(TestResult.java:124)  at junit.framework.TestResult.run(TestResult.java:109)  at junit.framework.TestCase.run(TestCase.java:118)  at junit.framework.TestSuite.runTest(TestSuite.java:208)  at junit.framework.TestSuite.run(TestSuite.java:203)  at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128)  at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)  at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)  at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)  at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)  at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)	src/java
62	src/java/org/apache/commons/lang/Entities.java内public String unescape(String str)外src/java/org/apache/commons/lang/Entities.java内public void unescape(Writer writer, String string)	cb7bfbc06d5d289be61733824d7f3e81321b2b3a	1313a65c11dea54f1baf492d4185fb2d673b6716	LANG-292	https://issues.apache.org/jira/browse/LANG-292	unescapeXml("&12345678;") should be "&12345678;"	Following test (in EntitiesTest.java) fails:     public void testNumberOverflow() throws Exception  {         doTestUnescapeEntity("&#12345678;", "&#12345678;");         doTestUnescapeEntity("x&#12345678;y", "x&#12345678;y");         doTestUnescapeEntity("&#x12345678;", "&#x12345678;");         doTestUnescapeEntity("x&#x12345678;y", "x&#x12345678;y");     }  Maximim value for char is 0xFFFF, so &#12345678; is invalid entity reference, and so should be left as is.	src/java
63	src/java/org/apache/commons/lang/time/DurationFormatUtils.java内methodPartNotInFile:public static String formatPeriod(long startMillis, long endMillis, String forma外src/java/org/apache/commons/lang/time/DurationFormatUtils.java内methodPartNotInFile:static String format(Token[] tokens, int years, int months, int days, int hours,	3333dcc11f2d65ee99043945502102dcf3bca50c	0695c3f71e3fc5abe29d8b9b33eed7faac7e73bf	LANG-281	https://issues.apache.org/jira/browse/LANG-281	DurationFormatUtils returns wrong result	DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005 The following code will result in a String of -2 which is way off. I've tested against 2.1 and 2.2.         Calendar cal = Calendar.getInstance();         cal.set(Calendar.MONTH, Calendar.DECEMBER);         cal.set(Calendar.DAY_OF_MONTH, 31);         cal.set(Calendar.YEAR, 2005);         cal.set(Calendar.HOUR_OF_DAY, 0);         cal.set(Calendar.MINUTE, 0);         cal.set(Calendar.SECOND, 0);         cal.set(Calendar.MILLISECOND, 0);         String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");         System.out.println(result);	src/java
64	src/java/org/apache/commons/lang/enums/ValuedEnum.java内public final int getValue()外src/java/org/apache/commons/lang/enums/ValuedEnum.java内public int compareTo(Object other)	df1653a8490feba4a21ad8aade5c960b402c3c7a	8de71ae52958ae70fe651b7327319c9beecd9b84	LANG-259	https://issues.apache.org/jira/browse/LANG-259	ValuedEnum.compareTo(Object other) not typesafe - it easily could be...	int org.apache.commons.lang.enums.ValuedEnum.compareTo(Object other)  is not typesafe - if the int-values are the same, it will return "0" even for two totally different sub-classes of ValuedEnum	src/java
65	src/java/org/apache/commons/lang/time/DateUtils.java内private static void modify(Calendar val, int field, boolean round)外src/java/org/apache/commons/lang/time/DateUtils.java内private static void modify(Calendar val, int field, boolean round)外src/java/org/apache/commons/lang/time/DateUtils.java内private static void modify(Calendar val, int field, boolean round)	c8fc5f3dff9491b076a1f76ed5a2584908b1db4f	bb1671667d9085fb76bd06af7f7ad91d2c1c8389	LANG-59	https://issues.apache.org/jira/browse/LANG-59	[lang] DateUtils.truncate method is buggy when dealing with DST switching hours	Try to truncate 2004-10-31 01:00:00 MDT by hour and you'll actually get 2004-10- 31 01:00:00 MST, which is one hour after the input hour.     // truncate 2004-10-31 01:00:00 MDT     Date oct31_01MDT = new Date(1099206000000L);         Date result = DateUtils.truncate(oct31_01MDT, Calendar.HOUR_OF_DAY);     assertEquals(oct31_01MDT, result);	src/java